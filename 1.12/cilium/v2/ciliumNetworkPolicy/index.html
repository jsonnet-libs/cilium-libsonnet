<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link href=https://jsonnet-libs.github.io/cilium-libsonnet/1.12/cilium/v2/ciliumNetworkPolicy/ rel=canonical><link rel=icon href=../../../../assets/images/favicon.png><meta name=generator content="mkdocs-1.4.0, mkdocs-material-8.5.6"><title>cilium.v2.ciliumNetworkPolicy - cilium jsonnet library</title><link rel=stylesheet href=../../../../assets/stylesheets/main.20d9efc8.min.css><link rel=stylesheet href=../../../../assets/stylesheets/palette.cbb835fc.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><link rel=stylesheet href=../../../../stylesheets/extra.css><script>__md_scope=new URL("../../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=indigo data-md-color-accent=indigo> <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#ciliumv2ciliumnetworkpolicy class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <header class=md-header data-md-component=header> <nav class="md-header__inner md-grid" aria-label=Header> <a href=../../../.. title="cilium jsonnet library" class="md-header__button md-logo" aria-label="cilium jsonnet library" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> cilium jsonnet library </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> cilium.v2.ciliumNetworkPolicy </span> </div> </div> </div> <form class=md-header__option data-md-component=palette> <input class=md-option data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme=default data-md-color-primary=indigo data-md-color-accent=indigo aria-label="Switch to dark mode" type=radio name=__palette id=__palette_1> <label class="md-header__button md-icon" title="Switch to dark mode" for=__palette_2 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6zm0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4zM7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg> </label> <input class=md-option data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme=slate data-md-color-primary=red data-md-color-accent=red aria-label="Switch to light mode" type=radio name=__palette id=__palette_2> <label class="md-header__button md-icon" title="Switch to light mode" for=__palette_1 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3Z"/></svg> </label> </form> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg> </label> <nav class=md-search__options aria-label=Search> <button type=reset class="md-search__icon md-icon" title=Clear aria-label=Clear tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg> </button> </nav> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/jsonnet-libs/cilium-libsonnet title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> jsonnet-libs/cilium-libsonnet </div> </a> </div> </nav> </header> <div class=md-container data-md-component=container> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=../../../.. title="cilium jsonnet library" class="md-nav__button md-logo" aria-label="cilium jsonnet library" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg> </a> cilium jsonnet library </label> <div class=md-nav__source> <a href=https://github.com/jsonnet-libs/cilium-libsonnet title="Go to repository" class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><!-- Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg> </div> <div class=md-source__repository> jsonnet-libs/cilium-libsonnet </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../.. class=md-nav__link> cilium Jsonnet library </a> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_2 type=checkbox id=__nav_2 checked> <label class=md-nav__link for=__nav_2> 1.12 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=1.12 data-md-level=1> <label class=md-nav__title for=__nav_2> <span class="md-nav__icon md-icon"></span> 1.12 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../../ class=md-nav__link> cilium </a> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_2_2 type=checkbox id=__nav_2_2 checked> <label class=md-nav__link for=__nav_2_2> Cilium <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Cilium data-md-level=2> <label class=md-nav__title for=__nav_2_2> <span class="md-nav__icon md-icon"></span> Cilium </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../ class=md-nav__link> cilium </a> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=__nav_2_2_2 type=checkbox id=__nav_2_2_2 checked> <label class=md-nav__link for=__nav_2_2_2> V2 <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=V2 data-md-level=3> <label class=md-nav__title for=__nav_2_2_2> <span class="md-nav__icon md-icon"></span> V2 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../ class=md-nav__link> cilium.v2 </a> </li> <li class=md-nav__item> <a href=../ciliumClusterwideEnvoyConfig/ class=md-nav__link> cilium.v2.ciliumClusterwideEnvoyConfig </a> </li> <li class=md-nav__item> <a href=../ciliumClusterwideNetworkPolicy/ class=md-nav__link> cilium.v2.ciliumClusterwideNetworkPolicy </a> </li> <li class=md-nav__item> <a href=../ciliumEgressGatewayPolicy/ class=md-nav__link> cilium.v2.ciliumEgressGatewayPolicy </a> </li> <li class=md-nav__item> <a href=../ciliumEndpoint/ class=md-nav__link> cilium.v2.ciliumEndpoint </a> </li> <li class=md-nav__item> <a href=../ciliumEnvoyConfig/ class=md-nav__link> cilium.v2.ciliumEnvoyConfig </a> </li> <li class=md-nav__item> <a href=../ciliumExternalWorkload/ class=md-nav__link> cilium.v2.ciliumExternalWorkload </a> </li> <li class=md-nav__item> <a href=../ciliumIdentity/ class=md-nav__link> cilium.v2.ciliumIdentity </a> </li> <li class=md-nav__item> <a href=../ciliumLocalRedirectPolicy/ class=md-nav__link> cilium.v2.ciliumLocalRedirectPolicy </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" data-md-toggle=toc type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> cilium.v2.ciliumNetworkPolicy <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> cilium.v2.ciliumNetworkPolicy </a> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#index class=md-nav__link> Index </a> </li> <li class=md-nav__item> <a href=#fields class=md-nav__link> Fields </a> <nav class=md-nav aria-label=Fields> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-new class=md-nav__link> fn new </a> </li> <li class=md-nav__item> <a href=#fn-withspecs class=md-nav__link> fn withSpecs </a> </li> <li class=md-nav__item> <a href=#fn-withspecsmixin class=md-nav__link> fn withSpecsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-metadata class=md-nav__link> obj metadata </a> <nav class=md-nav aria-label="obj metadata"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-metadatawithannotations class=md-nav__link> fn metadata.withAnnotations </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithannotationsmixin class=md-nav__link> fn metadata.withAnnotationsMixin </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithclustername class=md-nav__link> fn metadata.withClusterName </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithcreationtimestamp class=md-nav__link> fn metadata.withCreationTimestamp </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithdeletiongraceperiodseconds class=md-nav__link> fn metadata.withDeletionGracePeriodSeconds </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithdeletiontimestamp class=md-nav__link> fn metadata.withDeletionTimestamp </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithfinalizers class=md-nav__link> fn metadata.withFinalizers </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithfinalizersmixin class=md-nav__link> fn metadata.withFinalizersMixin </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithgeneratename class=md-nav__link> fn metadata.withGenerateName </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithgeneration class=md-nav__link> fn metadata.withGeneration </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithlabels class=md-nav__link> fn metadata.withLabels </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithlabelsmixin class=md-nav__link> fn metadata.withLabelsMixin </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithname class=md-nav__link> fn metadata.withName </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithnamespace class=md-nav__link> fn metadata.withNamespace </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithownerreferences class=md-nav__link> fn metadata.withOwnerReferences </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithownerreferencesmixin class=md-nav__link> fn metadata.withOwnerReferencesMixin </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithresourceversion class=md-nav__link> fn metadata.withResourceVersion </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithselflink class=md-nav__link> fn metadata.withSelfLink </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithuid class=md-nav__link> fn metadata.withUid </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-spec class=md-nav__link> obj spec </a> <nav class=md-nav aria-label="obj spec"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specwithdescription class=md-nav__link> fn spec.withDescription </a> </li> <li class=md-nav__item> <a href=#fn-specwithegress class=md-nav__link> fn spec.withEgress </a> </li> <li class=md-nav__item> <a href=#fn-specwithegressdeny class=md-nav__link> fn spec.withEgressDeny </a> </li> <li class=md-nav__item> <a href=#fn-specwithegressdenymixin class=md-nav__link> fn spec.withEgressDenyMixin </a> </li> <li class=md-nav__item> <a href=#fn-specwithegressmixin class=md-nav__link> fn spec.withEgressMixin </a> </li> <li class=md-nav__item> <a href=#fn-specwithingress class=md-nav__link> fn spec.withIngress </a> </li> <li class=md-nav__item> <a href=#fn-specwithingressdeny class=md-nav__link> fn spec.withIngressDeny </a> </li> <li class=md-nav__item> <a href=#fn-specwithingressdenymixin class=md-nav__link> fn spec.withIngressDenyMixin </a> </li> <li class=md-nav__item> <a href=#fn-specwithingressmixin class=md-nav__link> fn spec.withIngressMixin </a> </li> <li class=md-nav__item> <a href=#fn-specwithlabels class=md-nav__link> fn spec.withLabels </a> </li> <li class=md-nav__item> <a href=#fn-specwithlabelsmixin class=md-nav__link> fn spec.withLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegress class=md-nav__link> obj spec.egress </a> <nav class=md-nav aria-label="obj spec.egress"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresswithicmps class=md-nav__link> fn spec.egress.withIcmps </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithicmpsmixin class=md-nav__link> fn spec.egress.withIcmpsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtocidr class=md-nav__link> fn spec.egress.withToCIDR </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtocidrmixin class=md-nav__link> fn spec.egress.withToCIDRMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtocidrset class=md-nav__link> fn spec.egress.withToCIDRSet </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtocidrsetmixin class=md-nav__link> fn spec.egress.withToCIDRSetMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtoendpoints class=md-nav__link> fn spec.egress.withToEndpoints </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtoendpointsmixin class=md-nav__link> fn spec.egress.withToEndpointsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtoentities class=md-nav__link> fn spec.egress.withToEntities </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtoentitiesmixin class=md-nav__link> fn spec.egress.withToEntitiesMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtofqdns class=md-nav__link> fn spec.egress.withToFQDNs </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtofqdnsmixin class=md-nav__link> fn spec.egress.withToFQDNsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtogroups class=md-nav__link> fn spec.egress.withToGroups </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtogroupsmixin class=md-nav__link> fn spec.egress.withToGroupsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtoports class=md-nav__link> fn spec.egress.withToPorts </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtoportsmixin class=md-nav__link> fn spec.egress.withToPortsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtorequires class=md-nav__link> fn spec.egress.withToRequires </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtorequiresmixin class=md-nav__link> fn spec.egress.withToRequiresMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtoservices class=md-nav__link> fn spec.egress.withToServices </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtoservicesmixin class=md-nav__link> fn spec.egress.withToServicesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressicmps class=md-nav__link> obj spec.egress.icmps </a> <nav class=md-nav aria-label="obj spec.egress.icmps"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressicmpswithfields class=md-nav__link> fn spec.egress.icmps.withFields </a> </li> <li class=md-nav__item> <a href=#fn-specegressicmpswithfieldsmixin class=md-nav__link> fn spec.egress.icmps.withFieldsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressicmpsfields class=md-nav__link> obj spec.egress.icmps.fields </a> <nav class=md-nav aria-label="obj spec.egress.icmps.fields"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressicmpsfieldswithfamily class=md-nav__link> fn spec.egress.icmps.fields.withFamily </a> </li> <li class=md-nav__item> <a href=#fn-specegressicmpsfieldswithtype class=md-nav__link> fn spec.egress.icmps.fields.withType </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstocidrset class=md-nav__link> obj spec.egress.toCIDRSet </a> <nav class=md-nav aria-label="obj spec.egress.toCIDRSet"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstocidrsetwithcidr class=md-nav__link> fn spec.egress.toCIDRSet.withCidr </a> </li> <li class=md-nav__item> <a href=#fn-specegresstocidrsetwithexcept class=md-nav__link> fn spec.egress.toCIDRSet.withExcept </a> </li> <li class=md-nav__item> <a href=#fn-specegresstocidrsetwithexceptmixin class=md-nav__link> fn spec.egress.toCIDRSet.withExceptMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoendpoints class=md-nav__link> obj spec.egress.toEndpoints </a> <nav class=md-nav aria-label="obj spec.egress.toEndpoints"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoendpointswithmatchexpressions class=md-nav__link> fn spec.egress.toEndpoints.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoendpointswithmatchexpressionsmixin class=md-nav__link> fn spec.egress.toEndpoints.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoendpointswithmatchlabels class=md-nav__link> fn spec.egress.toEndpoints.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoendpointswithmatchlabelsmixin class=md-nav__link> fn spec.egress.toEndpoints.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoendpointsmatchexpressions class=md-nav__link> obj spec.egress.toEndpoints.matchExpressions </a> <nav class=md-nav aria-label="obj spec.egress.toEndpoints.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoendpointsmatchexpressionswithkey class=md-nav__link> fn spec.egress.toEndpoints.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoendpointsmatchexpressionswithoperator class=md-nav__link> fn spec.egress.toEndpoints.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoendpointsmatchexpressionswithvalues class=md-nav__link> fn spec.egress.toEndpoints.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoendpointsmatchexpressionswithvaluesmixin class=md-nav__link> fn spec.egress.toEndpoints.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstofqdns class=md-nav__link> obj spec.egress.toFQDNs </a> <nav class=md-nav aria-label="obj spec.egress.toFQDNs"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstofqdnswithmatchname class=md-nav__link> fn spec.egress.toFQDNs.withMatchName </a> </li> <li class=md-nav__item> <a href=#fn-specegresstofqdnswithmatchpattern class=md-nav__link> fn spec.egress.toFQDNs.withMatchPattern </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstogroups class=md-nav__link> obj spec.egress.toGroups </a> </li> <li class=md-nav__item> <a href=#obj-specegresstogroupsaws class=md-nav__link> obj spec.egress.toGroups.aws </a> <nav class=md-nav aria-label="obj spec.egress.toGroups.aws"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstogroupsawswithlabels class=md-nav__link> fn spec.egress.toGroups.aws.withLabels </a> </li> <li class=md-nav__item> <a href=#fn-specegresstogroupsawswithlabelsmixin class=md-nav__link> fn spec.egress.toGroups.aws.withLabelsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresstogroupsawswithregion class=md-nav__link> fn spec.egress.toGroups.aws.withRegion </a> </li> <li class=md-nav__item> <a href=#fn-specegresstogroupsawswithsecuritygroupsids class=md-nav__link> fn spec.egress.toGroups.aws.withSecurityGroupsIds </a> </li> <li class=md-nav__item> <a href=#fn-specegresstogroupsawswithsecuritygroupsidsmixin class=md-nav__link> fn spec.egress.toGroups.aws.withSecurityGroupsIdsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresstogroupsawswithsecuritygroupsnames class=md-nav__link> fn spec.egress.toGroups.aws.withSecurityGroupsNames </a> </li> <li class=md-nav__item> <a href=#fn-specegresstogroupsawswithsecuritygroupsnamesmixin class=md-nav__link> fn spec.egress.toGroups.aws.withSecurityGroupsNamesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoports class=md-nav__link> obj spec.egress.toPorts </a> <nav class=md-nav aria-label="obj spec.egress.toPorts"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoportswithports class=md-nav__link> fn spec.egress.toPorts.withPorts </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportswithportsmixin class=md-nav__link> fn spec.egress.toPorts.withPortsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoportsoriginatingtls class=md-nav__link> obj spec.egress.toPorts.originatingTLS </a> <nav class=md-nav aria-label="obj spec.egress.toPorts.originatingTLS"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoportsoriginatingtlswithcertificate class=md-nav__link> fn spec.egress.toPorts.originatingTLS.withCertificate </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsoriginatingtlswithprivatekey class=md-nav__link> fn spec.egress.toPorts.originatingTLS.withPrivateKey </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsoriginatingtlswithtrustedca class=md-nav__link> fn spec.egress.toPorts.originatingTLS.withTrustedCA </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoportsoriginatingtlssecret class=md-nav__link> obj spec.egress.toPorts.originatingTLS.secret </a> <nav class=md-nav aria-label="obj spec.egress.toPorts.originatingTLS.secret"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoportsoriginatingtlssecretwithname class=md-nav__link> fn spec.egress.toPorts.originatingTLS.secret.withName </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsoriginatingtlssecretwithnamespace class=md-nav__link> fn spec.egress.toPorts.originatingTLS.secret.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoportsports class=md-nav__link> obj spec.egress.toPorts.ports </a> <nav class=md-nav aria-label="obj spec.egress.toPorts.ports"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoportsportswithport class=md-nav__link> fn spec.egress.toPorts.ports.withPort </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsportswithprotocol class=md-nav__link> fn spec.egress.toPorts.ports.withProtocol </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoportsrules class=md-nav__link> obj spec.egress.toPorts.rules </a> <nav class=md-nav aria-label="obj spec.egress.toPorts.rules"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoportsruleswithdns class=md-nav__link> fn spec.egress.toPorts.rules.withDns </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleswithdnsmixin class=md-nav__link> fn spec.egress.toPorts.rules.withDnsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleswithhttp class=md-nav__link> fn spec.egress.toPorts.rules.withHttp </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleswithhttpmixin class=md-nav__link> fn spec.egress.toPorts.rules.withHttpMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleswithkafka class=md-nav__link> fn spec.egress.toPorts.rules.withKafka </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleswithkafkamixin class=md-nav__link> fn spec.egress.toPorts.rules.withKafkaMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleswithl7 class=md-nav__link> fn spec.egress.toPorts.rules.withL7 </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleswithl7mixin class=md-nav__link> fn spec.egress.toPorts.rules.withL7Mixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleswithl7proto class=md-nav__link> fn spec.egress.toPorts.rules.withL7proto </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoportsrulesdns class=md-nav__link> obj spec.egress.toPorts.rules.dns </a> <nav class=md-nav aria-label="obj spec.egress.toPorts.rules.dns"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoportsrulesdnswithmatchname class=md-nav__link> fn spec.egress.toPorts.rules.dns.withMatchName </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsrulesdnswithmatchpattern class=md-nav__link> fn spec.egress.toPorts.rules.dns.withMatchPattern </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoportsruleshttp class=md-nav__link> obj spec.egress.toPorts.rules.http </a> <nav class=md-nav aria-label="obj spec.egress.toPorts.rules.http"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoportsruleshttpwithheadermatches class=md-nav__link> fn spec.egress.toPorts.rules.http.withHeaderMatches </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleshttpwithheadermatchesmixin class=md-nav__link> fn spec.egress.toPorts.rules.http.withHeaderMatchesMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleshttpwithheaders class=md-nav__link> fn spec.egress.toPorts.rules.http.withHeaders </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleshttpwithheadersmixin class=md-nav__link> fn spec.egress.toPorts.rules.http.withHeadersMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleshttpwithhost class=md-nav__link> fn spec.egress.toPorts.rules.http.withHost </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleshttpwithmethod class=md-nav__link> fn spec.egress.toPorts.rules.http.withMethod </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleshttpwithpath class=md-nav__link> fn spec.egress.toPorts.rules.http.withPath </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoportsruleshttpheadermatches class=md-nav__link> obj spec.egress.toPorts.rules.http.headerMatches </a> <nav class=md-nav aria-label="obj spec.egress.toPorts.rules.http.headerMatches"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoportsruleshttpheadermatcheswithmismatch class=md-nav__link> fn spec.egress.toPorts.rules.http.headerMatches.withMismatch </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleshttpheadermatcheswithname class=md-nav__link> fn spec.egress.toPorts.rules.http.headerMatches.withName </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleshttpheadermatcheswithvalue class=md-nav__link> fn spec.egress.toPorts.rules.http.headerMatches.withValue </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoportsruleshttpheadermatchessecret class=md-nav__link> obj spec.egress.toPorts.rules.http.headerMatches.secret </a> <nav class=md-nav aria-label="obj spec.egress.toPorts.rules.http.headerMatches.secret"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoportsruleshttpheadermatchessecretwithname class=md-nav__link> fn spec.egress.toPorts.rules.http.headerMatches.secret.withName </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleshttpheadermatchessecretwithnamespace class=md-nav__link> fn spec.egress.toPorts.rules.http.headerMatches.secret.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoportsruleskafka class=md-nav__link> obj spec.egress.toPorts.rules.kafka </a> <nav class=md-nav aria-label="obj spec.egress.toPorts.rules.kafka"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoportsruleskafkawithapikey class=md-nav__link> fn spec.egress.toPorts.rules.kafka.withApiKey </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleskafkawithapiversion class=md-nav__link> fn spec.egress.toPorts.rules.kafka.withApiVersion </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleskafkawithclientid class=md-nav__link> fn spec.egress.toPorts.rules.kafka.withClientID </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleskafkawithrole class=md-nav__link> fn spec.egress.toPorts.rules.kafka.withRole </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleskafkawithtopic class=md-nav__link> fn spec.egress.toPorts.rules.kafka.withTopic </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoportsterminatingtls class=md-nav__link> obj spec.egress.toPorts.terminatingTLS </a> <nav class=md-nav aria-label="obj spec.egress.toPorts.terminatingTLS"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoportsterminatingtlswithcertificate class=md-nav__link> fn spec.egress.toPorts.terminatingTLS.withCertificate </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsterminatingtlswithprivatekey class=md-nav__link> fn spec.egress.toPorts.terminatingTLS.withPrivateKey </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsterminatingtlswithtrustedca class=md-nav__link> fn spec.egress.toPorts.terminatingTLS.withTrustedCA </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoportsterminatingtlssecret class=md-nav__link> obj spec.egress.toPorts.terminatingTLS.secret </a> <nav class=md-nav aria-label="obj spec.egress.toPorts.terminatingTLS.secret"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoportsterminatingtlssecretwithname class=md-nav__link> fn spec.egress.toPorts.terminatingTLS.secret.withName </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsterminatingtlssecretwithnamespace class=md-nav__link> fn spec.egress.toPorts.terminatingTLS.secret.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstorequires class=md-nav__link> obj spec.egress.toRequires </a> <nav class=md-nav aria-label="obj spec.egress.toRequires"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstorequireswithmatchexpressions class=md-nav__link> fn spec.egress.toRequires.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specegresstorequireswithmatchexpressionsmixin class=md-nav__link> fn spec.egress.toRequires.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresstorequireswithmatchlabels class=md-nav__link> fn spec.egress.toRequires.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specegresstorequireswithmatchlabelsmixin class=md-nav__link> fn spec.egress.toRequires.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstorequiresmatchexpressions class=md-nav__link> obj spec.egress.toRequires.matchExpressions </a> <nav class=md-nav aria-label="obj spec.egress.toRequires.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstorequiresmatchexpressionswithkey class=md-nav__link> fn spec.egress.toRequires.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specegresstorequiresmatchexpressionswithoperator class=md-nav__link> fn spec.egress.toRequires.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specegresstorequiresmatchexpressionswithvalues class=md-nav__link> fn spec.egress.toRequires.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specegresstorequiresmatchexpressionswithvaluesmixin class=md-nav__link> fn spec.egress.toRequires.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoservices class=md-nav__link> obj spec.egress.toServices </a> </li> <li class=md-nav__item> <a href=#obj-specegresstoservicesk8sservice class=md-nav__link> obj spec.egress.toServices.k8sService </a> <nav class=md-nav aria-label="obj spec.egress.toServices.k8sService"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoservicesk8sservicewithnamespace class=md-nav__link> fn spec.egress.toServices.k8sService.withNamespace </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoservicesk8sservicewithservicename class=md-nav__link> fn spec.egress.toServices.k8sService.withServiceName </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoservicesk8sserviceselector class=md-nav__link> obj spec.egress.toServices.k8sServiceSelector </a> <nav class=md-nav aria-label="obj spec.egress.toServices.k8sServiceSelector"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoservicesk8sserviceselectorwithnamespace class=md-nav__link> fn spec.egress.toServices.k8sServiceSelector.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoservicesk8sserviceselectorselector class=md-nav__link> obj spec.egress.toServices.k8sServiceSelector.selector </a> <nav class=md-nav aria-label="obj spec.egress.toServices.k8sServiceSelector.selector"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoservicesk8sserviceselectorselectorwithmatchexpressions class=md-nav__link> fn spec.egress.toServices.k8sServiceSelector.selector.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoservicesk8sserviceselectorselectorwithmatchexpressionsmixin class=md-nav__link> fn spec.egress.toServices.k8sServiceSelector.selector.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoservicesk8sserviceselectorselectorwithmatchlabels class=md-nav__link> fn spec.egress.toServices.k8sServiceSelector.selector.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoservicesk8sserviceselectorselectorwithmatchlabelsmixin class=md-nav__link> fn spec.egress.toServices.k8sServiceSelector.selector.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoservicesk8sserviceselectorselectormatchexpressions class=md-nav__link> obj spec.egress.toServices.k8sServiceSelector.selector.matchExpressions </a> <nav class=md-nav aria-label="obj spec.egress.toServices.k8sServiceSelector.selector.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoservicesk8sserviceselectorselectormatchexpressionswithkey class=md-nav__link> fn spec.egress.toServices.k8sServiceSelector.selector.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoservicesk8sserviceselectorselectormatchexpressionswithoperator class=md-nav__link> fn spec.egress.toServices.k8sServiceSelector.selector.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoservicesk8sserviceselectorselectormatchexpressionswithvalues class=md-nav__link> fn spec.egress.toServices.k8sServiceSelector.selector.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoservicesk8sserviceselectorselectormatchexpressionswithvaluesmixin class=md-nav__link> fn spec.egress.toServices.k8sServiceSelector.selector.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdeny class=md-nav__link> obj spec.egressDeny </a> <nav class=md-nav aria-label="obj spec.egressDeny"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenywithicmps class=md-nav__link> fn spec.egressDeny.withIcmps </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithicmpsmixin class=md-nav__link> fn spec.egressDeny.withIcmpsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtocidr class=md-nav__link> fn spec.egressDeny.withToCIDR </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtocidrmixin class=md-nav__link> fn spec.egressDeny.withToCIDRMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtocidrset class=md-nav__link> fn spec.egressDeny.withToCIDRSet </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtocidrsetmixin class=md-nav__link> fn spec.egressDeny.withToCIDRSetMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtoendpoints class=md-nav__link> fn spec.egressDeny.withToEndpoints </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtoendpointsmixin class=md-nav__link> fn spec.egressDeny.withToEndpointsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtoentities class=md-nav__link> fn spec.egressDeny.withToEntities </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtoentitiesmixin class=md-nav__link> fn spec.egressDeny.withToEntitiesMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtogroups class=md-nav__link> fn spec.egressDeny.withToGroups </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtogroupsmixin class=md-nav__link> fn spec.egressDeny.withToGroupsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtoports class=md-nav__link> fn spec.egressDeny.withToPorts </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtoportsmixin class=md-nav__link> fn spec.egressDeny.withToPortsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtorequires class=md-nav__link> fn spec.egressDeny.withToRequires </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtorequiresmixin class=md-nav__link> fn spec.egressDeny.withToRequiresMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtoservices class=md-nav__link> fn spec.egressDeny.withToServices </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtoservicesmixin class=md-nav__link> fn spec.egressDeny.withToServicesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdenyicmps class=md-nav__link> obj spec.egressDeny.icmps </a> <nav class=md-nav aria-label="obj spec.egressDeny.icmps"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenyicmpswithfields class=md-nav__link> fn spec.egressDeny.icmps.withFields </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenyicmpswithfieldsmixin class=md-nav__link> fn spec.egressDeny.icmps.withFieldsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdenyicmpsfields class=md-nav__link> obj spec.egressDeny.icmps.fields </a> <nav class=md-nav aria-label="obj spec.egressDeny.icmps.fields"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenyicmpsfieldswithfamily class=md-nav__link> fn spec.egressDeny.icmps.fields.withFamily </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenyicmpsfieldswithtype class=md-nav__link> fn spec.egressDeny.icmps.fields.withType </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdenytocidrset class=md-nav__link> obj spec.egressDeny.toCIDRSet </a> <nav class=md-nav aria-label="obj spec.egressDeny.toCIDRSet"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenytocidrsetwithcidr class=md-nav__link> fn spec.egressDeny.toCIDRSet.withCidr </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytocidrsetwithexcept class=md-nav__link> fn spec.egressDeny.toCIDRSet.withExcept </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytocidrsetwithexceptmixin class=md-nav__link> fn spec.egressDeny.toCIDRSet.withExceptMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdenytoendpoints class=md-nav__link> obj spec.egressDeny.toEndpoints </a> <nav class=md-nav aria-label="obj spec.egressDeny.toEndpoints"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenytoendpointswithmatchexpressions class=md-nav__link> fn spec.egressDeny.toEndpoints.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoendpointswithmatchexpressionsmixin class=md-nav__link> fn spec.egressDeny.toEndpoints.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoendpointswithmatchlabels class=md-nav__link> fn spec.egressDeny.toEndpoints.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoendpointswithmatchlabelsmixin class=md-nav__link> fn spec.egressDeny.toEndpoints.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdenytoendpointsmatchexpressions class=md-nav__link> obj spec.egressDeny.toEndpoints.matchExpressions </a> <nav class=md-nav aria-label="obj spec.egressDeny.toEndpoints.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenytoendpointsmatchexpressionswithkey class=md-nav__link> fn spec.egressDeny.toEndpoints.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoendpointsmatchexpressionswithoperator class=md-nav__link> fn spec.egressDeny.toEndpoints.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoendpointsmatchexpressionswithvalues class=md-nav__link> fn spec.egressDeny.toEndpoints.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoendpointsmatchexpressionswithvaluesmixin class=md-nav__link> fn spec.egressDeny.toEndpoints.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdenytogroups class=md-nav__link> obj spec.egressDeny.toGroups </a> </li> <li class=md-nav__item> <a href=#obj-specegressdenytogroupsaws class=md-nav__link> obj spec.egressDeny.toGroups.aws </a> <nav class=md-nav aria-label="obj spec.egressDeny.toGroups.aws"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenytogroupsawswithlabels class=md-nav__link> fn spec.egressDeny.toGroups.aws.withLabels </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytogroupsawswithlabelsmixin class=md-nav__link> fn spec.egressDeny.toGroups.aws.withLabelsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytogroupsawswithregion class=md-nav__link> fn spec.egressDeny.toGroups.aws.withRegion </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytogroupsawswithsecuritygroupsids class=md-nav__link> fn spec.egressDeny.toGroups.aws.withSecurityGroupsIds </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytogroupsawswithsecuritygroupsidsmixin class=md-nav__link> fn spec.egressDeny.toGroups.aws.withSecurityGroupsIdsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytogroupsawswithsecuritygroupsnames class=md-nav__link> fn spec.egressDeny.toGroups.aws.withSecurityGroupsNames </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytogroupsawswithsecuritygroupsnamesmixin class=md-nav__link> fn spec.egressDeny.toGroups.aws.withSecurityGroupsNamesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdenytoports class=md-nav__link> obj spec.egressDeny.toPorts </a> <nav class=md-nav aria-label="obj spec.egressDeny.toPorts"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenytoportswithports class=md-nav__link> fn spec.egressDeny.toPorts.withPorts </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoportswithportsmixin class=md-nav__link> fn spec.egressDeny.toPorts.withPortsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdenytoportsports class=md-nav__link> obj spec.egressDeny.toPorts.ports </a> <nav class=md-nav aria-label="obj spec.egressDeny.toPorts.ports"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenytoportsportswithport class=md-nav__link> fn spec.egressDeny.toPorts.ports.withPort </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoportsportswithprotocol class=md-nav__link> fn spec.egressDeny.toPorts.ports.withProtocol </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdenytorequires class=md-nav__link> obj spec.egressDeny.toRequires </a> <nav class=md-nav aria-label="obj spec.egressDeny.toRequires"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenytorequireswithmatchexpressions class=md-nav__link> fn spec.egressDeny.toRequires.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytorequireswithmatchexpressionsmixin class=md-nav__link> fn spec.egressDeny.toRequires.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytorequireswithmatchlabels class=md-nav__link> fn spec.egressDeny.toRequires.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytorequireswithmatchlabelsmixin class=md-nav__link> fn spec.egressDeny.toRequires.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdenytorequiresmatchexpressions class=md-nav__link> obj spec.egressDeny.toRequires.matchExpressions </a> <nav class=md-nav aria-label="obj spec.egressDeny.toRequires.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenytorequiresmatchexpressionswithkey class=md-nav__link> fn spec.egressDeny.toRequires.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytorequiresmatchexpressionswithoperator class=md-nav__link> fn spec.egressDeny.toRequires.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytorequiresmatchexpressionswithvalues class=md-nav__link> fn spec.egressDeny.toRequires.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytorequiresmatchexpressionswithvaluesmixin class=md-nav__link> fn spec.egressDeny.toRequires.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdenytoservices class=md-nav__link> obj spec.egressDeny.toServices </a> </li> <li class=md-nav__item> <a href=#obj-specegressdenytoservicesk8sservice class=md-nav__link> obj spec.egressDeny.toServices.k8sService </a> <nav class=md-nav aria-label="obj spec.egressDeny.toServices.k8sService"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenytoservicesk8sservicewithnamespace class=md-nav__link> fn spec.egressDeny.toServices.k8sService.withNamespace </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoservicesk8sservicewithservicename class=md-nav__link> fn spec.egressDeny.toServices.k8sService.withServiceName </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdenytoservicesk8sserviceselector class=md-nav__link> obj spec.egressDeny.toServices.k8sServiceSelector </a> <nav class=md-nav aria-label="obj spec.egressDeny.toServices.k8sServiceSelector"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenytoservicesk8sserviceselectorwithnamespace class=md-nav__link> fn spec.egressDeny.toServices.k8sServiceSelector.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdenytoservicesk8sserviceselectorselector class=md-nav__link> obj spec.egressDeny.toServices.k8sServiceSelector.selector </a> <nav class=md-nav aria-label="obj spec.egressDeny.toServices.k8sServiceSelector.selector"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenytoservicesk8sserviceselectorselectorwithmatchexpressions class=md-nav__link> fn spec.egressDeny.toServices.k8sServiceSelector.selector.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoservicesk8sserviceselectorselectorwithmatchexpressionsmixin class=md-nav__link> fn spec.egressDeny.toServices.k8sServiceSelector.selector.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoservicesk8sserviceselectorselectorwithmatchlabels class=md-nav__link> fn spec.egressDeny.toServices.k8sServiceSelector.selector.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoservicesk8sserviceselectorselectorwithmatchlabelsmixin class=md-nav__link> fn spec.egressDeny.toServices.k8sServiceSelector.selector.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdenytoservicesk8sserviceselectorselectormatchexpressions class=md-nav__link> obj spec.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions </a> <nav class=md-nav aria-label="obj spec.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenytoservicesk8sserviceselectorselectormatchexpressionswithkey class=md-nav__link> fn spec.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoservicesk8sserviceselectorselectormatchexpressionswithoperator class=md-nav__link> fn spec.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoservicesk8sserviceselectorselectormatchexpressionswithvalues class=md-nav__link> fn spec.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoservicesk8sserviceselectorselectormatchexpressionswithvaluesmixin class=md-nav__link> fn spec.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specendpointselector class=md-nav__link> obj spec.endpointSelector </a> <nav class=md-nav aria-label="obj spec.endpointSelector"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specendpointselectorwithmatchexpressions class=md-nav__link> fn spec.endpointSelector.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specendpointselectorwithmatchexpressionsmixin class=md-nav__link> fn spec.endpointSelector.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specendpointselectorwithmatchlabels class=md-nav__link> fn spec.endpointSelector.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specendpointselectorwithmatchlabelsmixin class=md-nav__link> fn spec.endpointSelector.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specendpointselectormatchexpressions class=md-nav__link> obj spec.endpointSelector.matchExpressions </a> <nav class=md-nav aria-label="obj spec.endpointSelector.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specendpointselectormatchexpressionswithkey class=md-nav__link> fn spec.endpointSelector.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specendpointselectormatchexpressionswithoperator class=md-nav__link> fn spec.endpointSelector.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specendpointselectormatchexpressionswithvalues class=md-nav__link> fn spec.endpointSelector.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specendpointselectormatchexpressionswithvaluesmixin class=md-nav__link> fn spec.endpointSelector.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingress class=md-nav__link> obj spec.ingress </a> <nav class=md-nav aria-label="obj spec.ingress"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingresswithfromcidr class=md-nav__link> fn spec.ingress.withFromCIDR </a> </li> <li class=md-nav__item> <a href=#fn-specingresswithfromcidrmixin class=md-nav__link> fn spec.ingress.withFromCIDRMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingresswithfromcidrset class=md-nav__link> fn spec.ingress.withFromCIDRSet </a> </li> <li class=md-nav__item> <a href=#fn-specingresswithfromcidrsetmixin class=md-nav__link> fn spec.ingress.withFromCIDRSetMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingresswithfromendpoints class=md-nav__link> fn spec.ingress.withFromEndpoints </a> </li> <li class=md-nav__item> <a href=#fn-specingresswithfromendpointsmixin class=md-nav__link> fn spec.ingress.withFromEndpointsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingresswithfromentities class=md-nav__link> fn spec.ingress.withFromEntities </a> </li> <li class=md-nav__item> <a href=#fn-specingresswithfromentitiesmixin class=md-nav__link> fn spec.ingress.withFromEntitiesMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingresswithfromrequires class=md-nav__link> fn spec.ingress.withFromRequires </a> </li> <li class=md-nav__item> <a href=#fn-specingresswithfromrequiresmixin class=md-nav__link> fn spec.ingress.withFromRequiresMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingresswithicmps class=md-nav__link> fn spec.ingress.withIcmps </a> </li> <li class=md-nav__item> <a href=#fn-specingresswithicmpsmixin class=md-nav__link> fn spec.ingress.withIcmpsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingresswithtoports class=md-nav__link> fn spec.ingress.withToPorts </a> </li> <li class=md-nav__item> <a href=#fn-specingresswithtoportsmixin class=md-nav__link> fn spec.ingress.withToPortsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressfromcidrset class=md-nav__link> obj spec.ingress.fromCIDRSet </a> <nav class=md-nav aria-label="obj spec.ingress.fromCIDRSet"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressfromcidrsetwithcidr class=md-nav__link> fn spec.ingress.fromCIDRSet.withCidr </a> </li> <li class=md-nav__item> <a href=#fn-specingressfromcidrsetwithexcept class=md-nav__link> fn spec.ingress.fromCIDRSet.withExcept </a> </li> <li class=md-nav__item> <a href=#fn-specingressfromcidrsetwithexceptmixin class=md-nav__link> fn spec.ingress.fromCIDRSet.withExceptMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressfromendpoints class=md-nav__link> obj spec.ingress.fromEndpoints </a> <nav class=md-nav aria-label="obj spec.ingress.fromEndpoints"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressfromendpointswithmatchexpressions class=md-nav__link> fn spec.ingress.fromEndpoints.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specingressfromendpointswithmatchexpressionsmixin class=md-nav__link> fn spec.ingress.fromEndpoints.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingressfromendpointswithmatchlabels class=md-nav__link> fn spec.ingress.fromEndpoints.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specingressfromendpointswithmatchlabelsmixin class=md-nav__link> fn spec.ingress.fromEndpoints.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressfromendpointsmatchexpressions class=md-nav__link> obj spec.ingress.fromEndpoints.matchExpressions </a> <nav class=md-nav aria-label="obj spec.ingress.fromEndpoints.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressfromendpointsmatchexpressionswithkey class=md-nav__link> fn spec.ingress.fromEndpoints.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specingressfromendpointsmatchexpressionswithoperator class=md-nav__link> fn spec.ingress.fromEndpoints.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specingressfromendpointsmatchexpressionswithvalues class=md-nav__link> fn spec.ingress.fromEndpoints.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specingressfromendpointsmatchexpressionswithvaluesmixin class=md-nav__link> fn spec.ingress.fromEndpoints.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressfromrequires class=md-nav__link> obj spec.ingress.fromRequires </a> <nav class=md-nav aria-label="obj spec.ingress.fromRequires"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressfromrequireswithmatchexpressions class=md-nav__link> fn spec.ingress.fromRequires.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specingressfromrequireswithmatchexpressionsmixin class=md-nav__link> fn spec.ingress.fromRequires.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingressfromrequireswithmatchlabels class=md-nav__link> fn spec.ingress.fromRequires.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specingressfromrequireswithmatchlabelsmixin class=md-nav__link> fn spec.ingress.fromRequires.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressfromrequiresmatchexpressions class=md-nav__link> obj spec.ingress.fromRequires.matchExpressions </a> <nav class=md-nav aria-label="obj spec.ingress.fromRequires.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressfromrequiresmatchexpressionswithkey class=md-nav__link> fn spec.ingress.fromRequires.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specingressfromrequiresmatchexpressionswithoperator class=md-nav__link> fn spec.ingress.fromRequires.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specingressfromrequiresmatchexpressionswithvalues class=md-nav__link> fn spec.ingress.fromRequires.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specingressfromrequiresmatchexpressionswithvaluesmixin class=md-nav__link> fn spec.ingress.fromRequires.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressicmps class=md-nav__link> obj spec.ingress.icmps </a> <nav class=md-nav aria-label="obj spec.ingress.icmps"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressicmpswithfields class=md-nav__link> fn spec.ingress.icmps.withFields </a> </li> <li class=md-nav__item> <a href=#fn-specingressicmpswithfieldsmixin class=md-nav__link> fn spec.ingress.icmps.withFieldsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressicmpsfields class=md-nav__link> obj spec.ingress.icmps.fields </a> <nav class=md-nav aria-label="obj spec.ingress.icmps.fields"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressicmpsfieldswithfamily class=md-nav__link> fn spec.ingress.icmps.fields.withFamily </a> </li> <li class=md-nav__item> <a href=#fn-specingressicmpsfieldswithtype class=md-nav__link> fn spec.ingress.icmps.fields.withType </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingresstoports class=md-nav__link> obj spec.ingress.toPorts </a> <nav class=md-nav aria-label="obj spec.ingress.toPorts"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingresstoportswithports class=md-nav__link> fn spec.ingress.toPorts.withPorts </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportswithportsmixin class=md-nav__link> fn spec.ingress.toPorts.withPortsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingresstoportsoriginatingtls class=md-nav__link> obj spec.ingress.toPorts.originatingTLS </a> <nav class=md-nav aria-label="obj spec.ingress.toPorts.originatingTLS"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingresstoportsoriginatingtlswithcertificate class=md-nav__link> fn spec.ingress.toPorts.originatingTLS.withCertificate </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsoriginatingtlswithprivatekey class=md-nav__link> fn spec.ingress.toPorts.originatingTLS.withPrivateKey </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsoriginatingtlswithtrustedca class=md-nav__link> fn spec.ingress.toPorts.originatingTLS.withTrustedCA </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingresstoportsoriginatingtlssecret class=md-nav__link> obj spec.ingress.toPorts.originatingTLS.secret </a> <nav class=md-nav aria-label="obj spec.ingress.toPorts.originatingTLS.secret"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingresstoportsoriginatingtlssecretwithname class=md-nav__link> fn spec.ingress.toPorts.originatingTLS.secret.withName </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsoriginatingtlssecretwithnamespace class=md-nav__link> fn spec.ingress.toPorts.originatingTLS.secret.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingresstoportsports class=md-nav__link> obj spec.ingress.toPorts.ports </a> <nav class=md-nav aria-label="obj spec.ingress.toPorts.ports"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingresstoportsportswithport class=md-nav__link> fn spec.ingress.toPorts.ports.withPort </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsportswithprotocol class=md-nav__link> fn spec.ingress.toPorts.ports.withProtocol </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingresstoportsrules class=md-nav__link> obj spec.ingress.toPorts.rules </a> <nav class=md-nav aria-label="obj spec.ingress.toPorts.rules"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingresstoportsruleswithdns class=md-nav__link> fn spec.ingress.toPorts.rules.withDns </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleswithdnsmixin class=md-nav__link> fn spec.ingress.toPorts.rules.withDnsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleswithhttp class=md-nav__link> fn spec.ingress.toPorts.rules.withHttp </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleswithhttpmixin class=md-nav__link> fn spec.ingress.toPorts.rules.withHttpMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleswithkafka class=md-nav__link> fn spec.ingress.toPorts.rules.withKafka </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleswithkafkamixin class=md-nav__link> fn spec.ingress.toPorts.rules.withKafkaMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleswithl7 class=md-nav__link> fn spec.ingress.toPorts.rules.withL7 </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleswithl7mixin class=md-nav__link> fn spec.ingress.toPorts.rules.withL7Mixin </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleswithl7proto class=md-nav__link> fn spec.ingress.toPorts.rules.withL7proto </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingresstoportsrulesdns class=md-nav__link> obj spec.ingress.toPorts.rules.dns </a> <nav class=md-nav aria-label="obj spec.ingress.toPorts.rules.dns"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingresstoportsrulesdnswithmatchname class=md-nav__link> fn spec.ingress.toPorts.rules.dns.withMatchName </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsrulesdnswithmatchpattern class=md-nav__link> fn spec.ingress.toPorts.rules.dns.withMatchPattern </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingresstoportsruleshttp class=md-nav__link> obj spec.ingress.toPorts.rules.http </a> <nav class=md-nav aria-label="obj spec.ingress.toPorts.rules.http"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingresstoportsruleshttpwithheadermatches class=md-nav__link> fn spec.ingress.toPorts.rules.http.withHeaderMatches </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleshttpwithheadermatchesmixin class=md-nav__link> fn spec.ingress.toPorts.rules.http.withHeaderMatchesMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleshttpwithheaders class=md-nav__link> fn spec.ingress.toPorts.rules.http.withHeaders </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleshttpwithheadersmixin class=md-nav__link> fn spec.ingress.toPorts.rules.http.withHeadersMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleshttpwithhost class=md-nav__link> fn spec.ingress.toPorts.rules.http.withHost </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleshttpwithmethod class=md-nav__link> fn spec.ingress.toPorts.rules.http.withMethod </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleshttpwithpath class=md-nav__link> fn spec.ingress.toPorts.rules.http.withPath </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingresstoportsruleshttpheadermatches class=md-nav__link> obj spec.ingress.toPorts.rules.http.headerMatches </a> <nav class=md-nav aria-label="obj spec.ingress.toPorts.rules.http.headerMatches"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingresstoportsruleshttpheadermatcheswithmismatch class=md-nav__link> fn spec.ingress.toPorts.rules.http.headerMatches.withMismatch </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleshttpheadermatcheswithname class=md-nav__link> fn spec.ingress.toPorts.rules.http.headerMatches.withName </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleshttpheadermatcheswithvalue class=md-nav__link> fn spec.ingress.toPorts.rules.http.headerMatches.withValue </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingresstoportsruleshttpheadermatchessecret class=md-nav__link> obj spec.ingress.toPorts.rules.http.headerMatches.secret </a> <nav class=md-nav aria-label="obj spec.ingress.toPorts.rules.http.headerMatches.secret"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingresstoportsruleshttpheadermatchessecretwithname class=md-nav__link> fn spec.ingress.toPorts.rules.http.headerMatches.secret.withName </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleshttpheadermatchessecretwithnamespace class=md-nav__link> fn spec.ingress.toPorts.rules.http.headerMatches.secret.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingresstoportsruleskafka class=md-nav__link> obj spec.ingress.toPorts.rules.kafka </a> <nav class=md-nav aria-label="obj spec.ingress.toPorts.rules.kafka"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingresstoportsruleskafkawithapikey class=md-nav__link> fn spec.ingress.toPorts.rules.kafka.withApiKey </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleskafkawithapiversion class=md-nav__link> fn spec.ingress.toPorts.rules.kafka.withApiVersion </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleskafkawithclientid class=md-nav__link> fn spec.ingress.toPorts.rules.kafka.withClientID </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleskafkawithrole class=md-nav__link> fn spec.ingress.toPorts.rules.kafka.withRole </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleskafkawithtopic class=md-nav__link> fn spec.ingress.toPorts.rules.kafka.withTopic </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingresstoportsterminatingtls class=md-nav__link> obj spec.ingress.toPorts.terminatingTLS </a> <nav class=md-nav aria-label="obj spec.ingress.toPorts.terminatingTLS"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingresstoportsterminatingtlswithcertificate class=md-nav__link> fn spec.ingress.toPorts.terminatingTLS.withCertificate </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsterminatingtlswithprivatekey class=md-nav__link> fn spec.ingress.toPorts.terminatingTLS.withPrivateKey </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsterminatingtlswithtrustedca class=md-nav__link> fn spec.ingress.toPorts.terminatingTLS.withTrustedCA </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingresstoportsterminatingtlssecret class=md-nav__link> obj spec.ingress.toPorts.terminatingTLS.secret </a> <nav class=md-nav aria-label="obj spec.ingress.toPorts.terminatingTLS.secret"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingresstoportsterminatingtlssecretwithname class=md-nav__link> fn spec.ingress.toPorts.terminatingTLS.secret.withName </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsterminatingtlssecretwithnamespace class=md-nav__link> fn spec.ingress.toPorts.terminatingTLS.secret.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressdeny class=md-nav__link> obj spec.ingressDeny </a> <nav class=md-nav aria-label="obj spec.ingressDeny"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressdenywithfromcidr class=md-nav__link> fn spec.ingressDeny.withFromCIDR </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenywithfromcidrmixin class=md-nav__link> fn spec.ingressDeny.withFromCIDRMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenywithfromcidrset class=md-nav__link> fn spec.ingressDeny.withFromCIDRSet </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenywithfromcidrsetmixin class=md-nav__link> fn spec.ingressDeny.withFromCIDRSetMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenywithfromendpoints class=md-nav__link> fn spec.ingressDeny.withFromEndpoints </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenywithfromendpointsmixin class=md-nav__link> fn spec.ingressDeny.withFromEndpointsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenywithfromentities class=md-nav__link> fn spec.ingressDeny.withFromEntities </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenywithfromentitiesmixin class=md-nav__link> fn spec.ingressDeny.withFromEntitiesMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenywithfromrequires class=md-nav__link> fn spec.ingressDeny.withFromRequires </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenywithfromrequiresmixin class=md-nav__link> fn spec.ingressDeny.withFromRequiresMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenywithicmps class=md-nav__link> fn spec.ingressDeny.withIcmps </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenywithicmpsmixin class=md-nav__link> fn spec.ingressDeny.withIcmpsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenywithtoports class=md-nav__link> fn spec.ingressDeny.withToPorts </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenywithtoportsmixin class=md-nav__link> fn spec.ingressDeny.withToPortsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressdenyfromcidrset class=md-nav__link> obj spec.ingressDeny.fromCIDRSet </a> <nav class=md-nav aria-label="obj spec.ingressDeny.fromCIDRSet"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressdenyfromcidrsetwithcidr class=md-nav__link> fn spec.ingressDeny.fromCIDRSet.withCidr </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyfromcidrsetwithexcept class=md-nav__link> fn spec.ingressDeny.fromCIDRSet.withExcept </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyfromcidrsetwithexceptmixin class=md-nav__link> fn spec.ingressDeny.fromCIDRSet.withExceptMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressdenyfromendpoints class=md-nav__link> obj spec.ingressDeny.fromEndpoints </a> <nav class=md-nav aria-label="obj spec.ingressDeny.fromEndpoints"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressdenyfromendpointswithmatchexpressions class=md-nav__link> fn spec.ingressDeny.fromEndpoints.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyfromendpointswithmatchexpressionsmixin class=md-nav__link> fn spec.ingressDeny.fromEndpoints.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyfromendpointswithmatchlabels class=md-nav__link> fn spec.ingressDeny.fromEndpoints.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyfromendpointswithmatchlabelsmixin class=md-nav__link> fn spec.ingressDeny.fromEndpoints.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressdenyfromendpointsmatchexpressions class=md-nav__link> obj spec.ingressDeny.fromEndpoints.matchExpressions </a> <nav class=md-nav aria-label="obj spec.ingressDeny.fromEndpoints.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressdenyfromendpointsmatchexpressionswithkey class=md-nav__link> fn spec.ingressDeny.fromEndpoints.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyfromendpointsmatchexpressionswithoperator class=md-nav__link> fn spec.ingressDeny.fromEndpoints.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyfromendpointsmatchexpressionswithvalues class=md-nav__link> fn spec.ingressDeny.fromEndpoints.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyfromendpointsmatchexpressionswithvaluesmixin class=md-nav__link> fn spec.ingressDeny.fromEndpoints.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressdenyfromrequires class=md-nav__link> obj spec.ingressDeny.fromRequires </a> <nav class=md-nav aria-label="obj spec.ingressDeny.fromRequires"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressdenyfromrequireswithmatchexpressions class=md-nav__link> fn spec.ingressDeny.fromRequires.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyfromrequireswithmatchexpressionsmixin class=md-nav__link> fn spec.ingressDeny.fromRequires.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyfromrequireswithmatchlabels class=md-nav__link> fn spec.ingressDeny.fromRequires.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyfromrequireswithmatchlabelsmixin class=md-nav__link> fn spec.ingressDeny.fromRequires.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressdenyfromrequiresmatchexpressions class=md-nav__link> obj spec.ingressDeny.fromRequires.matchExpressions </a> <nav class=md-nav aria-label="obj spec.ingressDeny.fromRequires.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressdenyfromrequiresmatchexpressionswithkey class=md-nav__link> fn spec.ingressDeny.fromRequires.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyfromrequiresmatchexpressionswithoperator class=md-nav__link> fn spec.ingressDeny.fromRequires.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyfromrequiresmatchexpressionswithvalues class=md-nav__link> fn spec.ingressDeny.fromRequires.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyfromrequiresmatchexpressionswithvaluesmixin class=md-nav__link> fn spec.ingressDeny.fromRequires.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressdenyicmps class=md-nav__link> obj spec.ingressDeny.icmps </a> <nav class=md-nav aria-label="obj spec.ingressDeny.icmps"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressdenyicmpswithfields class=md-nav__link> fn spec.ingressDeny.icmps.withFields </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyicmpswithfieldsmixin class=md-nav__link> fn spec.ingressDeny.icmps.withFieldsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressdenyicmpsfields class=md-nav__link> obj spec.ingressDeny.icmps.fields </a> <nav class=md-nav aria-label="obj spec.ingressDeny.icmps.fields"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressdenyicmpsfieldswithfamily class=md-nav__link> fn spec.ingressDeny.icmps.fields.withFamily </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyicmpsfieldswithtype class=md-nav__link> fn spec.ingressDeny.icmps.fields.withType </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressdenytoports class=md-nav__link> obj spec.ingressDeny.toPorts </a> <nav class=md-nav aria-label="obj spec.ingressDeny.toPorts"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressdenytoportswithports class=md-nav__link> fn spec.ingressDeny.toPorts.withPorts </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenytoportswithportsmixin class=md-nav__link> fn spec.ingressDeny.toPorts.withPortsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressdenytoportsports class=md-nav__link> obj spec.ingressDeny.toPorts.ports </a> <nav class=md-nav aria-label="obj spec.ingressDeny.toPorts.ports"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressdenytoportsportswithport class=md-nav__link> fn spec.ingressDeny.toPorts.ports.withPort </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenytoportsportswithprotocol class=md-nav__link> fn spec.ingressDeny.toPorts.ports.withProtocol </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-speclabels class=md-nav__link> obj spec.labels </a> <nav class=md-nav aria-label="obj spec.labels"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-speclabelswithkey class=md-nav__link> fn spec.labels.withKey </a> </li> <li class=md-nav__item> <a href=#fn-speclabelswithsource class=md-nav__link> fn spec.labels.withSource </a> </li> <li class=md-nav__item> <a href=#fn-speclabelswithvalue class=md-nav__link> fn spec.labels.withValue </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specnodeselector class=md-nav__link> obj spec.nodeSelector </a> <nav class=md-nav aria-label="obj spec.nodeSelector"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specnodeselectorwithmatchexpressions class=md-nav__link> fn spec.nodeSelector.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specnodeselectorwithmatchexpressionsmixin class=md-nav__link> fn spec.nodeSelector.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specnodeselectorwithmatchlabels class=md-nav__link> fn spec.nodeSelector.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specnodeselectorwithmatchlabelsmixin class=md-nav__link> fn spec.nodeSelector.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specnodeselectormatchexpressions class=md-nav__link> obj spec.nodeSelector.matchExpressions </a> <nav class=md-nav aria-label="obj spec.nodeSelector.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specnodeselectormatchexpressionswithkey class=md-nav__link> fn spec.nodeSelector.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specnodeselectormatchexpressionswithoperator class=md-nav__link> fn spec.nodeSelector.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specnodeselectormatchexpressionswithvalues class=md-nav__link> fn spec.nodeSelector.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specnodeselectormatchexpressionswithvaluesmixin class=md-nav__link> fn spec.nodeSelector.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specs class=md-nav__link> obj specs </a> <nav class=md-nav aria-label="obj specs"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specswithdescription class=md-nav__link> fn specs.withDescription </a> </li> <li class=md-nav__item> <a href=#fn-specswithegress class=md-nav__link> fn specs.withEgress </a> </li> <li class=md-nav__item> <a href=#fn-specswithegressdeny class=md-nav__link> fn specs.withEgressDeny </a> </li> <li class=md-nav__item> <a href=#fn-specswithegressdenymixin class=md-nav__link> fn specs.withEgressDenyMixin </a> </li> <li class=md-nav__item> <a href=#fn-specswithegressmixin class=md-nav__link> fn specs.withEgressMixin </a> </li> <li class=md-nav__item> <a href=#fn-specswithingress class=md-nav__link> fn specs.withIngress </a> </li> <li class=md-nav__item> <a href=#fn-specswithingressdeny class=md-nav__link> fn specs.withIngressDeny </a> </li> <li class=md-nav__item> <a href=#fn-specswithingressdenymixin class=md-nav__link> fn specs.withIngressDenyMixin </a> </li> <li class=md-nav__item> <a href=#fn-specswithingressmixin class=md-nav__link> fn specs.withIngressMixin </a> </li> <li class=md-nav__item> <a href=#fn-specswithlabels class=md-nav__link> fn specs.withLabels </a> </li> <li class=md-nav__item> <a href=#fn-specswithlabelsmixin class=md-nav__link> fn specs.withLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegress class=md-nav__link> obj specs.egress </a> <nav class=md-nav aria-label="obj specs.egress"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresswithicmps class=md-nav__link> fn specs.egress.withIcmps </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithicmpsmixin class=md-nav__link> fn specs.egress.withIcmpsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtocidr class=md-nav__link> fn specs.egress.withToCIDR </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtocidrmixin class=md-nav__link> fn specs.egress.withToCIDRMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtocidrset class=md-nav__link> fn specs.egress.withToCIDRSet </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtocidrsetmixin class=md-nav__link> fn specs.egress.withToCIDRSetMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtoendpoints class=md-nav__link> fn specs.egress.withToEndpoints </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtoendpointsmixin class=md-nav__link> fn specs.egress.withToEndpointsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtoentities class=md-nav__link> fn specs.egress.withToEntities </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtoentitiesmixin class=md-nav__link> fn specs.egress.withToEntitiesMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtofqdns class=md-nav__link> fn specs.egress.withToFQDNs </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtofqdnsmixin class=md-nav__link> fn specs.egress.withToFQDNsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtogroups class=md-nav__link> fn specs.egress.withToGroups </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtogroupsmixin class=md-nav__link> fn specs.egress.withToGroupsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtoports class=md-nav__link> fn specs.egress.withToPorts </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtoportsmixin class=md-nav__link> fn specs.egress.withToPortsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtorequires class=md-nav__link> fn specs.egress.withToRequires </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtorequiresmixin class=md-nav__link> fn specs.egress.withToRequiresMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtoservices class=md-nav__link> fn specs.egress.withToServices </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtoservicesmixin class=md-nav__link> fn specs.egress.withToServicesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressicmps class=md-nav__link> obj specs.egress.icmps </a> <nav class=md-nav aria-label="obj specs.egress.icmps"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressicmpswithfields class=md-nav__link> fn specs.egress.icmps.withFields </a> </li> <li class=md-nav__item> <a href=#fn-specsegressicmpswithfieldsmixin class=md-nav__link> fn specs.egress.icmps.withFieldsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressicmpsfields class=md-nav__link> obj specs.egress.icmps.fields </a> <nav class=md-nav aria-label="obj specs.egress.icmps.fields"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressicmpsfieldswithfamily class=md-nav__link> fn specs.egress.icmps.fields.withFamily </a> </li> <li class=md-nav__item> <a href=#fn-specsegressicmpsfieldswithtype class=md-nav__link> fn specs.egress.icmps.fields.withType </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstocidrset class=md-nav__link> obj specs.egress.toCIDRSet </a> <nav class=md-nav aria-label="obj specs.egress.toCIDRSet"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstocidrsetwithcidr class=md-nav__link> fn specs.egress.toCIDRSet.withCidr </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstocidrsetwithexcept class=md-nav__link> fn specs.egress.toCIDRSet.withExcept </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstocidrsetwithexceptmixin class=md-nav__link> fn specs.egress.toCIDRSet.withExceptMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoendpoints class=md-nav__link> obj specs.egress.toEndpoints </a> <nav class=md-nav aria-label="obj specs.egress.toEndpoints"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoendpointswithmatchexpressions class=md-nav__link> fn specs.egress.toEndpoints.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoendpointswithmatchexpressionsmixin class=md-nav__link> fn specs.egress.toEndpoints.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoendpointswithmatchlabels class=md-nav__link> fn specs.egress.toEndpoints.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoendpointswithmatchlabelsmixin class=md-nav__link> fn specs.egress.toEndpoints.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoendpointsmatchexpressions class=md-nav__link> obj specs.egress.toEndpoints.matchExpressions </a> <nav class=md-nav aria-label="obj specs.egress.toEndpoints.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoendpointsmatchexpressionswithkey class=md-nav__link> fn specs.egress.toEndpoints.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoendpointsmatchexpressionswithoperator class=md-nav__link> fn specs.egress.toEndpoints.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoendpointsmatchexpressionswithvalues class=md-nav__link> fn specs.egress.toEndpoints.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoendpointsmatchexpressionswithvaluesmixin class=md-nav__link> fn specs.egress.toEndpoints.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstofqdns class=md-nav__link> obj specs.egress.toFQDNs </a> <nav class=md-nav aria-label="obj specs.egress.toFQDNs"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstofqdnswithmatchname class=md-nav__link> fn specs.egress.toFQDNs.withMatchName </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstofqdnswithmatchpattern class=md-nav__link> fn specs.egress.toFQDNs.withMatchPattern </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstogroups class=md-nav__link> obj specs.egress.toGroups </a> </li> <li class=md-nav__item> <a href=#obj-specsegresstogroupsaws class=md-nav__link> obj specs.egress.toGroups.aws </a> <nav class=md-nav aria-label="obj specs.egress.toGroups.aws"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstogroupsawswithlabels class=md-nav__link> fn specs.egress.toGroups.aws.withLabels </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstogroupsawswithlabelsmixin class=md-nav__link> fn specs.egress.toGroups.aws.withLabelsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstogroupsawswithregion class=md-nav__link> fn specs.egress.toGroups.aws.withRegion </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstogroupsawswithsecuritygroupsids class=md-nav__link> fn specs.egress.toGroups.aws.withSecurityGroupsIds </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstogroupsawswithsecuritygroupsidsmixin class=md-nav__link> fn specs.egress.toGroups.aws.withSecurityGroupsIdsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstogroupsawswithsecuritygroupsnames class=md-nav__link> fn specs.egress.toGroups.aws.withSecurityGroupsNames </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstogroupsawswithsecuritygroupsnamesmixin class=md-nav__link> fn specs.egress.toGroups.aws.withSecurityGroupsNamesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoports class=md-nav__link> obj specs.egress.toPorts </a> <nav class=md-nav aria-label="obj specs.egress.toPorts"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoportswithports class=md-nav__link> fn specs.egress.toPorts.withPorts </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportswithportsmixin class=md-nav__link> fn specs.egress.toPorts.withPortsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoportsoriginatingtls class=md-nav__link> obj specs.egress.toPorts.originatingTLS </a> <nav class=md-nav aria-label="obj specs.egress.toPorts.originatingTLS"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoportsoriginatingtlswithcertificate class=md-nav__link> fn specs.egress.toPorts.originatingTLS.withCertificate </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsoriginatingtlswithprivatekey class=md-nav__link> fn specs.egress.toPorts.originatingTLS.withPrivateKey </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsoriginatingtlswithtrustedca class=md-nav__link> fn specs.egress.toPorts.originatingTLS.withTrustedCA </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoportsoriginatingtlssecret class=md-nav__link> obj specs.egress.toPorts.originatingTLS.secret </a> <nav class=md-nav aria-label="obj specs.egress.toPorts.originatingTLS.secret"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoportsoriginatingtlssecretwithname class=md-nav__link> fn specs.egress.toPorts.originatingTLS.secret.withName </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsoriginatingtlssecretwithnamespace class=md-nav__link> fn specs.egress.toPorts.originatingTLS.secret.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoportsports class=md-nav__link> obj specs.egress.toPorts.ports </a> <nav class=md-nav aria-label="obj specs.egress.toPorts.ports"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoportsportswithport class=md-nav__link> fn specs.egress.toPorts.ports.withPort </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsportswithprotocol class=md-nav__link> fn specs.egress.toPorts.ports.withProtocol </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoportsrules class=md-nav__link> obj specs.egress.toPorts.rules </a> <nav class=md-nav aria-label="obj specs.egress.toPorts.rules"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleswithdns class=md-nav__link> fn specs.egress.toPorts.rules.withDns </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleswithdnsmixin class=md-nav__link> fn specs.egress.toPorts.rules.withDnsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleswithhttp class=md-nav__link> fn specs.egress.toPorts.rules.withHttp </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleswithhttpmixin class=md-nav__link> fn specs.egress.toPorts.rules.withHttpMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleswithkafka class=md-nav__link> fn specs.egress.toPorts.rules.withKafka </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleswithkafkamixin class=md-nav__link> fn specs.egress.toPorts.rules.withKafkaMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleswithl7 class=md-nav__link> fn specs.egress.toPorts.rules.withL7 </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleswithl7mixin class=md-nav__link> fn specs.egress.toPorts.rules.withL7Mixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleswithl7proto class=md-nav__link> fn specs.egress.toPorts.rules.withL7proto </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoportsrulesdns class=md-nav__link> obj specs.egress.toPorts.rules.dns </a> <nav class=md-nav aria-label="obj specs.egress.toPorts.rules.dns"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoportsrulesdnswithmatchname class=md-nav__link> fn specs.egress.toPorts.rules.dns.withMatchName </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsrulesdnswithmatchpattern class=md-nav__link> fn specs.egress.toPorts.rules.dns.withMatchPattern </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoportsruleshttp class=md-nav__link> obj specs.egress.toPorts.rules.http </a> <nav class=md-nav aria-label="obj specs.egress.toPorts.rules.http"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleshttpwithheadermatches class=md-nav__link> fn specs.egress.toPorts.rules.http.withHeaderMatches </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleshttpwithheadermatchesmixin class=md-nav__link> fn specs.egress.toPorts.rules.http.withHeaderMatchesMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleshttpwithheaders class=md-nav__link> fn specs.egress.toPorts.rules.http.withHeaders </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleshttpwithheadersmixin class=md-nav__link> fn specs.egress.toPorts.rules.http.withHeadersMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleshttpwithhost class=md-nav__link> fn specs.egress.toPorts.rules.http.withHost </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleshttpwithmethod class=md-nav__link> fn specs.egress.toPorts.rules.http.withMethod </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleshttpwithpath class=md-nav__link> fn specs.egress.toPorts.rules.http.withPath </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoportsruleshttpheadermatches class=md-nav__link> obj specs.egress.toPorts.rules.http.headerMatches </a> <nav class=md-nav aria-label="obj specs.egress.toPorts.rules.http.headerMatches"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleshttpheadermatcheswithmismatch class=md-nav__link> fn specs.egress.toPorts.rules.http.headerMatches.withMismatch </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleshttpheadermatcheswithname class=md-nav__link> fn specs.egress.toPorts.rules.http.headerMatches.withName </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleshttpheadermatcheswithvalue class=md-nav__link> fn specs.egress.toPorts.rules.http.headerMatches.withValue </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoportsruleshttpheadermatchessecret class=md-nav__link> obj specs.egress.toPorts.rules.http.headerMatches.secret </a> <nav class=md-nav aria-label="obj specs.egress.toPorts.rules.http.headerMatches.secret"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleshttpheadermatchessecretwithname class=md-nav__link> fn specs.egress.toPorts.rules.http.headerMatches.secret.withName </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleshttpheadermatchessecretwithnamespace class=md-nav__link> fn specs.egress.toPorts.rules.http.headerMatches.secret.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoportsruleskafka class=md-nav__link> obj specs.egress.toPorts.rules.kafka </a> <nav class=md-nav aria-label="obj specs.egress.toPorts.rules.kafka"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleskafkawithapikey class=md-nav__link> fn specs.egress.toPorts.rules.kafka.withApiKey </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleskafkawithapiversion class=md-nav__link> fn specs.egress.toPorts.rules.kafka.withApiVersion </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleskafkawithclientid class=md-nav__link> fn specs.egress.toPorts.rules.kafka.withClientID </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleskafkawithrole class=md-nav__link> fn specs.egress.toPorts.rules.kafka.withRole </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleskafkawithtopic class=md-nav__link> fn specs.egress.toPorts.rules.kafka.withTopic </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoportsterminatingtls class=md-nav__link> obj specs.egress.toPorts.terminatingTLS </a> <nav class=md-nav aria-label="obj specs.egress.toPorts.terminatingTLS"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoportsterminatingtlswithcertificate class=md-nav__link> fn specs.egress.toPorts.terminatingTLS.withCertificate </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsterminatingtlswithprivatekey class=md-nav__link> fn specs.egress.toPorts.terminatingTLS.withPrivateKey </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsterminatingtlswithtrustedca class=md-nav__link> fn specs.egress.toPorts.terminatingTLS.withTrustedCA </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoportsterminatingtlssecret class=md-nav__link> obj specs.egress.toPorts.terminatingTLS.secret </a> <nav class=md-nav aria-label="obj specs.egress.toPorts.terminatingTLS.secret"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoportsterminatingtlssecretwithname class=md-nav__link> fn specs.egress.toPorts.terminatingTLS.secret.withName </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsterminatingtlssecretwithnamespace class=md-nav__link> fn specs.egress.toPorts.terminatingTLS.secret.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstorequires class=md-nav__link> obj specs.egress.toRequires </a> <nav class=md-nav aria-label="obj specs.egress.toRequires"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstorequireswithmatchexpressions class=md-nav__link> fn specs.egress.toRequires.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstorequireswithmatchexpressionsmixin class=md-nav__link> fn specs.egress.toRequires.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstorequireswithmatchlabels class=md-nav__link> fn specs.egress.toRequires.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstorequireswithmatchlabelsmixin class=md-nav__link> fn specs.egress.toRequires.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstorequiresmatchexpressions class=md-nav__link> obj specs.egress.toRequires.matchExpressions </a> <nav class=md-nav aria-label="obj specs.egress.toRequires.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstorequiresmatchexpressionswithkey class=md-nav__link> fn specs.egress.toRequires.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstorequiresmatchexpressionswithoperator class=md-nav__link> fn specs.egress.toRequires.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstorequiresmatchexpressionswithvalues class=md-nav__link> fn specs.egress.toRequires.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstorequiresmatchexpressionswithvaluesmixin class=md-nav__link> fn specs.egress.toRequires.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoservices class=md-nav__link> obj specs.egress.toServices </a> </li> <li class=md-nav__item> <a href=#obj-specsegresstoservicesk8sservice class=md-nav__link> obj specs.egress.toServices.k8sService </a> <nav class=md-nav aria-label="obj specs.egress.toServices.k8sService"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoservicesk8sservicewithnamespace class=md-nav__link> fn specs.egress.toServices.k8sService.withNamespace </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoservicesk8sservicewithservicename class=md-nav__link> fn specs.egress.toServices.k8sService.withServiceName </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoservicesk8sserviceselector class=md-nav__link> obj specs.egress.toServices.k8sServiceSelector </a> <nav class=md-nav aria-label="obj specs.egress.toServices.k8sServiceSelector"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoservicesk8sserviceselectorwithnamespace class=md-nav__link> fn specs.egress.toServices.k8sServiceSelector.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoservicesk8sserviceselectorselector class=md-nav__link> obj specs.egress.toServices.k8sServiceSelector.selector </a> <nav class=md-nav aria-label="obj specs.egress.toServices.k8sServiceSelector.selector"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoservicesk8sserviceselectorselectorwithmatchexpressions class=md-nav__link> fn specs.egress.toServices.k8sServiceSelector.selector.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoservicesk8sserviceselectorselectorwithmatchexpressionsmixin class=md-nav__link> fn specs.egress.toServices.k8sServiceSelector.selector.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoservicesk8sserviceselectorselectorwithmatchlabels class=md-nav__link> fn specs.egress.toServices.k8sServiceSelector.selector.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoservicesk8sserviceselectorselectorwithmatchlabelsmixin class=md-nav__link> fn specs.egress.toServices.k8sServiceSelector.selector.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoservicesk8sserviceselectorselectormatchexpressions class=md-nav__link> obj specs.egress.toServices.k8sServiceSelector.selector.matchExpressions </a> <nav class=md-nav aria-label="obj specs.egress.toServices.k8sServiceSelector.selector.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoservicesk8sserviceselectorselectormatchexpressionswithkey class=md-nav__link> fn specs.egress.toServices.k8sServiceSelector.selector.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoservicesk8sserviceselectorselectormatchexpressionswithoperator class=md-nav__link> fn specs.egress.toServices.k8sServiceSelector.selector.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoservicesk8sserviceselectorselectormatchexpressionswithvalues class=md-nav__link> fn specs.egress.toServices.k8sServiceSelector.selector.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoservicesk8sserviceselectorselectormatchexpressionswithvaluesmixin class=md-nav__link> fn specs.egress.toServices.k8sServiceSelector.selector.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdeny class=md-nav__link> obj specs.egressDeny </a> <nav class=md-nav aria-label="obj specs.egressDeny"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenywithicmps class=md-nav__link> fn specs.egressDeny.withIcmps </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithicmpsmixin class=md-nav__link> fn specs.egressDeny.withIcmpsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtocidr class=md-nav__link> fn specs.egressDeny.withToCIDR </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtocidrmixin class=md-nav__link> fn specs.egressDeny.withToCIDRMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtocidrset class=md-nav__link> fn specs.egressDeny.withToCIDRSet </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtocidrsetmixin class=md-nav__link> fn specs.egressDeny.withToCIDRSetMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtoendpoints class=md-nav__link> fn specs.egressDeny.withToEndpoints </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtoendpointsmixin class=md-nav__link> fn specs.egressDeny.withToEndpointsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtoentities class=md-nav__link> fn specs.egressDeny.withToEntities </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtoentitiesmixin class=md-nav__link> fn specs.egressDeny.withToEntitiesMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtogroups class=md-nav__link> fn specs.egressDeny.withToGroups </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtogroupsmixin class=md-nav__link> fn specs.egressDeny.withToGroupsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtoports class=md-nav__link> fn specs.egressDeny.withToPorts </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtoportsmixin class=md-nav__link> fn specs.egressDeny.withToPortsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtorequires class=md-nav__link> fn specs.egressDeny.withToRequires </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtorequiresmixin class=md-nav__link> fn specs.egressDeny.withToRequiresMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtoservices class=md-nav__link> fn specs.egressDeny.withToServices </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtoservicesmixin class=md-nav__link> fn specs.egressDeny.withToServicesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdenyicmps class=md-nav__link> obj specs.egressDeny.icmps </a> <nav class=md-nav aria-label="obj specs.egressDeny.icmps"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenyicmpswithfields class=md-nav__link> fn specs.egressDeny.icmps.withFields </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenyicmpswithfieldsmixin class=md-nav__link> fn specs.egressDeny.icmps.withFieldsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdenyicmpsfields class=md-nav__link> obj specs.egressDeny.icmps.fields </a> <nav class=md-nav aria-label="obj specs.egressDeny.icmps.fields"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenyicmpsfieldswithfamily class=md-nav__link> fn specs.egressDeny.icmps.fields.withFamily </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenyicmpsfieldswithtype class=md-nav__link> fn specs.egressDeny.icmps.fields.withType </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdenytocidrset class=md-nav__link> obj specs.egressDeny.toCIDRSet </a> <nav class=md-nav aria-label="obj specs.egressDeny.toCIDRSet"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenytocidrsetwithcidr class=md-nav__link> fn specs.egressDeny.toCIDRSet.withCidr </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytocidrsetwithexcept class=md-nav__link> fn specs.egressDeny.toCIDRSet.withExcept </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytocidrsetwithexceptmixin class=md-nav__link> fn specs.egressDeny.toCIDRSet.withExceptMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdenytoendpoints class=md-nav__link> obj specs.egressDeny.toEndpoints </a> <nav class=md-nav aria-label="obj specs.egressDeny.toEndpoints"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenytoendpointswithmatchexpressions class=md-nav__link> fn specs.egressDeny.toEndpoints.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoendpointswithmatchexpressionsmixin class=md-nav__link> fn specs.egressDeny.toEndpoints.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoendpointswithmatchlabels class=md-nav__link> fn specs.egressDeny.toEndpoints.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoendpointswithmatchlabelsmixin class=md-nav__link> fn specs.egressDeny.toEndpoints.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdenytoendpointsmatchexpressions class=md-nav__link> obj specs.egressDeny.toEndpoints.matchExpressions </a> <nav class=md-nav aria-label="obj specs.egressDeny.toEndpoints.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenytoendpointsmatchexpressionswithkey class=md-nav__link> fn specs.egressDeny.toEndpoints.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoendpointsmatchexpressionswithoperator class=md-nav__link> fn specs.egressDeny.toEndpoints.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoendpointsmatchexpressionswithvalues class=md-nav__link> fn specs.egressDeny.toEndpoints.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoendpointsmatchexpressionswithvaluesmixin class=md-nav__link> fn specs.egressDeny.toEndpoints.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdenytogroups class=md-nav__link> obj specs.egressDeny.toGroups </a> </li> <li class=md-nav__item> <a href=#obj-specsegressdenytogroupsaws class=md-nav__link> obj specs.egressDeny.toGroups.aws </a> <nav class=md-nav aria-label="obj specs.egressDeny.toGroups.aws"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenytogroupsawswithlabels class=md-nav__link> fn specs.egressDeny.toGroups.aws.withLabels </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytogroupsawswithlabelsmixin class=md-nav__link> fn specs.egressDeny.toGroups.aws.withLabelsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytogroupsawswithregion class=md-nav__link> fn specs.egressDeny.toGroups.aws.withRegion </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytogroupsawswithsecuritygroupsids class=md-nav__link> fn specs.egressDeny.toGroups.aws.withSecurityGroupsIds </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytogroupsawswithsecuritygroupsidsmixin class=md-nav__link> fn specs.egressDeny.toGroups.aws.withSecurityGroupsIdsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytogroupsawswithsecuritygroupsnames class=md-nav__link> fn specs.egressDeny.toGroups.aws.withSecurityGroupsNames </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytogroupsawswithsecuritygroupsnamesmixin class=md-nav__link> fn specs.egressDeny.toGroups.aws.withSecurityGroupsNamesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdenytoports class=md-nav__link> obj specs.egressDeny.toPorts </a> <nav class=md-nav aria-label="obj specs.egressDeny.toPorts"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenytoportswithports class=md-nav__link> fn specs.egressDeny.toPorts.withPorts </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoportswithportsmixin class=md-nav__link> fn specs.egressDeny.toPorts.withPortsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdenytoportsports class=md-nav__link> obj specs.egressDeny.toPorts.ports </a> <nav class=md-nav aria-label="obj specs.egressDeny.toPorts.ports"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenytoportsportswithport class=md-nav__link> fn specs.egressDeny.toPorts.ports.withPort </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoportsportswithprotocol class=md-nav__link> fn specs.egressDeny.toPorts.ports.withProtocol </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdenytorequires class=md-nav__link> obj specs.egressDeny.toRequires </a> <nav class=md-nav aria-label="obj specs.egressDeny.toRequires"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenytorequireswithmatchexpressions class=md-nav__link> fn specs.egressDeny.toRequires.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytorequireswithmatchexpressionsmixin class=md-nav__link> fn specs.egressDeny.toRequires.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytorequireswithmatchlabels class=md-nav__link> fn specs.egressDeny.toRequires.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytorequireswithmatchlabelsmixin class=md-nav__link> fn specs.egressDeny.toRequires.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdenytorequiresmatchexpressions class=md-nav__link> obj specs.egressDeny.toRequires.matchExpressions </a> <nav class=md-nav aria-label="obj specs.egressDeny.toRequires.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenytorequiresmatchexpressionswithkey class=md-nav__link> fn specs.egressDeny.toRequires.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytorequiresmatchexpressionswithoperator class=md-nav__link> fn specs.egressDeny.toRequires.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytorequiresmatchexpressionswithvalues class=md-nav__link> fn specs.egressDeny.toRequires.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytorequiresmatchexpressionswithvaluesmixin class=md-nav__link> fn specs.egressDeny.toRequires.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdenytoservices class=md-nav__link> obj specs.egressDeny.toServices </a> </li> <li class=md-nav__item> <a href=#obj-specsegressdenytoservicesk8sservice class=md-nav__link> obj specs.egressDeny.toServices.k8sService </a> <nav class=md-nav aria-label="obj specs.egressDeny.toServices.k8sService"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenytoservicesk8sservicewithnamespace class=md-nav__link> fn specs.egressDeny.toServices.k8sService.withNamespace </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoservicesk8sservicewithservicename class=md-nav__link> fn specs.egressDeny.toServices.k8sService.withServiceName </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdenytoservicesk8sserviceselector class=md-nav__link> obj specs.egressDeny.toServices.k8sServiceSelector </a> <nav class=md-nav aria-label="obj specs.egressDeny.toServices.k8sServiceSelector"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenytoservicesk8sserviceselectorwithnamespace class=md-nav__link> fn specs.egressDeny.toServices.k8sServiceSelector.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdenytoservicesk8sserviceselectorselector class=md-nav__link> obj specs.egressDeny.toServices.k8sServiceSelector.selector </a> <nav class=md-nav aria-label="obj specs.egressDeny.toServices.k8sServiceSelector.selector"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenytoservicesk8sserviceselectorselectorwithmatchexpressions class=md-nav__link> fn specs.egressDeny.toServices.k8sServiceSelector.selector.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoservicesk8sserviceselectorselectorwithmatchexpressionsmixin class=md-nav__link> fn specs.egressDeny.toServices.k8sServiceSelector.selector.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoservicesk8sserviceselectorselectorwithmatchlabels class=md-nav__link> fn specs.egressDeny.toServices.k8sServiceSelector.selector.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoservicesk8sserviceselectorselectorwithmatchlabelsmixin class=md-nav__link> fn specs.egressDeny.toServices.k8sServiceSelector.selector.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdenytoservicesk8sserviceselectorselectormatchexpressions class=md-nav__link> obj specs.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions </a> <nav class=md-nav aria-label="obj specs.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenytoservicesk8sserviceselectorselectormatchexpressionswithkey class=md-nav__link> fn specs.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoservicesk8sserviceselectorselectormatchexpressionswithoperator class=md-nav__link> fn specs.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoservicesk8sserviceselectorselectormatchexpressionswithvalues class=md-nav__link> fn specs.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoservicesk8sserviceselectorselectormatchexpressionswithvaluesmixin class=md-nav__link> fn specs.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsendpointselector class=md-nav__link> obj specs.endpointSelector </a> <nav class=md-nav aria-label="obj specs.endpointSelector"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsendpointselectorwithmatchexpressions class=md-nav__link> fn specs.endpointSelector.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specsendpointselectorwithmatchexpressionsmixin class=md-nav__link> fn specs.endpointSelector.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsendpointselectorwithmatchlabels class=md-nav__link> fn specs.endpointSelector.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specsendpointselectorwithmatchlabelsmixin class=md-nav__link> fn specs.endpointSelector.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsendpointselectormatchexpressions class=md-nav__link> obj specs.endpointSelector.matchExpressions </a> <nav class=md-nav aria-label="obj specs.endpointSelector.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsendpointselectormatchexpressionswithkey class=md-nav__link> fn specs.endpointSelector.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specsendpointselectormatchexpressionswithoperator class=md-nav__link> fn specs.endpointSelector.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specsendpointselectormatchexpressionswithvalues class=md-nav__link> fn specs.endpointSelector.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specsendpointselectormatchexpressionswithvaluesmixin class=md-nav__link> fn specs.endpointSelector.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingress class=md-nav__link> obj specs.ingress </a> <nav class=md-nav aria-label="obj specs.ingress"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingresswithfromcidr class=md-nav__link> fn specs.ingress.withFromCIDR </a> </li> <li class=md-nav__item> <a href=#fn-specsingresswithfromcidrmixin class=md-nav__link> fn specs.ingress.withFromCIDRMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingresswithfromcidrset class=md-nav__link> fn specs.ingress.withFromCIDRSet </a> </li> <li class=md-nav__item> <a href=#fn-specsingresswithfromcidrsetmixin class=md-nav__link> fn specs.ingress.withFromCIDRSetMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingresswithfromendpoints class=md-nav__link> fn specs.ingress.withFromEndpoints </a> </li> <li class=md-nav__item> <a href=#fn-specsingresswithfromendpointsmixin class=md-nav__link> fn specs.ingress.withFromEndpointsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingresswithfromentities class=md-nav__link> fn specs.ingress.withFromEntities </a> </li> <li class=md-nav__item> <a href=#fn-specsingresswithfromentitiesmixin class=md-nav__link> fn specs.ingress.withFromEntitiesMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingresswithfromrequires class=md-nav__link> fn specs.ingress.withFromRequires </a> </li> <li class=md-nav__item> <a href=#fn-specsingresswithfromrequiresmixin class=md-nav__link> fn specs.ingress.withFromRequiresMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingresswithicmps class=md-nav__link> fn specs.ingress.withIcmps </a> </li> <li class=md-nav__item> <a href=#fn-specsingresswithicmpsmixin class=md-nav__link> fn specs.ingress.withIcmpsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingresswithtoports class=md-nav__link> fn specs.ingress.withToPorts </a> </li> <li class=md-nav__item> <a href=#fn-specsingresswithtoportsmixin class=md-nav__link> fn specs.ingress.withToPortsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressfromcidrset class=md-nav__link> obj specs.ingress.fromCIDRSet </a> <nav class=md-nav aria-label="obj specs.ingress.fromCIDRSet"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressfromcidrsetwithcidr class=md-nav__link> fn specs.ingress.fromCIDRSet.withCidr </a> </li> <li class=md-nav__item> <a href=#fn-specsingressfromcidrsetwithexcept class=md-nav__link> fn specs.ingress.fromCIDRSet.withExcept </a> </li> <li class=md-nav__item> <a href=#fn-specsingressfromcidrsetwithexceptmixin class=md-nav__link> fn specs.ingress.fromCIDRSet.withExceptMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressfromendpoints class=md-nav__link> obj specs.ingress.fromEndpoints </a> <nav class=md-nav aria-label="obj specs.ingress.fromEndpoints"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressfromendpointswithmatchexpressions class=md-nav__link> fn specs.ingress.fromEndpoints.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specsingressfromendpointswithmatchexpressionsmixin class=md-nav__link> fn specs.ingress.fromEndpoints.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingressfromendpointswithmatchlabels class=md-nav__link> fn specs.ingress.fromEndpoints.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specsingressfromendpointswithmatchlabelsmixin class=md-nav__link> fn specs.ingress.fromEndpoints.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressfromendpointsmatchexpressions class=md-nav__link> obj specs.ingress.fromEndpoints.matchExpressions </a> <nav class=md-nav aria-label="obj specs.ingress.fromEndpoints.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressfromendpointsmatchexpressionswithkey class=md-nav__link> fn specs.ingress.fromEndpoints.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specsingressfromendpointsmatchexpressionswithoperator class=md-nav__link> fn specs.ingress.fromEndpoints.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specsingressfromendpointsmatchexpressionswithvalues class=md-nav__link> fn specs.ingress.fromEndpoints.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specsingressfromendpointsmatchexpressionswithvaluesmixin class=md-nav__link> fn specs.ingress.fromEndpoints.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressfromrequires class=md-nav__link> obj specs.ingress.fromRequires </a> <nav class=md-nav aria-label="obj specs.ingress.fromRequires"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressfromrequireswithmatchexpressions class=md-nav__link> fn specs.ingress.fromRequires.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specsingressfromrequireswithmatchexpressionsmixin class=md-nav__link> fn specs.ingress.fromRequires.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingressfromrequireswithmatchlabels class=md-nav__link> fn specs.ingress.fromRequires.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specsingressfromrequireswithmatchlabelsmixin class=md-nav__link> fn specs.ingress.fromRequires.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressfromrequiresmatchexpressions class=md-nav__link> obj specs.ingress.fromRequires.matchExpressions </a> <nav class=md-nav aria-label="obj specs.ingress.fromRequires.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressfromrequiresmatchexpressionswithkey class=md-nav__link> fn specs.ingress.fromRequires.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specsingressfromrequiresmatchexpressionswithoperator class=md-nav__link> fn specs.ingress.fromRequires.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specsingressfromrequiresmatchexpressionswithvalues class=md-nav__link> fn specs.ingress.fromRequires.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specsingressfromrequiresmatchexpressionswithvaluesmixin class=md-nav__link> fn specs.ingress.fromRequires.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressicmps class=md-nav__link> obj specs.ingress.icmps </a> <nav class=md-nav aria-label="obj specs.ingress.icmps"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressicmpswithfields class=md-nav__link> fn specs.ingress.icmps.withFields </a> </li> <li class=md-nav__item> <a href=#fn-specsingressicmpswithfieldsmixin class=md-nav__link> fn specs.ingress.icmps.withFieldsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressicmpsfields class=md-nav__link> obj specs.ingress.icmps.fields </a> <nav class=md-nav aria-label="obj specs.ingress.icmps.fields"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressicmpsfieldswithfamily class=md-nav__link> fn specs.ingress.icmps.fields.withFamily </a> </li> <li class=md-nav__item> <a href=#fn-specsingressicmpsfieldswithtype class=md-nav__link> fn specs.ingress.icmps.fields.withType </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingresstoports class=md-nav__link> obj specs.ingress.toPorts </a> <nav class=md-nav aria-label="obj specs.ingress.toPorts"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingresstoportswithports class=md-nav__link> fn specs.ingress.toPorts.withPorts </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportswithportsmixin class=md-nav__link> fn specs.ingress.toPorts.withPortsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingresstoportsoriginatingtls class=md-nav__link> obj specs.ingress.toPorts.originatingTLS </a> <nav class=md-nav aria-label="obj specs.ingress.toPorts.originatingTLS"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingresstoportsoriginatingtlswithcertificate class=md-nav__link> fn specs.ingress.toPorts.originatingTLS.withCertificate </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsoriginatingtlswithprivatekey class=md-nav__link> fn specs.ingress.toPorts.originatingTLS.withPrivateKey </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsoriginatingtlswithtrustedca class=md-nav__link> fn specs.ingress.toPorts.originatingTLS.withTrustedCA </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingresstoportsoriginatingtlssecret class=md-nav__link> obj specs.ingress.toPorts.originatingTLS.secret </a> <nav class=md-nav aria-label="obj specs.ingress.toPorts.originatingTLS.secret"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingresstoportsoriginatingtlssecretwithname class=md-nav__link> fn specs.ingress.toPorts.originatingTLS.secret.withName </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsoriginatingtlssecretwithnamespace class=md-nav__link> fn specs.ingress.toPorts.originatingTLS.secret.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingresstoportsports class=md-nav__link> obj specs.ingress.toPorts.ports </a> <nav class=md-nav aria-label="obj specs.ingress.toPorts.ports"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingresstoportsportswithport class=md-nav__link> fn specs.ingress.toPorts.ports.withPort </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsportswithprotocol class=md-nav__link> fn specs.ingress.toPorts.ports.withProtocol </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingresstoportsrules class=md-nav__link> obj specs.ingress.toPorts.rules </a> <nav class=md-nav aria-label="obj specs.ingress.toPorts.rules"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleswithdns class=md-nav__link> fn specs.ingress.toPorts.rules.withDns </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleswithdnsmixin class=md-nav__link> fn specs.ingress.toPorts.rules.withDnsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleswithhttp class=md-nav__link> fn specs.ingress.toPorts.rules.withHttp </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleswithhttpmixin class=md-nav__link> fn specs.ingress.toPorts.rules.withHttpMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleswithkafka class=md-nav__link> fn specs.ingress.toPorts.rules.withKafka </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleswithkafkamixin class=md-nav__link> fn specs.ingress.toPorts.rules.withKafkaMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleswithl7 class=md-nav__link> fn specs.ingress.toPorts.rules.withL7 </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleswithl7mixin class=md-nav__link> fn specs.ingress.toPorts.rules.withL7Mixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleswithl7proto class=md-nav__link> fn specs.ingress.toPorts.rules.withL7proto </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingresstoportsrulesdns class=md-nav__link> obj specs.ingress.toPorts.rules.dns </a> <nav class=md-nav aria-label="obj specs.ingress.toPorts.rules.dns"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingresstoportsrulesdnswithmatchname class=md-nav__link> fn specs.ingress.toPorts.rules.dns.withMatchName </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsrulesdnswithmatchpattern class=md-nav__link> fn specs.ingress.toPorts.rules.dns.withMatchPattern </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingresstoportsruleshttp class=md-nav__link> obj specs.ingress.toPorts.rules.http </a> <nav class=md-nav aria-label="obj specs.ingress.toPorts.rules.http"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleshttpwithheadermatches class=md-nav__link> fn specs.ingress.toPorts.rules.http.withHeaderMatches </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleshttpwithheadermatchesmixin class=md-nav__link> fn specs.ingress.toPorts.rules.http.withHeaderMatchesMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleshttpwithheaders class=md-nav__link> fn specs.ingress.toPorts.rules.http.withHeaders </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleshttpwithheadersmixin class=md-nav__link> fn specs.ingress.toPorts.rules.http.withHeadersMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleshttpwithhost class=md-nav__link> fn specs.ingress.toPorts.rules.http.withHost </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleshttpwithmethod class=md-nav__link> fn specs.ingress.toPorts.rules.http.withMethod </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleshttpwithpath class=md-nav__link> fn specs.ingress.toPorts.rules.http.withPath </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingresstoportsruleshttpheadermatches class=md-nav__link> obj specs.ingress.toPorts.rules.http.headerMatches </a> <nav class=md-nav aria-label="obj specs.ingress.toPorts.rules.http.headerMatches"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleshttpheadermatcheswithmismatch class=md-nav__link> fn specs.ingress.toPorts.rules.http.headerMatches.withMismatch </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleshttpheadermatcheswithname class=md-nav__link> fn specs.ingress.toPorts.rules.http.headerMatches.withName </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleshttpheadermatcheswithvalue class=md-nav__link> fn specs.ingress.toPorts.rules.http.headerMatches.withValue </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingresstoportsruleshttpheadermatchessecret class=md-nav__link> obj specs.ingress.toPorts.rules.http.headerMatches.secret </a> <nav class=md-nav aria-label="obj specs.ingress.toPorts.rules.http.headerMatches.secret"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleshttpheadermatchessecretwithname class=md-nav__link> fn specs.ingress.toPorts.rules.http.headerMatches.secret.withName </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleshttpheadermatchessecretwithnamespace class=md-nav__link> fn specs.ingress.toPorts.rules.http.headerMatches.secret.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingresstoportsruleskafka class=md-nav__link> obj specs.ingress.toPorts.rules.kafka </a> <nav class=md-nav aria-label="obj specs.ingress.toPorts.rules.kafka"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleskafkawithapikey class=md-nav__link> fn specs.ingress.toPorts.rules.kafka.withApiKey </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleskafkawithapiversion class=md-nav__link> fn specs.ingress.toPorts.rules.kafka.withApiVersion </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleskafkawithclientid class=md-nav__link> fn specs.ingress.toPorts.rules.kafka.withClientID </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleskafkawithrole class=md-nav__link> fn specs.ingress.toPorts.rules.kafka.withRole </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleskafkawithtopic class=md-nav__link> fn specs.ingress.toPorts.rules.kafka.withTopic </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingresstoportsterminatingtls class=md-nav__link> obj specs.ingress.toPorts.terminatingTLS </a> <nav class=md-nav aria-label="obj specs.ingress.toPorts.terminatingTLS"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingresstoportsterminatingtlswithcertificate class=md-nav__link> fn specs.ingress.toPorts.terminatingTLS.withCertificate </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsterminatingtlswithprivatekey class=md-nav__link> fn specs.ingress.toPorts.terminatingTLS.withPrivateKey </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsterminatingtlswithtrustedca class=md-nav__link> fn specs.ingress.toPorts.terminatingTLS.withTrustedCA </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingresstoportsterminatingtlssecret class=md-nav__link> obj specs.ingress.toPorts.terminatingTLS.secret </a> <nav class=md-nav aria-label="obj specs.ingress.toPorts.terminatingTLS.secret"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingresstoportsterminatingtlssecretwithname class=md-nav__link> fn specs.ingress.toPorts.terminatingTLS.secret.withName </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsterminatingtlssecretwithnamespace class=md-nav__link> fn specs.ingress.toPorts.terminatingTLS.secret.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressdeny class=md-nav__link> obj specs.ingressDeny </a> <nav class=md-nav aria-label="obj specs.ingressDeny"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressdenywithfromcidr class=md-nav__link> fn specs.ingressDeny.withFromCIDR </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenywithfromcidrmixin class=md-nav__link> fn specs.ingressDeny.withFromCIDRMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenywithfromcidrset class=md-nav__link> fn specs.ingressDeny.withFromCIDRSet </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenywithfromcidrsetmixin class=md-nav__link> fn specs.ingressDeny.withFromCIDRSetMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenywithfromendpoints class=md-nav__link> fn specs.ingressDeny.withFromEndpoints </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenywithfromendpointsmixin class=md-nav__link> fn specs.ingressDeny.withFromEndpointsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenywithfromentities class=md-nav__link> fn specs.ingressDeny.withFromEntities </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenywithfromentitiesmixin class=md-nav__link> fn specs.ingressDeny.withFromEntitiesMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenywithfromrequires class=md-nav__link> fn specs.ingressDeny.withFromRequires </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenywithfromrequiresmixin class=md-nav__link> fn specs.ingressDeny.withFromRequiresMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenywithicmps class=md-nav__link> fn specs.ingressDeny.withIcmps </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenywithicmpsmixin class=md-nav__link> fn specs.ingressDeny.withIcmpsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenywithtoports class=md-nav__link> fn specs.ingressDeny.withToPorts </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenywithtoportsmixin class=md-nav__link> fn specs.ingressDeny.withToPortsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressdenyfromcidrset class=md-nav__link> obj specs.ingressDeny.fromCIDRSet </a> <nav class=md-nav aria-label="obj specs.ingressDeny.fromCIDRSet"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressdenyfromcidrsetwithcidr class=md-nav__link> fn specs.ingressDeny.fromCIDRSet.withCidr </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyfromcidrsetwithexcept class=md-nav__link> fn specs.ingressDeny.fromCIDRSet.withExcept </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyfromcidrsetwithexceptmixin class=md-nav__link> fn specs.ingressDeny.fromCIDRSet.withExceptMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressdenyfromendpoints class=md-nav__link> obj specs.ingressDeny.fromEndpoints </a> <nav class=md-nav aria-label="obj specs.ingressDeny.fromEndpoints"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressdenyfromendpointswithmatchexpressions class=md-nav__link> fn specs.ingressDeny.fromEndpoints.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyfromendpointswithmatchexpressionsmixin class=md-nav__link> fn specs.ingressDeny.fromEndpoints.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyfromendpointswithmatchlabels class=md-nav__link> fn specs.ingressDeny.fromEndpoints.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyfromendpointswithmatchlabelsmixin class=md-nav__link> fn specs.ingressDeny.fromEndpoints.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressdenyfromendpointsmatchexpressions class=md-nav__link> obj specs.ingressDeny.fromEndpoints.matchExpressions </a> <nav class=md-nav aria-label="obj specs.ingressDeny.fromEndpoints.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressdenyfromendpointsmatchexpressionswithkey class=md-nav__link> fn specs.ingressDeny.fromEndpoints.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyfromendpointsmatchexpressionswithoperator class=md-nav__link> fn specs.ingressDeny.fromEndpoints.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyfromendpointsmatchexpressionswithvalues class=md-nav__link> fn specs.ingressDeny.fromEndpoints.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyfromendpointsmatchexpressionswithvaluesmixin class=md-nav__link> fn specs.ingressDeny.fromEndpoints.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressdenyfromrequires class=md-nav__link> obj specs.ingressDeny.fromRequires </a> <nav class=md-nav aria-label="obj specs.ingressDeny.fromRequires"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressdenyfromrequireswithmatchexpressions class=md-nav__link> fn specs.ingressDeny.fromRequires.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyfromrequireswithmatchexpressionsmixin class=md-nav__link> fn specs.ingressDeny.fromRequires.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyfromrequireswithmatchlabels class=md-nav__link> fn specs.ingressDeny.fromRequires.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyfromrequireswithmatchlabelsmixin class=md-nav__link> fn specs.ingressDeny.fromRequires.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressdenyfromrequiresmatchexpressions class=md-nav__link> obj specs.ingressDeny.fromRequires.matchExpressions </a> <nav class=md-nav aria-label="obj specs.ingressDeny.fromRequires.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressdenyfromrequiresmatchexpressionswithkey class=md-nav__link> fn specs.ingressDeny.fromRequires.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyfromrequiresmatchexpressionswithoperator class=md-nav__link> fn specs.ingressDeny.fromRequires.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyfromrequiresmatchexpressionswithvalues class=md-nav__link> fn specs.ingressDeny.fromRequires.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyfromrequiresmatchexpressionswithvaluesmixin class=md-nav__link> fn specs.ingressDeny.fromRequires.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressdenyicmps class=md-nav__link> obj specs.ingressDeny.icmps </a> <nav class=md-nav aria-label="obj specs.ingressDeny.icmps"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressdenyicmpswithfields class=md-nav__link> fn specs.ingressDeny.icmps.withFields </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyicmpswithfieldsmixin class=md-nav__link> fn specs.ingressDeny.icmps.withFieldsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressdenyicmpsfields class=md-nav__link> obj specs.ingressDeny.icmps.fields </a> <nav class=md-nav aria-label="obj specs.ingressDeny.icmps.fields"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressdenyicmpsfieldswithfamily class=md-nav__link> fn specs.ingressDeny.icmps.fields.withFamily </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyicmpsfieldswithtype class=md-nav__link> fn specs.ingressDeny.icmps.fields.withType </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressdenytoports class=md-nav__link> obj specs.ingressDeny.toPorts </a> <nav class=md-nav aria-label="obj specs.ingressDeny.toPorts"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressdenytoportswithports class=md-nav__link> fn specs.ingressDeny.toPorts.withPorts </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenytoportswithportsmixin class=md-nav__link> fn specs.ingressDeny.toPorts.withPortsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressdenytoportsports class=md-nav__link> obj specs.ingressDeny.toPorts.ports </a> <nav class=md-nav aria-label="obj specs.ingressDeny.toPorts.ports"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressdenytoportsportswithport class=md-nav__link> fn specs.ingressDeny.toPorts.ports.withPort </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenytoportsportswithprotocol class=md-nav__link> fn specs.ingressDeny.toPorts.ports.withProtocol </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specslabels class=md-nav__link> obj specs.labels </a> <nav class=md-nav aria-label="obj specs.labels"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specslabelswithkey class=md-nav__link> fn specs.labels.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specslabelswithsource class=md-nav__link> fn specs.labels.withSource </a> </li> <li class=md-nav__item> <a href=#fn-specslabelswithvalue class=md-nav__link> fn specs.labels.withValue </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsnodeselector class=md-nav__link> obj specs.nodeSelector </a> <nav class=md-nav aria-label="obj specs.nodeSelector"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsnodeselectorwithmatchexpressions class=md-nav__link> fn specs.nodeSelector.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specsnodeselectorwithmatchexpressionsmixin class=md-nav__link> fn specs.nodeSelector.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsnodeselectorwithmatchlabels class=md-nav__link> fn specs.nodeSelector.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specsnodeselectorwithmatchlabelsmixin class=md-nav__link> fn specs.nodeSelector.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsnodeselectormatchexpressions class=md-nav__link> obj specs.nodeSelector.matchExpressions </a> <nav class=md-nav aria-label="obj specs.nodeSelector.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsnodeselectormatchexpressionswithkey class=md-nav__link> fn specs.nodeSelector.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specsnodeselectormatchexpressionswithoperator class=md-nav__link> fn specs.nodeSelector.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specsnodeselectormatchexpressionswithvalues class=md-nav__link> fn specs.nodeSelector.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specsnodeselectormatchexpressionswithvaluesmixin class=md-nav__link> fn specs.nodeSelector.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../ciliumNode/ class=md-nav__link> cilium.v2.ciliumNode </a> </li> </ul> </nav> </li> </ul> </nav> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#index class=md-nav__link> Index </a> </li> <li class=md-nav__item> <a href=#fields class=md-nav__link> Fields </a> <nav class=md-nav aria-label=Fields> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-new class=md-nav__link> fn new </a> </li> <li class=md-nav__item> <a href=#fn-withspecs class=md-nav__link> fn withSpecs </a> </li> <li class=md-nav__item> <a href=#fn-withspecsmixin class=md-nav__link> fn withSpecsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-metadata class=md-nav__link> obj metadata </a> <nav class=md-nav aria-label="obj metadata"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-metadatawithannotations class=md-nav__link> fn metadata.withAnnotations </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithannotationsmixin class=md-nav__link> fn metadata.withAnnotationsMixin </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithclustername class=md-nav__link> fn metadata.withClusterName </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithcreationtimestamp class=md-nav__link> fn metadata.withCreationTimestamp </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithdeletiongraceperiodseconds class=md-nav__link> fn metadata.withDeletionGracePeriodSeconds </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithdeletiontimestamp class=md-nav__link> fn metadata.withDeletionTimestamp </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithfinalizers class=md-nav__link> fn metadata.withFinalizers </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithfinalizersmixin class=md-nav__link> fn metadata.withFinalizersMixin </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithgeneratename class=md-nav__link> fn metadata.withGenerateName </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithgeneration class=md-nav__link> fn metadata.withGeneration </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithlabels class=md-nav__link> fn metadata.withLabels </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithlabelsmixin class=md-nav__link> fn metadata.withLabelsMixin </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithname class=md-nav__link> fn metadata.withName </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithnamespace class=md-nav__link> fn metadata.withNamespace </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithownerreferences class=md-nav__link> fn metadata.withOwnerReferences </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithownerreferencesmixin class=md-nav__link> fn metadata.withOwnerReferencesMixin </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithresourceversion class=md-nav__link> fn metadata.withResourceVersion </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithselflink class=md-nav__link> fn metadata.withSelfLink </a> </li> <li class=md-nav__item> <a href=#fn-metadatawithuid class=md-nav__link> fn metadata.withUid </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-spec class=md-nav__link> obj spec </a> <nav class=md-nav aria-label="obj spec"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specwithdescription class=md-nav__link> fn spec.withDescription </a> </li> <li class=md-nav__item> <a href=#fn-specwithegress class=md-nav__link> fn spec.withEgress </a> </li> <li class=md-nav__item> <a href=#fn-specwithegressdeny class=md-nav__link> fn spec.withEgressDeny </a> </li> <li class=md-nav__item> <a href=#fn-specwithegressdenymixin class=md-nav__link> fn spec.withEgressDenyMixin </a> </li> <li class=md-nav__item> <a href=#fn-specwithegressmixin class=md-nav__link> fn spec.withEgressMixin </a> </li> <li class=md-nav__item> <a href=#fn-specwithingress class=md-nav__link> fn spec.withIngress </a> </li> <li class=md-nav__item> <a href=#fn-specwithingressdeny class=md-nav__link> fn spec.withIngressDeny </a> </li> <li class=md-nav__item> <a href=#fn-specwithingressdenymixin class=md-nav__link> fn spec.withIngressDenyMixin </a> </li> <li class=md-nav__item> <a href=#fn-specwithingressmixin class=md-nav__link> fn spec.withIngressMixin </a> </li> <li class=md-nav__item> <a href=#fn-specwithlabels class=md-nav__link> fn spec.withLabels </a> </li> <li class=md-nav__item> <a href=#fn-specwithlabelsmixin class=md-nav__link> fn spec.withLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegress class=md-nav__link> obj spec.egress </a> <nav class=md-nav aria-label="obj spec.egress"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresswithicmps class=md-nav__link> fn spec.egress.withIcmps </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithicmpsmixin class=md-nav__link> fn spec.egress.withIcmpsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtocidr class=md-nav__link> fn spec.egress.withToCIDR </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtocidrmixin class=md-nav__link> fn spec.egress.withToCIDRMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtocidrset class=md-nav__link> fn spec.egress.withToCIDRSet </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtocidrsetmixin class=md-nav__link> fn spec.egress.withToCIDRSetMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtoendpoints class=md-nav__link> fn spec.egress.withToEndpoints </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtoendpointsmixin class=md-nav__link> fn spec.egress.withToEndpointsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtoentities class=md-nav__link> fn spec.egress.withToEntities </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtoentitiesmixin class=md-nav__link> fn spec.egress.withToEntitiesMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtofqdns class=md-nav__link> fn spec.egress.withToFQDNs </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtofqdnsmixin class=md-nav__link> fn spec.egress.withToFQDNsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtogroups class=md-nav__link> fn spec.egress.withToGroups </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtogroupsmixin class=md-nav__link> fn spec.egress.withToGroupsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtoports class=md-nav__link> fn spec.egress.withToPorts </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtoportsmixin class=md-nav__link> fn spec.egress.withToPortsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtorequires class=md-nav__link> fn spec.egress.withToRequires </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtorequiresmixin class=md-nav__link> fn spec.egress.withToRequiresMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtoservices class=md-nav__link> fn spec.egress.withToServices </a> </li> <li class=md-nav__item> <a href=#fn-specegresswithtoservicesmixin class=md-nav__link> fn spec.egress.withToServicesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressicmps class=md-nav__link> obj spec.egress.icmps </a> <nav class=md-nav aria-label="obj spec.egress.icmps"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressicmpswithfields class=md-nav__link> fn spec.egress.icmps.withFields </a> </li> <li class=md-nav__item> <a href=#fn-specegressicmpswithfieldsmixin class=md-nav__link> fn spec.egress.icmps.withFieldsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressicmpsfields class=md-nav__link> obj spec.egress.icmps.fields </a> <nav class=md-nav aria-label="obj spec.egress.icmps.fields"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressicmpsfieldswithfamily class=md-nav__link> fn spec.egress.icmps.fields.withFamily </a> </li> <li class=md-nav__item> <a href=#fn-specegressicmpsfieldswithtype class=md-nav__link> fn spec.egress.icmps.fields.withType </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstocidrset class=md-nav__link> obj spec.egress.toCIDRSet </a> <nav class=md-nav aria-label="obj spec.egress.toCIDRSet"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstocidrsetwithcidr class=md-nav__link> fn spec.egress.toCIDRSet.withCidr </a> </li> <li class=md-nav__item> <a href=#fn-specegresstocidrsetwithexcept class=md-nav__link> fn spec.egress.toCIDRSet.withExcept </a> </li> <li class=md-nav__item> <a href=#fn-specegresstocidrsetwithexceptmixin class=md-nav__link> fn spec.egress.toCIDRSet.withExceptMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoendpoints class=md-nav__link> obj spec.egress.toEndpoints </a> <nav class=md-nav aria-label="obj spec.egress.toEndpoints"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoendpointswithmatchexpressions class=md-nav__link> fn spec.egress.toEndpoints.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoendpointswithmatchexpressionsmixin class=md-nav__link> fn spec.egress.toEndpoints.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoendpointswithmatchlabels class=md-nav__link> fn spec.egress.toEndpoints.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoendpointswithmatchlabelsmixin class=md-nav__link> fn spec.egress.toEndpoints.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoendpointsmatchexpressions class=md-nav__link> obj spec.egress.toEndpoints.matchExpressions </a> <nav class=md-nav aria-label="obj spec.egress.toEndpoints.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoendpointsmatchexpressionswithkey class=md-nav__link> fn spec.egress.toEndpoints.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoendpointsmatchexpressionswithoperator class=md-nav__link> fn spec.egress.toEndpoints.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoendpointsmatchexpressionswithvalues class=md-nav__link> fn spec.egress.toEndpoints.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoendpointsmatchexpressionswithvaluesmixin class=md-nav__link> fn spec.egress.toEndpoints.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstofqdns class=md-nav__link> obj spec.egress.toFQDNs </a> <nav class=md-nav aria-label="obj spec.egress.toFQDNs"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstofqdnswithmatchname class=md-nav__link> fn spec.egress.toFQDNs.withMatchName </a> </li> <li class=md-nav__item> <a href=#fn-specegresstofqdnswithmatchpattern class=md-nav__link> fn spec.egress.toFQDNs.withMatchPattern </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstogroups class=md-nav__link> obj spec.egress.toGroups </a> </li> <li class=md-nav__item> <a href=#obj-specegresstogroupsaws class=md-nav__link> obj spec.egress.toGroups.aws </a> <nav class=md-nav aria-label="obj spec.egress.toGroups.aws"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstogroupsawswithlabels class=md-nav__link> fn spec.egress.toGroups.aws.withLabels </a> </li> <li class=md-nav__item> <a href=#fn-specegresstogroupsawswithlabelsmixin class=md-nav__link> fn spec.egress.toGroups.aws.withLabelsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresstogroupsawswithregion class=md-nav__link> fn spec.egress.toGroups.aws.withRegion </a> </li> <li class=md-nav__item> <a href=#fn-specegresstogroupsawswithsecuritygroupsids class=md-nav__link> fn spec.egress.toGroups.aws.withSecurityGroupsIds </a> </li> <li class=md-nav__item> <a href=#fn-specegresstogroupsawswithsecuritygroupsidsmixin class=md-nav__link> fn spec.egress.toGroups.aws.withSecurityGroupsIdsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresstogroupsawswithsecuritygroupsnames class=md-nav__link> fn spec.egress.toGroups.aws.withSecurityGroupsNames </a> </li> <li class=md-nav__item> <a href=#fn-specegresstogroupsawswithsecuritygroupsnamesmixin class=md-nav__link> fn spec.egress.toGroups.aws.withSecurityGroupsNamesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoports class=md-nav__link> obj spec.egress.toPorts </a> <nav class=md-nav aria-label="obj spec.egress.toPorts"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoportswithports class=md-nav__link> fn spec.egress.toPorts.withPorts </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportswithportsmixin class=md-nav__link> fn spec.egress.toPorts.withPortsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoportsoriginatingtls class=md-nav__link> obj spec.egress.toPorts.originatingTLS </a> <nav class=md-nav aria-label="obj spec.egress.toPorts.originatingTLS"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoportsoriginatingtlswithcertificate class=md-nav__link> fn spec.egress.toPorts.originatingTLS.withCertificate </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsoriginatingtlswithprivatekey class=md-nav__link> fn spec.egress.toPorts.originatingTLS.withPrivateKey </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsoriginatingtlswithtrustedca class=md-nav__link> fn spec.egress.toPorts.originatingTLS.withTrustedCA </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoportsoriginatingtlssecret class=md-nav__link> obj spec.egress.toPorts.originatingTLS.secret </a> <nav class=md-nav aria-label="obj spec.egress.toPorts.originatingTLS.secret"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoportsoriginatingtlssecretwithname class=md-nav__link> fn spec.egress.toPorts.originatingTLS.secret.withName </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsoriginatingtlssecretwithnamespace class=md-nav__link> fn spec.egress.toPorts.originatingTLS.secret.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoportsports class=md-nav__link> obj spec.egress.toPorts.ports </a> <nav class=md-nav aria-label="obj spec.egress.toPorts.ports"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoportsportswithport class=md-nav__link> fn spec.egress.toPorts.ports.withPort </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsportswithprotocol class=md-nav__link> fn spec.egress.toPorts.ports.withProtocol </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoportsrules class=md-nav__link> obj spec.egress.toPorts.rules </a> <nav class=md-nav aria-label="obj spec.egress.toPorts.rules"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoportsruleswithdns class=md-nav__link> fn spec.egress.toPorts.rules.withDns </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleswithdnsmixin class=md-nav__link> fn spec.egress.toPorts.rules.withDnsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleswithhttp class=md-nav__link> fn spec.egress.toPorts.rules.withHttp </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleswithhttpmixin class=md-nav__link> fn spec.egress.toPorts.rules.withHttpMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleswithkafka class=md-nav__link> fn spec.egress.toPorts.rules.withKafka </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleswithkafkamixin class=md-nav__link> fn spec.egress.toPorts.rules.withKafkaMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleswithl7 class=md-nav__link> fn spec.egress.toPorts.rules.withL7 </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleswithl7mixin class=md-nav__link> fn spec.egress.toPorts.rules.withL7Mixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleswithl7proto class=md-nav__link> fn spec.egress.toPorts.rules.withL7proto </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoportsrulesdns class=md-nav__link> obj spec.egress.toPorts.rules.dns </a> <nav class=md-nav aria-label="obj spec.egress.toPorts.rules.dns"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoportsrulesdnswithmatchname class=md-nav__link> fn spec.egress.toPorts.rules.dns.withMatchName </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsrulesdnswithmatchpattern class=md-nav__link> fn spec.egress.toPorts.rules.dns.withMatchPattern </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoportsruleshttp class=md-nav__link> obj spec.egress.toPorts.rules.http </a> <nav class=md-nav aria-label="obj spec.egress.toPorts.rules.http"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoportsruleshttpwithheadermatches class=md-nav__link> fn spec.egress.toPorts.rules.http.withHeaderMatches </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleshttpwithheadermatchesmixin class=md-nav__link> fn spec.egress.toPorts.rules.http.withHeaderMatchesMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleshttpwithheaders class=md-nav__link> fn spec.egress.toPorts.rules.http.withHeaders </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleshttpwithheadersmixin class=md-nav__link> fn spec.egress.toPorts.rules.http.withHeadersMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleshttpwithhost class=md-nav__link> fn spec.egress.toPorts.rules.http.withHost </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleshttpwithmethod class=md-nav__link> fn spec.egress.toPorts.rules.http.withMethod </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleshttpwithpath class=md-nav__link> fn spec.egress.toPorts.rules.http.withPath </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoportsruleshttpheadermatches class=md-nav__link> obj spec.egress.toPorts.rules.http.headerMatches </a> <nav class=md-nav aria-label="obj spec.egress.toPorts.rules.http.headerMatches"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoportsruleshttpheadermatcheswithmismatch class=md-nav__link> fn spec.egress.toPorts.rules.http.headerMatches.withMismatch </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleshttpheadermatcheswithname class=md-nav__link> fn spec.egress.toPorts.rules.http.headerMatches.withName </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleshttpheadermatcheswithvalue class=md-nav__link> fn spec.egress.toPorts.rules.http.headerMatches.withValue </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoportsruleshttpheadermatchessecret class=md-nav__link> obj spec.egress.toPorts.rules.http.headerMatches.secret </a> <nav class=md-nav aria-label="obj spec.egress.toPorts.rules.http.headerMatches.secret"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoportsruleshttpheadermatchessecretwithname class=md-nav__link> fn spec.egress.toPorts.rules.http.headerMatches.secret.withName </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleshttpheadermatchessecretwithnamespace class=md-nav__link> fn spec.egress.toPorts.rules.http.headerMatches.secret.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoportsruleskafka class=md-nav__link> obj spec.egress.toPorts.rules.kafka </a> <nav class=md-nav aria-label="obj spec.egress.toPorts.rules.kafka"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoportsruleskafkawithapikey class=md-nav__link> fn spec.egress.toPorts.rules.kafka.withApiKey </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleskafkawithapiversion class=md-nav__link> fn spec.egress.toPorts.rules.kafka.withApiVersion </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleskafkawithclientid class=md-nav__link> fn spec.egress.toPorts.rules.kafka.withClientID </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleskafkawithrole class=md-nav__link> fn spec.egress.toPorts.rules.kafka.withRole </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsruleskafkawithtopic class=md-nav__link> fn spec.egress.toPorts.rules.kafka.withTopic </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoportsterminatingtls class=md-nav__link> obj spec.egress.toPorts.terminatingTLS </a> <nav class=md-nav aria-label="obj spec.egress.toPorts.terminatingTLS"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoportsterminatingtlswithcertificate class=md-nav__link> fn spec.egress.toPorts.terminatingTLS.withCertificate </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsterminatingtlswithprivatekey class=md-nav__link> fn spec.egress.toPorts.terminatingTLS.withPrivateKey </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsterminatingtlswithtrustedca class=md-nav__link> fn spec.egress.toPorts.terminatingTLS.withTrustedCA </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoportsterminatingtlssecret class=md-nav__link> obj spec.egress.toPorts.terminatingTLS.secret </a> <nav class=md-nav aria-label="obj spec.egress.toPorts.terminatingTLS.secret"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoportsterminatingtlssecretwithname class=md-nav__link> fn spec.egress.toPorts.terminatingTLS.secret.withName </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoportsterminatingtlssecretwithnamespace class=md-nav__link> fn spec.egress.toPorts.terminatingTLS.secret.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstorequires class=md-nav__link> obj spec.egress.toRequires </a> <nav class=md-nav aria-label="obj spec.egress.toRequires"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstorequireswithmatchexpressions class=md-nav__link> fn spec.egress.toRequires.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specegresstorequireswithmatchexpressionsmixin class=md-nav__link> fn spec.egress.toRequires.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresstorequireswithmatchlabels class=md-nav__link> fn spec.egress.toRequires.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specegresstorequireswithmatchlabelsmixin class=md-nav__link> fn spec.egress.toRequires.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstorequiresmatchexpressions class=md-nav__link> obj spec.egress.toRequires.matchExpressions </a> <nav class=md-nav aria-label="obj spec.egress.toRequires.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstorequiresmatchexpressionswithkey class=md-nav__link> fn spec.egress.toRequires.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specegresstorequiresmatchexpressionswithoperator class=md-nav__link> fn spec.egress.toRequires.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specegresstorequiresmatchexpressionswithvalues class=md-nav__link> fn spec.egress.toRequires.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specegresstorequiresmatchexpressionswithvaluesmixin class=md-nav__link> fn spec.egress.toRequires.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoservices class=md-nav__link> obj spec.egress.toServices </a> </li> <li class=md-nav__item> <a href=#obj-specegresstoservicesk8sservice class=md-nav__link> obj spec.egress.toServices.k8sService </a> <nav class=md-nav aria-label="obj spec.egress.toServices.k8sService"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoservicesk8sservicewithnamespace class=md-nav__link> fn spec.egress.toServices.k8sService.withNamespace </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoservicesk8sservicewithservicename class=md-nav__link> fn spec.egress.toServices.k8sService.withServiceName </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoservicesk8sserviceselector class=md-nav__link> obj spec.egress.toServices.k8sServiceSelector </a> <nav class=md-nav aria-label="obj spec.egress.toServices.k8sServiceSelector"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoservicesk8sserviceselectorwithnamespace class=md-nav__link> fn spec.egress.toServices.k8sServiceSelector.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoservicesk8sserviceselectorselector class=md-nav__link> obj spec.egress.toServices.k8sServiceSelector.selector </a> <nav class=md-nav aria-label="obj spec.egress.toServices.k8sServiceSelector.selector"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoservicesk8sserviceselectorselectorwithmatchexpressions class=md-nav__link> fn spec.egress.toServices.k8sServiceSelector.selector.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoservicesk8sserviceselectorselectorwithmatchexpressionsmixin class=md-nav__link> fn spec.egress.toServices.k8sServiceSelector.selector.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoservicesk8sserviceselectorselectorwithmatchlabels class=md-nav__link> fn spec.egress.toServices.k8sServiceSelector.selector.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoservicesk8sserviceselectorselectorwithmatchlabelsmixin class=md-nav__link> fn spec.egress.toServices.k8sServiceSelector.selector.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegresstoservicesk8sserviceselectorselectormatchexpressions class=md-nav__link> obj spec.egress.toServices.k8sServiceSelector.selector.matchExpressions </a> <nav class=md-nav aria-label="obj spec.egress.toServices.k8sServiceSelector.selector.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegresstoservicesk8sserviceselectorselectormatchexpressionswithkey class=md-nav__link> fn spec.egress.toServices.k8sServiceSelector.selector.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoservicesk8sserviceselectorselectormatchexpressionswithoperator class=md-nav__link> fn spec.egress.toServices.k8sServiceSelector.selector.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoservicesk8sserviceselectorselectormatchexpressionswithvalues class=md-nav__link> fn spec.egress.toServices.k8sServiceSelector.selector.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specegresstoservicesk8sserviceselectorselectormatchexpressionswithvaluesmixin class=md-nav__link> fn spec.egress.toServices.k8sServiceSelector.selector.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdeny class=md-nav__link> obj spec.egressDeny </a> <nav class=md-nav aria-label="obj spec.egressDeny"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenywithicmps class=md-nav__link> fn spec.egressDeny.withIcmps </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithicmpsmixin class=md-nav__link> fn spec.egressDeny.withIcmpsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtocidr class=md-nav__link> fn spec.egressDeny.withToCIDR </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtocidrmixin class=md-nav__link> fn spec.egressDeny.withToCIDRMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtocidrset class=md-nav__link> fn spec.egressDeny.withToCIDRSet </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtocidrsetmixin class=md-nav__link> fn spec.egressDeny.withToCIDRSetMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtoendpoints class=md-nav__link> fn spec.egressDeny.withToEndpoints </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtoendpointsmixin class=md-nav__link> fn spec.egressDeny.withToEndpointsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtoentities class=md-nav__link> fn spec.egressDeny.withToEntities </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtoentitiesmixin class=md-nav__link> fn spec.egressDeny.withToEntitiesMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtogroups class=md-nav__link> fn spec.egressDeny.withToGroups </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtogroupsmixin class=md-nav__link> fn spec.egressDeny.withToGroupsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtoports class=md-nav__link> fn spec.egressDeny.withToPorts </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtoportsmixin class=md-nav__link> fn spec.egressDeny.withToPortsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtorequires class=md-nav__link> fn spec.egressDeny.withToRequires </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtorequiresmixin class=md-nav__link> fn spec.egressDeny.withToRequiresMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtoservices class=md-nav__link> fn spec.egressDeny.withToServices </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenywithtoservicesmixin class=md-nav__link> fn spec.egressDeny.withToServicesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdenyicmps class=md-nav__link> obj spec.egressDeny.icmps </a> <nav class=md-nav aria-label="obj spec.egressDeny.icmps"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenyicmpswithfields class=md-nav__link> fn spec.egressDeny.icmps.withFields </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenyicmpswithfieldsmixin class=md-nav__link> fn spec.egressDeny.icmps.withFieldsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdenyicmpsfields class=md-nav__link> obj spec.egressDeny.icmps.fields </a> <nav class=md-nav aria-label="obj spec.egressDeny.icmps.fields"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenyicmpsfieldswithfamily class=md-nav__link> fn spec.egressDeny.icmps.fields.withFamily </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenyicmpsfieldswithtype class=md-nav__link> fn spec.egressDeny.icmps.fields.withType </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdenytocidrset class=md-nav__link> obj spec.egressDeny.toCIDRSet </a> <nav class=md-nav aria-label="obj spec.egressDeny.toCIDRSet"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenytocidrsetwithcidr class=md-nav__link> fn spec.egressDeny.toCIDRSet.withCidr </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytocidrsetwithexcept class=md-nav__link> fn spec.egressDeny.toCIDRSet.withExcept </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytocidrsetwithexceptmixin class=md-nav__link> fn spec.egressDeny.toCIDRSet.withExceptMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdenytoendpoints class=md-nav__link> obj spec.egressDeny.toEndpoints </a> <nav class=md-nav aria-label="obj spec.egressDeny.toEndpoints"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenytoendpointswithmatchexpressions class=md-nav__link> fn spec.egressDeny.toEndpoints.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoendpointswithmatchexpressionsmixin class=md-nav__link> fn spec.egressDeny.toEndpoints.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoendpointswithmatchlabels class=md-nav__link> fn spec.egressDeny.toEndpoints.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoendpointswithmatchlabelsmixin class=md-nav__link> fn spec.egressDeny.toEndpoints.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdenytoendpointsmatchexpressions class=md-nav__link> obj spec.egressDeny.toEndpoints.matchExpressions </a> <nav class=md-nav aria-label="obj spec.egressDeny.toEndpoints.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenytoendpointsmatchexpressionswithkey class=md-nav__link> fn spec.egressDeny.toEndpoints.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoendpointsmatchexpressionswithoperator class=md-nav__link> fn spec.egressDeny.toEndpoints.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoendpointsmatchexpressionswithvalues class=md-nav__link> fn spec.egressDeny.toEndpoints.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoendpointsmatchexpressionswithvaluesmixin class=md-nav__link> fn spec.egressDeny.toEndpoints.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdenytogroups class=md-nav__link> obj spec.egressDeny.toGroups </a> </li> <li class=md-nav__item> <a href=#obj-specegressdenytogroupsaws class=md-nav__link> obj spec.egressDeny.toGroups.aws </a> <nav class=md-nav aria-label="obj spec.egressDeny.toGroups.aws"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenytogroupsawswithlabels class=md-nav__link> fn spec.egressDeny.toGroups.aws.withLabels </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytogroupsawswithlabelsmixin class=md-nav__link> fn spec.egressDeny.toGroups.aws.withLabelsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytogroupsawswithregion class=md-nav__link> fn spec.egressDeny.toGroups.aws.withRegion </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytogroupsawswithsecuritygroupsids class=md-nav__link> fn spec.egressDeny.toGroups.aws.withSecurityGroupsIds </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytogroupsawswithsecuritygroupsidsmixin class=md-nav__link> fn spec.egressDeny.toGroups.aws.withSecurityGroupsIdsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytogroupsawswithsecuritygroupsnames class=md-nav__link> fn spec.egressDeny.toGroups.aws.withSecurityGroupsNames </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytogroupsawswithsecuritygroupsnamesmixin class=md-nav__link> fn spec.egressDeny.toGroups.aws.withSecurityGroupsNamesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdenytoports class=md-nav__link> obj spec.egressDeny.toPorts </a> <nav class=md-nav aria-label="obj spec.egressDeny.toPorts"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenytoportswithports class=md-nav__link> fn spec.egressDeny.toPorts.withPorts </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoportswithportsmixin class=md-nav__link> fn spec.egressDeny.toPorts.withPortsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdenytoportsports class=md-nav__link> obj spec.egressDeny.toPorts.ports </a> <nav class=md-nav aria-label="obj spec.egressDeny.toPorts.ports"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenytoportsportswithport class=md-nav__link> fn spec.egressDeny.toPorts.ports.withPort </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoportsportswithprotocol class=md-nav__link> fn spec.egressDeny.toPorts.ports.withProtocol </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdenytorequires class=md-nav__link> obj spec.egressDeny.toRequires </a> <nav class=md-nav aria-label="obj spec.egressDeny.toRequires"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenytorequireswithmatchexpressions class=md-nav__link> fn spec.egressDeny.toRequires.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytorequireswithmatchexpressionsmixin class=md-nav__link> fn spec.egressDeny.toRequires.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytorequireswithmatchlabels class=md-nav__link> fn spec.egressDeny.toRequires.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytorequireswithmatchlabelsmixin class=md-nav__link> fn spec.egressDeny.toRequires.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdenytorequiresmatchexpressions class=md-nav__link> obj spec.egressDeny.toRequires.matchExpressions </a> <nav class=md-nav aria-label="obj spec.egressDeny.toRequires.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenytorequiresmatchexpressionswithkey class=md-nav__link> fn spec.egressDeny.toRequires.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytorequiresmatchexpressionswithoperator class=md-nav__link> fn spec.egressDeny.toRequires.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytorequiresmatchexpressionswithvalues class=md-nav__link> fn spec.egressDeny.toRequires.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytorequiresmatchexpressionswithvaluesmixin class=md-nav__link> fn spec.egressDeny.toRequires.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdenytoservices class=md-nav__link> obj spec.egressDeny.toServices </a> </li> <li class=md-nav__item> <a href=#obj-specegressdenytoservicesk8sservice class=md-nav__link> obj spec.egressDeny.toServices.k8sService </a> <nav class=md-nav aria-label="obj spec.egressDeny.toServices.k8sService"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenytoservicesk8sservicewithnamespace class=md-nav__link> fn spec.egressDeny.toServices.k8sService.withNamespace </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoservicesk8sservicewithservicename class=md-nav__link> fn spec.egressDeny.toServices.k8sService.withServiceName </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdenytoservicesk8sserviceselector class=md-nav__link> obj spec.egressDeny.toServices.k8sServiceSelector </a> <nav class=md-nav aria-label="obj spec.egressDeny.toServices.k8sServiceSelector"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenytoservicesk8sserviceselectorwithnamespace class=md-nav__link> fn spec.egressDeny.toServices.k8sServiceSelector.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdenytoservicesk8sserviceselectorselector class=md-nav__link> obj spec.egressDeny.toServices.k8sServiceSelector.selector </a> <nav class=md-nav aria-label="obj spec.egressDeny.toServices.k8sServiceSelector.selector"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenytoservicesk8sserviceselectorselectorwithmatchexpressions class=md-nav__link> fn spec.egressDeny.toServices.k8sServiceSelector.selector.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoservicesk8sserviceselectorselectorwithmatchexpressionsmixin class=md-nav__link> fn spec.egressDeny.toServices.k8sServiceSelector.selector.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoservicesk8sserviceselectorselectorwithmatchlabels class=md-nav__link> fn spec.egressDeny.toServices.k8sServiceSelector.selector.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoservicesk8sserviceselectorselectorwithmatchlabelsmixin class=md-nav__link> fn spec.egressDeny.toServices.k8sServiceSelector.selector.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specegressdenytoservicesk8sserviceselectorselectormatchexpressions class=md-nav__link> obj spec.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions </a> <nav class=md-nav aria-label="obj spec.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specegressdenytoservicesk8sserviceselectorselectormatchexpressionswithkey class=md-nav__link> fn spec.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoservicesk8sserviceselectorselectormatchexpressionswithoperator class=md-nav__link> fn spec.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoservicesk8sserviceselectorselectormatchexpressionswithvalues class=md-nav__link> fn spec.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specegressdenytoservicesk8sserviceselectorselectormatchexpressionswithvaluesmixin class=md-nav__link> fn spec.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specendpointselector class=md-nav__link> obj spec.endpointSelector </a> <nav class=md-nav aria-label="obj spec.endpointSelector"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specendpointselectorwithmatchexpressions class=md-nav__link> fn spec.endpointSelector.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specendpointselectorwithmatchexpressionsmixin class=md-nav__link> fn spec.endpointSelector.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specendpointselectorwithmatchlabels class=md-nav__link> fn spec.endpointSelector.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specendpointselectorwithmatchlabelsmixin class=md-nav__link> fn spec.endpointSelector.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specendpointselectormatchexpressions class=md-nav__link> obj spec.endpointSelector.matchExpressions </a> <nav class=md-nav aria-label="obj spec.endpointSelector.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specendpointselectormatchexpressionswithkey class=md-nav__link> fn spec.endpointSelector.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specendpointselectormatchexpressionswithoperator class=md-nav__link> fn spec.endpointSelector.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specendpointselectormatchexpressionswithvalues class=md-nav__link> fn spec.endpointSelector.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specendpointselectormatchexpressionswithvaluesmixin class=md-nav__link> fn spec.endpointSelector.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingress class=md-nav__link> obj spec.ingress </a> <nav class=md-nav aria-label="obj spec.ingress"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingresswithfromcidr class=md-nav__link> fn spec.ingress.withFromCIDR </a> </li> <li class=md-nav__item> <a href=#fn-specingresswithfromcidrmixin class=md-nav__link> fn spec.ingress.withFromCIDRMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingresswithfromcidrset class=md-nav__link> fn spec.ingress.withFromCIDRSet </a> </li> <li class=md-nav__item> <a href=#fn-specingresswithfromcidrsetmixin class=md-nav__link> fn spec.ingress.withFromCIDRSetMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingresswithfromendpoints class=md-nav__link> fn spec.ingress.withFromEndpoints </a> </li> <li class=md-nav__item> <a href=#fn-specingresswithfromendpointsmixin class=md-nav__link> fn spec.ingress.withFromEndpointsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingresswithfromentities class=md-nav__link> fn spec.ingress.withFromEntities </a> </li> <li class=md-nav__item> <a href=#fn-specingresswithfromentitiesmixin class=md-nav__link> fn spec.ingress.withFromEntitiesMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingresswithfromrequires class=md-nav__link> fn spec.ingress.withFromRequires </a> </li> <li class=md-nav__item> <a href=#fn-specingresswithfromrequiresmixin class=md-nav__link> fn spec.ingress.withFromRequiresMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingresswithicmps class=md-nav__link> fn spec.ingress.withIcmps </a> </li> <li class=md-nav__item> <a href=#fn-specingresswithicmpsmixin class=md-nav__link> fn spec.ingress.withIcmpsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingresswithtoports class=md-nav__link> fn spec.ingress.withToPorts </a> </li> <li class=md-nav__item> <a href=#fn-specingresswithtoportsmixin class=md-nav__link> fn spec.ingress.withToPortsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressfromcidrset class=md-nav__link> obj spec.ingress.fromCIDRSet </a> <nav class=md-nav aria-label="obj spec.ingress.fromCIDRSet"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressfromcidrsetwithcidr class=md-nav__link> fn spec.ingress.fromCIDRSet.withCidr </a> </li> <li class=md-nav__item> <a href=#fn-specingressfromcidrsetwithexcept class=md-nav__link> fn spec.ingress.fromCIDRSet.withExcept </a> </li> <li class=md-nav__item> <a href=#fn-specingressfromcidrsetwithexceptmixin class=md-nav__link> fn spec.ingress.fromCIDRSet.withExceptMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressfromendpoints class=md-nav__link> obj spec.ingress.fromEndpoints </a> <nav class=md-nav aria-label="obj spec.ingress.fromEndpoints"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressfromendpointswithmatchexpressions class=md-nav__link> fn spec.ingress.fromEndpoints.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specingressfromendpointswithmatchexpressionsmixin class=md-nav__link> fn spec.ingress.fromEndpoints.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingressfromendpointswithmatchlabels class=md-nav__link> fn spec.ingress.fromEndpoints.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specingressfromendpointswithmatchlabelsmixin class=md-nav__link> fn spec.ingress.fromEndpoints.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressfromendpointsmatchexpressions class=md-nav__link> obj spec.ingress.fromEndpoints.matchExpressions </a> <nav class=md-nav aria-label="obj spec.ingress.fromEndpoints.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressfromendpointsmatchexpressionswithkey class=md-nav__link> fn spec.ingress.fromEndpoints.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specingressfromendpointsmatchexpressionswithoperator class=md-nav__link> fn spec.ingress.fromEndpoints.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specingressfromendpointsmatchexpressionswithvalues class=md-nav__link> fn spec.ingress.fromEndpoints.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specingressfromendpointsmatchexpressionswithvaluesmixin class=md-nav__link> fn spec.ingress.fromEndpoints.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressfromrequires class=md-nav__link> obj spec.ingress.fromRequires </a> <nav class=md-nav aria-label="obj spec.ingress.fromRequires"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressfromrequireswithmatchexpressions class=md-nav__link> fn spec.ingress.fromRequires.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specingressfromrequireswithmatchexpressionsmixin class=md-nav__link> fn spec.ingress.fromRequires.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingressfromrequireswithmatchlabels class=md-nav__link> fn spec.ingress.fromRequires.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specingressfromrequireswithmatchlabelsmixin class=md-nav__link> fn spec.ingress.fromRequires.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressfromrequiresmatchexpressions class=md-nav__link> obj spec.ingress.fromRequires.matchExpressions </a> <nav class=md-nav aria-label="obj spec.ingress.fromRequires.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressfromrequiresmatchexpressionswithkey class=md-nav__link> fn spec.ingress.fromRequires.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specingressfromrequiresmatchexpressionswithoperator class=md-nav__link> fn spec.ingress.fromRequires.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specingressfromrequiresmatchexpressionswithvalues class=md-nav__link> fn spec.ingress.fromRequires.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specingressfromrequiresmatchexpressionswithvaluesmixin class=md-nav__link> fn spec.ingress.fromRequires.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressicmps class=md-nav__link> obj spec.ingress.icmps </a> <nav class=md-nav aria-label="obj spec.ingress.icmps"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressicmpswithfields class=md-nav__link> fn spec.ingress.icmps.withFields </a> </li> <li class=md-nav__item> <a href=#fn-specingressicmpswithfieldsmixin class=md-nav__link> fn spec.ingress.icmps.withFieldsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressicmpsfields class=md-nav__link> obj spec.ingress.icmps.fields </a> <nav class=md-nav aria-label="obj spec.ingress.icmps.fields"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressicmpsfieldswithfamily class=md-nav__link> fn spec.ingress.icmps.fields.withFamily </a> </li> <li class=md-nav__item> <a href=#fn-specingressicmpsfieldswithtype class=md-nav__link> fn spec.ingress.icmps.fields.withType </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingresstoports class=md-nav__link> obj spec.ingress.toPorts </a> <nav class=md-nav aria-label="obj spec.ingress.toPorts"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingresstoportswithports class=md-nav__link> fn spec.ingress.toPorts.withPorts </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportswithportsmixin class=md-nav__link> fn spec.ingress.toPorts.withPortsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingresstoportsoriginatingtls class=md-nav__link> obj spec.ingress.toPorts.originatingTLS </a> <nav class=md-nav aria-label="obj spec.ingress.toPorts.originatingTLS"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingresstoportsoriginatingtlswithcertificate class=md-nav__link> fn spec.ingress.toPorts.originatingTLS.withCertificate </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsoriginatingtlswithprivatekey class=md-nav__link> fn spec.ingress.toPorts.originatingTLS.withPrivateKey </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsoriginatingtlswithtrustedca class=md-nav__link> fn spec.ingress.toPorts.originatingTLS.withTrustedCA </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingresstoportsoriginatingtlssecret class=md-nav__link> obj spec.ingress.toPorts.originatingTLS.secret </a> <nav class=md-nav aria-label="obj spec.ingress.toPorts.originatingTLS.secret"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingresstoportsoriginatingtlssecretwithname class=md-nav__link> fn spec.ingress.toPorts.originatingTLS.secret.withName </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsoriginatingtlssecretwithnamespace class=md-nav__link> fn spec.ingress.toPorts.originatingTLS.secret.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingresstoportsports class=md-nav__link> obj spec.ingress.toPorts.ports </a> <nav class=md-nav aria-label="obj spec.ingress.toPorts.ports"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingresstoportsportswithport class=md-nav__link> fn spec.ingress.toPorts.ports.withPort </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsportswithprotocol class=md-nav__link> fn spec.ingress.toPorts.ports.withProtocol </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingresstoportsrules class=md-nav__link> obj spec.ingress.toPorts.rules </a> <nav class=md-nav aria-label="obj spec.ingress.toPorts.rules"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingresstoportsruleswithdns class=md-nav__link> fn spec.ingress.toPorts.rules.withDns </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleswithdnsmixin class=md-nav__link> fn spec.ingress.toPorts.rules.withDnsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleswithhttp class=md-nav__link> fn spec.ingress.toPorts.rules.withHttp </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleswithhttpmixin class=md-nav__link> fn spec.ingress.toPorts.rules.withHttpMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleswithkafka class=md-nav__link> fn spec.ingress.toPorts.rules.withKafka </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleswithkafkamixin class=md-nav__link> fn spec.ingress.toPorts.rules.withKafkaMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleswithl7 class=md-nav__link> fn spec.ingress.toPorts.rules.withL7 </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleswithl7mixin class=md-nav__link> fn spec.ingress.toPorts.rules.withL7Mixin </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleswithl7proto class=md-nav__link> fn spec.ingress.toPorts.rules.withL7proto </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingresstoportsrulesdns class=md-nav__link> obj spec.ingress.toPorts.rules.dns </a> <nav class=md-nav aria-label="obj spec.ingress.toPorts.rules.dns"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingresstoportsrulesdnswithmatchname class=md-nav__link> fn spec.ingress.toPorts.rules.dns.withMatchName </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsrulesdnswithmatchpattern class=md-nav__link> fn spec.ingress.toPorts.rules.dns.withMatchPattern </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingresstoportsruleshttp class=md-nav__link> obj spec.ingress.toPorts.rules.http </a> <nav class=md-nav aria-label="obj spec.ingress.toPorts.rules.http"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingresstoportsruleshttpwithheadermatches class=md-nav__link> fn spec.ingress.toPorts.rules.http.withHeaderMatches </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleshttpwithheadermatchesmixin class=md-nav__link> fn spec.ingress.toPorts.rules.http.withHeaderMatchesMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleshttpwithheaders class=md-nav__link> fn spec.ingress.toPorts.rules.http.withHeaders </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleshttpwithheadersmixin class=md-nav__link> fn spec.ingress.toPorts.rules.http.withHeadersMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleshttpwithhost class=md-nav__link> fn spec.ingress.toPorts.rules.http.withHost </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleshttpwithmethod class=md-nav__link> fn spec.ingress.toPorts.rules.http.withMethod </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleshttpwithpath class=md-nav__link> fn spec.ingress.toPorts.rules.http.withPath </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingresstoportsruleshttpheadermatches class=md-nav__link> obj spec.ingress.toPorts.rules.http.headerMatches </a> <nav class=md-nav aria-label="obj spec.ingress.toPorts.rules.http.headerMatches"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingresstoportsruleshttpheadermatcheswithmismatch class=md-nav__link> fn spec.ingress.toPorts.rules.http.headerMatches.withMismatch </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleshttpheadermatcheswithname class=md-nav__link> fn spec.ingress.toPorts.rules.http.headerMatches.withName </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleshttpheadermatcheswithvalue class=md-nav__link> fn spec.ingress.toPorts.rules.http.headerMatches.withValue </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingresstoportsruleshttpheadermatchessecret class=md-nav__link> obj spec.ingress.toPorts.rules.http.headerMatches.secret </a> <nav class=md-nav aria-label="obj spec.ingress.toPorts.rules.http.headerMatches.secret"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingresstoportsruleshttpheadermatchessecretwithname class=md-nav__link> fn spec.ingress.toPorts.rules.http.headerMatches.secret.withName </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleshttpheadermatchessecretwithnamespace class=md-nav__link> fn spec.ingress.toPorts.rules.http.headerMatches.secret.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingresstoportsruleskafka class=md-nav__link> obj spec.ingress.toPorts.rules.kafka </a> <nav class=md-nav aria-label="obj spec.ingress.toPorts.rules.kafka"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingresstoportsruleskafkawithapikey class=md-nav__link> fn spec.ingress.toPorts.rules.kafka.withApiKey </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleskafkawithapiversion class=md-nav__link> fn spec.ingress.toPorts.rules.kafka.withApiVersion </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleskafkawithclientid class=md-nav__link> fn spec.ingress.toPorts.rules.kafka.withClientID </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleskafkawithrole class=md-nav__link> fn spec.ingress.toPorts.rules.kafka.withRole </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsruleskafkawithtopic class=md-nav__link> fn spec.ingress.toPorts.rules.kafka.withTopic </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingresstoportsterminatingtls class=md-nav__link> obj spec.ingress.toPorts.terminatingTLS </a> <nav class=md-nav aria-label="obj spec.ingress.toPorts.terminatingTLS"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingresstoportsterminatingtlswithcertificate class=md-nav__link> fn spec.ingress.toPorts.terminatingTLS.withCertificate </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsterminatingtlswithprivatekey class=md-nav__link> fn spec.ingress.toPorts.terminatingTLS.withPrivateKey </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsterminatingtlswithtrustedca class=md-nav__link> fn spec.ingress.toPorts.terminatingTLS.withTrustedCA </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingresstoportsterminatingtlssecret class=md-nav__link> obj spec.ingress.toPorts.terminatingTLS.secret </a> <nav class=md-nav aria-label="obj spec.ingress.toPorts.terminatingTLS.secret"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingresstoportsterminatingtlssecretwithname class=md-nav__link> fn spec.ingress.toPorts.terminatingTLS.secret.withName </a> </li> <li class=md-nav__item> <a href=#fn-specingresstoportsterminatingtlssecretwithnamespace class=md-nav__link> fn spec.ingress.toPorts.terminatingTLS.secret.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressdeny class=md-nav__link> obj spec.ingressDeny </a> <nav class=md-nav aria-label="obj spec.ingressDeny"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressdenywithfromcidr class=md-nav__link> fn spec.ingressDeny.withFromCIDR </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenywithfromcidrmixin class=md-nav__link> fn spec.ingressDeny.withFromCIDRMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenywithfromcidrset class=md-nav__link> fn spec.ingressDeny.withFromCIDRSet </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenywithfromcidrsetmixin class=md-nav__link> fn spec.ingressDeny.withFromCIDRSetMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenywithfromendpoints class=md-nav__link> fn spec.ingressDeny.withFromEndpoints </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenywithfromendpointsmixin class=md-nav__link> fn spec.ingressDeny.withFromEndpointsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenywithfromentities class=md-nav__link> fn spec.ingressDeny.withFromEntities </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenywithfromentitiesmixin class=md-nav__link> fn spec.ingressDeny.withFromEntitiesMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenywithfromrequires class=md-nav__link> fn spec.ingressDeny.withFromRequires </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenywithfromrequiresmixin class=md-nav__link> fn spec.ingressDeny.withFromRequiresMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenywithicmps class=md-nav__link> fn spec.ingressDeny.withIcmps </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenywithicmpsmixin class=md-nav__link> fn spec.ingressDeny.withIcmpsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenywithtoports class=md-nav__link> fn spec.ingressDeny.withToPorts </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenywithtoportsmixin class=md-nav__link> fn spec.ingressDeny.withToPortsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressdenyfromcidrset class=md-nav__link> obj spec.ingressDeny.fromCIDRSet </a> <nav class=md-nav aria-label="obj spec.ingressDeny.fromCIDRSet"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressdenyfromcidrsetwithcidr class=md-nav__link> fn spec.ingressDeny.fromCIDRSet.withCidr </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyfromcidrsetwithexcept class=md-nav__link> fn spec.ingressDeny.fromCIDRSet.withExcept </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyfromcidrsetwithexceptmixin class=md-nav__link> fn spec.ingressDeny.fromCIDRSet.withExceptMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressdenyfromendpoints class=md-nav__link> obj spec.ingressDeny.fromEndpoints </a> <nav class=md-nav aria-label="obj spec.ingressDeny.fromEndpoints"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressdenyfromendpointswithmatchexpressions class=md-nav__link> fn spec.ingressDeny.fromEndpoints.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyfromendpointswithmatchexpressionsmixin class=md-nav__link> fn spec.ingressDeny.fromEndpoints.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyfromendpointswithmatchlabels class=md-nav__link> fn spec.ingressDeny.fromEndpoints.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyfromendpointswithmatchlabelsmixin class=md-nav__link> fn spec.ingressDeny.fromEndpoints.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressdenyfromendpointsmatchexpressions class=md-nav__link> obj spec.ingressDeny.fromEndpoints.matchExpressions </a> <nav class=md-nav aria-label="obj spec.ingressDeny.fromEndpoints.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressdenyfromendpointsmatchexpressionswithkey class=md-nav__link> fn spec.ingressDeny.fromEndpoints.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyfromendpointsmatchexpressionswithoperator class=md-nav__link> fn spec.ingressDeny.fromEndpoints.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyfromendpointsmatchexpressionswithvalues class=md-nav__link> fn spec.ingressDeny.fromEndpoints.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyfromendpointsmatchexpressionswithvaluesmixin class=md-nav__link> fn spec.ingressDeny.fromEndpoints.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressdenyfromrequires class=md-nav__link> obj spec.ingressDeny.fromRequires </a> <nav class=md-nav aria-label="obj spec.ingressDeny.fromRequires"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressdenyfromrequireswithmatchexpressions class=md-nav__link> fn spec.ingressDeny.fromRequires.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyfromrequireswithmatchexpressionsmixin class=md-nav__link> fn spec.ingressDeny.fromRequires.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyfromrequireswithmatchlabels class=md-nav__link> fn spec.ingressDeny.fromRequires.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyfromrequireswithmatchlabelsmixin class=md-nav__link> fn spec.ingressDeny.fromRequires.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressdenyfromrequiresmatchexpressions class=md-nav__link> obj spec.ingressDeny.fromRequires.matchExpressions </a> <nav class=md-nav aria-label="obj spec.ingressDeny.fromRequires.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressdenyfromrequiresmatchexpressionswithkey class=md-nav__link> fn spec.ingressDeny.fromRequires.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyfromrequiresmatchexpressionswithoperator class=md-nav__link> fn spec.ingressDeny.fromRequires.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyfromrequiresmatchexpressionswithvalues class=md-nav__link> fn spec.ingressDeny.fromRequires.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyfromrequiresmatchexpressionswithvaluesmixin class=md-nav__link> fn spec.ingressDeny.fromRequires.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressdenyicmps class=md-nav__link> obj spec.ingressDeny.icmps </a> <nav class=md-nav aria-label="obj spec.ingressDeny.icmps"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressdenyicmpswithfields class=md-nav__link> fn spec.ingressDeny.icmps.withFields </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyicmpswithfieldsmixin class=md-nav__link> fn spec.ingressDeny.icmps.withFieldsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressdenyicmpsfields class=md-nav__link> obj spec.ingressDeny.icmps.fields </a> <nav class=md-nav aria-label="obj spec.ingressDeny.icmps.fields"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressdenyicmpsfieldswithfamily class=md-nav__link> fn spec.ingressDeny.icmps.fields.withFamily </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenyicmpsfieldswithtype class=md-nav__link> fn spec.ingressDeny.icmps.fields.withType </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressdenytoports class=md-nav__link> obj spec.ingressDeny.toPorts </a> <nav class=md-nav aria-label="obj spec.ingressDeny.toPorts"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressdenytoportswithports class=md-nav__link> fn spec.ingressDeny.toPorts.withPorts </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenytoportswithportsmixin class=md-nav__link> fn spec.ingressDeny.toPorts.withPortsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specingressdenytoportsports class=md-nav__link> obj spec.ingressDeny.toPorts.ports </a> <nav class=md-nav aria-label="obj spec.ingressDeny.toPorts.ports"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specingressdenytoportsportswithport class=md-nav__link> fn spec.ingressDeny.toPorts.ports.withPort </a> </li> <li class=md-nav__item> <a href=#fn-specingressdenytoportsportswithprotocol class=md-nav__link> fn spec.ingressDeny.toPorts.ports.withProtocol </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-speclabels class=md-nav__link> obj spec.labels </a> <nav class=md-nav aria-label="obj spec.labels"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-speclabelswithkey class=md-nav__link> fn spec.labels.withKey </a> </li> <li class=md-nav__item> <a href=#fn-speclabelswithsource class=md-nav__link> fn spec.labels.withSource </a> </li> <li class=md-nav__item> <a href=#fn-speclabelswithvalue class=md-nav__link> fn spec.labels.withValue </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specnodeselector class=md-nav__link> obj spec.nodeSelector </a> <nav class=md-nav aria-label="obj spec.nodeSelector"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specnodeselectorwithmatchexpressions class=md-nav__link> fn spec.nodeSelector.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specnodeselectorwithmatchexpressionsmixin class=md-nav__link> fn spec.nodeSelector.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specnodeselectorwithmatchlabels class=md-nav__link> fn spec.nodeSelector.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specnodeselectorwithmatchlabelsmixin class=md-nav__link> fn spec.nodeSelector.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specnodeselectormatchexpressions class=md-nav__link> obj spec.nodeSelector.matchExpressions </a> <nav class=md-nav aria-label="obj spec.nodeSelector.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specnodeselectormatchexpressionswithkey class=md-nav__link> fn spec.nodeSelector.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specnodeselectormatchexpressionswithoperator class=md-nav__link> fn spec.nodeSelector.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specnodeselectormatchexpressionswithvalues class=md-nav__link> fn spec.nodeSelector.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specnodeselectormatchexpressionswithvaluesmixin class=md-nav__link> fn spec.nodeSelector.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specs class=md-nav__link> obj specs </a> <nav class=md-nav aria-label="obj specs"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specswithdescription class=md-nav__link> fn specs.withDescription </a> </li> <li class=md-nav__item> <a href=#fn-specswithegress class=md-nav__link> fn specs.withEgress </a> </li> <li class=md-nav__item> <a href=#fn-specswithegressdeny class=md-nav__link> fn specs.withEgressDeny </a> </li> <li class=md-nav__item> <a href=#fn-specswithegressdenymixin class=md-nav__link> fn specs.withEgressDenyMixin </a> </li> <li class=md-nav__item> <a href=#fn-specswithegressmixin class=md-nav__link> fn specs.withEgressMixin </a> </li> <li class=md-nav__item> <a href=#fn-specswithingress class=md-nav__link> fn specs.withIngress </a> </li> <li class=md-nav__item> <a href=#fn-specswithingressdeny class=md-nav__link> fn specs.withIngressDeny </a> </li> <li class=md-nav__item> <a href=#fn-specswithingressdenymixin class=md-nav__link> fn specs.withIngressDenyMixin </a> </li> <li class=md-nav__item> <a href=#fn-specswithingressmixin class=md-nav__link> fn specs.withIngressMixin </a> </li> <li class=md-nav__item> <a href=#fn-specswithlabels class=md-nav__link> fn specs.withLabels </a> </li> <li class=md-nav__item> <a href=#fn-specswithlabelsmixin class=md-nav__link> fn specs.withLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegress class=md-nav__link> obj specs.egress </a> <nav class=md-nav aria-label="obj specs.egress"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresswithicmps class=md-nav__link> fn specs.egress.withIcmps </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithicmpsmixin class=md-nav__link> fn specs.egress.withIcmpsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtocidr class=md-nav__link> fn specs.egress.withToCIDR </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtocidrmixin class=md-nav__link> fn specs.egress.withToCIDRMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtocidrset class=md-nav__link> fn specs.egress.withToCIDRSet </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtocidrsetmixin class=md-nav__link> fn specs.egress.withToCIDRSetMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtoendpoints class=md-nav__link> fn specs.egress.withToEndpoints </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtoendpointsmixin class=md-nav__link> fn specs.egress.withToEndpointsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtoentities class=md-nav__link> fn specs.egress.withToEntities </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtoentitiesmixin class=md-nav__link> fn specs.egress.withToEntitiesMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtofqdns class=md-nav__link> fn specs.egress.withToFQDNs </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtofqdnsmixin class=md-nav__link> fn specs.egress.withToFQDNsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtogroups class=md-nav__link> fn specs.egress.withToGroups </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtogroupsmixin class=md-nav__link> fn specs.egress.withToGroupsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtoports class=md-nav__link> fn specs.egress.withToPorts </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtoportsmixin class=md-nav__link> fn specs.egress.withToPortsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtorequires class=md-nav__link> fn specs.egress.withToRequires </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtorequiresmixin class=md-nav__link> fn specs.egress.withToRequiresMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtoservices class=md-nav__link> fn specs.egress.withToServices </a> </li> <li class=md-nav__item> <a href=#fn-specsegresswithtoservicesmixin class=md-nav__link> fn specs.egress.withToServicesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressicmps class=md-nav__link> obj specs.egress.icmps </a> <nav class=md-nav aria-label="obj specs.egress.icmps"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressicmpswithfields class=md-nav__link> fn specs.egress.icmps.withFields </a> </li> <li class=md-nav__item> <a href=#fn-specsegressicmpswithfieldsmixin class=md-nav__link> fn specs.egress.icmps.withFieldsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressicmpsfields class=md-nav__link> obj specs.egress.icmps.fields </a> <nav class=md-nav aria-label="obj specs.egress.icmps.fields"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressicmpsfieldswithfamily class=md-nav__link> fn specs.egress.icmps.fields.withFamily </a> </li> <li class=md-nav__item> <a href=#fn-specsegressicmpsfieldswithtype class=md-nav__link> fn specs.egress.icmps.fields.withType </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstocidrset class=md-nav__link> obj specs.egress.toCIDRSet </a> <nav class=md-nav aria-label="obj specs.egress.toCIDRSet"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstocidrsetwithcidr class=md-nav__link> fn specs.egress.toCIDRSet.withCidr </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstocidrsetwithexcept class=md-nav__link> fn specs.egress.toCIDRSet.withExcept </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstocidrsetwithexceptmixin class=md-nav__link> fn specs.egress.toCIDRSet.withExceptMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoendpoints class=md-nav__link> obj specs.egress.toEndpoints </a> <nav class=md-nav aria-label="obj specs.egress.toEndpoints"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoendpointswithmatchexpressions class=md-nav__link> fn specs.egress.toEndpoints.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoendpointswithmatchexpressionsmixin class=md-nav__link> fn specs.egress.toEndpoints.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoendpointswithmatchlabels class=md-nav__link> fn specs.egress.toEndpoints.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoendpointswithmatchlabelsmixin class=md-nav__link> fn specs.egress.toEndpoints.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoendpointsmatchexpressions class=md-nav__link> obj specs.egress.toEndpoints.matchExpressions </a> <nav class=md-nav aria-label="obj specs.egress.toEndpoints.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoendpointsmatchexpressionswithkey class=md-nav__link> fn specs.egress.toEndpoints.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoendpointsmatchexpressionswithoperator class=md-nav__link> fn specs.egress.toEndpoints.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoendpointsmatchexpressionswithvalues class=md-nav__link> fn specs.egress.toEndpoints.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoendpointsmatchexpressionswithvaluesmixin class=md-nav__link> fn specs.egress.toEndpoints.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstofqdns class=md-nav__link> obj specs.egress.toFQDNs </a> <nav class=md-nav aria-label="obj specs.egress.toFQDNs"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstofqdnswithmatchname class=md-nav__link> fn specs.egress.toFQDNs.withMatchName </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstofqdnswithmatchpattern class=md-nav__link> fn specs.egress.toFQDNs.withMatchPattern </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstogroups class=md-nav__link> obj specs.egress.toGroups </a> </li> <li class=md-nav__item> <a href=#obj-specsegresstogroupsaws class=md-nav__link> obj specs.egress.toGroups.aws </a> <nav class=md-nav aria-label="obj specs.egress.toGroups.aws"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstogroupsawswithlabels class=md-nav__link> fn specs.egress.toGroups.aws.withLabels </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstogroupsawswithlabelsmixin class=md-nav__link> fn specs.egress.toGroups.aws.withLabelsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstogroupsawswithregion class=md-nav__link> fn specs.egress.toGroups.aws.withRegion </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstogroupsawswithsecuritygroupsids class=md-nav__link> fn specs.egress.toGroups.aws.withSecurityGroupsIds </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstogroupsawswithsecuritygroupsidsmixin class=md-nav__link> fn specs.egress.toGroups.aws.withSecurityGroupsIdsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstogroupsawswithsecuritygroupsnames class=md-nav__link> fn specs.egress.toGroups.aws.withSecurityGroupsNames </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstogroupsawswithsecuritygroupsnamesmixin class=md-nav__link> fn specs.egress.toGroups.aws.withSecurityGroupsNamesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoports class=md-nav__link> obj specs.egress.toPorts </a> <nav class=md-nav aria-label="obj specs.egress.toPorts"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoportswithports class=md-nav__link> fn specs.egress.toPorts.withPorts </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportswithportsmixin class=md-nav__link> fn specs.egress.toPorts.withPortsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoportsoriginatingtls class=md-nav__link> obj specs.egress.toPorts.originatingTLS </a> <nav class=md-nav aria-label="obj specs.egress.toPorts.originatingTLS"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoportsoriginatingtlswithcertificate class=md-nav__link> fn specs.egress.toPorts.originatingTLS.withCertificate </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsoriginatingtlswithprivatekey class=md-nav__link> fn specs.egress.toPorts.originatingTLS.withPrivateKey </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsoriginatingtlswithtrustedca class=md-nav__link> fn specs.egress.toPorts.originatingTLS.withTrustedCA </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoportsoriginatingtlssecret class=md-nav__link> obj specs.egress.toPorts.originatingTLS.secret </a> <nav class=md-nav aria-label="obj specs.egress.toPorts.originatingTLS.secret"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoportsoriginatingtlssecretwithname class=md-nav__link> fn specs.egress.toPorts.originatingTLS.secret.withName </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsoriginatingtlssecretwithnamespace class=md-nav__link> fn specs.egress.toPorts.originatingTLS.secret.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoportsports class=md-nav__link> obj specs.egress.toPorts.ports </a> <nav class=md-nav aria-label="obj specs.egress.toPorts.ports"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoportsportswithport class=md-nav__link> fn specs.egress.toPorts.ports.withPort </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsportswithprotocol class=md-nav__link> fn specs.egress.toPorts.ports.withProtocol </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoportsrules class=md-nav__link> obj specs.egress.toPorts.rules </a> <nav class=md-nav aria-label="obj specs.egress.toPorts.rules"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleswithdns class=md-nav__link> fn specs.egress.toPorts.rules.withDns </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleswithdnsmixin class=md-nav__link> fn specs.egress.toPorts.rules.withDnsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleswithhttp class=md-nav__link> fn specs.egress.toPorts.rules.withHttp </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleswithhttpmixin class=md-nav__link> fn specs.egress.toPorts.rules.withHttpMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleswithkafka class=md-nav__link> fn specs.egress.toPorts.rules.withKafka </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleswithkafkamixin class=md-nav__link> fn specs.egress.toPorts.rules.withKafkaMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleswithl7 class=md-nav__link> fn specs.egress.toPorts.rules.withL7 </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleswithl7mixin class=md-nav__link> fn specs.egress.toPorts.rules.withL7Mixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleswithl7proto class=md-nav__link> fn specs.egress.toPorts.rules.withL7proto </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoportsrulesdns class=md-nav__link> obj specs.egress.toPorts.rules.dns </a> <nav class=md-nav aria-label="obj specs.egress.toPorts.rules.dns"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoportsrulesdnswithmatchname class=md-nav__link> fn specs.egress.toPorts.rules.dns.withMatchName </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsrulesdnswithmatchpattern class=md-nav__link> fn specs.egress.toPorts.rules.dns.withMatchPattern </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoportsruleshttp class=md-nav__link> obj specs.egress.toPorts.rules.http </a> <nav class=md-nav aria-label="obj specs.egress.toPorts.rules.http"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleshttpwithheadermatches class=md-nav__link> fn specs.egress.toPorts.rules.http.withHeaderMatches </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleshttpwithheadermatchesmixin class=md-nav__link> fn specs.egress.toPorts.rules.http.withHeaderMatchesMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleshttpwithheaders class=md-nav__link> fn specs.egress.toPorts.rules.http.withHeaders </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleshttpwithheadersmixin class=md-nav__link> fn specs.egress.toPorts.rules.http.withHeadersMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleshttpwithhost class=md-nav__link> fn specs.egress.toPorts.rules.http.withHost </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleshttpwithmethod class=md-nav__link> fn specs.egress.toPorts.rules.http.withMethod </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleshttpwithpath class=md-nav__link> fn specs.egress.toPorts.rules.http.withPath </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoportsruleshttpheadermatches class=md-nav__link> obj specs.egress.toPorts.rules.http.headerMatches </a> <nav class=md-nav aria-label="obj specs.egress.toPorts.rules.http.headerMatches"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleshttpheadermatcheswithmismatch class=md-nav__link> fn specs.egress.toPorts.rules.http.headerMatches.withMismatch </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleshttpheadermatcheswithname class=md-nav__link> fn specs.egress.toPorts.rules.http.headerMatches.withName </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleshttpheadermatcheswithvalue class=md-nav__link> fn specs.egress.toPorts.rules.http.headerMatches.withValue </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoportsruleshttpheadermatchessecret class=md-nav__link> obj specs.egress.toPorts.rules.http.headerMatches.secret </a> <nav class=md-nav aria-label="obj specs.egress.toPorts.rules.http.headerMatches.secret"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleshttpheadermatchessecretwithname class=md-nav__link> fn specs.egress.toPorts.rules.http.headerMatches.secret.withName </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleshttpheadermatchessecretwithnamespace class=md-nav__link> fn specs.egress.toPorts.rules.http.headerMatches.secret.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoportsruleskafka class=md-nav__link> obj specs.egress.toPorts.rules.kafka </a> <nav class=md-nav aria-label="obj specs.egress.toPorts.rules.kafka"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleskafkawithapikey class=md-nav__link> fn specs.egress.toPorts.rules.kafka.withApiKey </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleskafkawithapiversion class=md-nav__link> fn specs.egress.toPorts.rules.kafka.withApiVersion </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleskafkawithclientid class=md-nav__link> fn specs.egress.toPorts.rules.kafka.withClientID </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleskafkawithrole class=md-nav__link> fn specs.egress.toPorts.rules.kafka.withRole </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsruleskafkawithtopic class=md-nav__link> fn specs.egress.toPorts.rules.kafka.withTopic </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoportsterminatingtls class=md-nav__link> obj specs.egress.toPorts.terminatingTLS </a> <nav class=md-nav aria-label="obj specs.egress.toPorts.terminatingTLS"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoportsterminatingtlswithcertificate class=md-nav__link> fn specs.egress.toPorts.terminatingTLS.withCertificate </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsterminatingtlswithprivatekey class=md-nav__link> fn specs.egress.toPorts.terminatingTLS.withPrivateKey </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsterminatingtlswithtrustedca class=md-nav__link> fn specs.egress.toPorts.terminatingTLS.withTrustedCA </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoportsterminatingtlssecret class=md-nav__link> obj specs.egress.toPorts.terminatingTLS.secret </a> <nav class=md-nav aria-label="obj specs.egress.toPorts.terminatingTLS.secret"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoportsterminatingtlssecretwithname class=md-nav__link> fn specs.egress.toPorts.terminatingTLS.secret.withName </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoportsterminatingtlssecretwithnamespace class=md-nav__link> fn specs.egress.toPorts.terminatingTLS.secret.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstorequires class=md-nav__link> obj specs.egress.toRequires </a> <nav class=md-nav aria-label="obj specs.egress.toRequires"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstorequireswithmatchexpressions class=md-nav__link> fn specs.egress.toRequires.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstorequireswithmatchexpressionsmixin class=md-nav__link> fn specs.egress.toRequires.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstorequireswithmatchlabels class=md-nav__link> fn specs.egress.toRequires.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstorequireswithmatchlabelsmixin class=md-nav__link> fn specs.egress.toRequires.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstorequiresmatchexpressions class=md-nav__link> obj specs.egress.toRequires.matchExpressions </a> <nav class=md-nav aria-label="obj specs.egress.toRequires.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstorequiresmatchexpressionswithkey class=md-nav__link> fn specs.egress.toRequires.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstorequiresmatchexpressionswithoperator class=md-nav__link> fn specs.egress.toRequires.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstorequiresmatchexpressionswithvalues class=md-nav__link> fn specs.egress.toRequires.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstorequiresmatchexpressionswithvaluesmixin class=md-nav__link> fn specs.egress.toRequires.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoservices class=md-nav__link> obj specs.egress.toServices </a> </li> <li class=md-nav__item> <a href=#obj-specsegresstoservicesk8sservice class=md-nav__link> obj specs.egress.toServices.k8sService </a> <nav class=md-nav aria-label="obj specs.egress.toServices.k8sService"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoservicesk8sservicewithnamespace class=md-nav__link> fn specs.egress.toServices.k8sService.withNamespace </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoservicesk8sservicewithservicename class=md-nav__link> fn specs.egress.toServices.k8sService.withServiceName </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoservicesk8sserviceselector class=md-nav__link> obj specs.egress.toServices.k8sServiceSelector </a> <nav class=md-nav aria-label="obj specs.egress.toServices.k8sServiceSelector"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoservicesk8sserviceselectorwithnamespace class=md-nav__link> fn specs.egress.toServices.k8sServiceSelector.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoservicesk8sserviceselectorselector class=md-nav__link> obj specs.egress.toServices.k8sServiceSelector.selector </a> <nav class=md-nav aria-label="obj specs.egress.toServices.k8sServiceSelector.selector"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoservicesk8sserviceselectorselectorwithmatchexpressions class=md-nav__link> fn specs.egress.toServices.k8sServiceSelector.selector.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoservicesk8sserviceselectorselectorwithmatchexpressionsmixin class=md-nav__link> fn specs.egress.toServices.k8sServiceSelector.selector.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoservicesk8sserviceselectorselectorwithmatchlabels class=md-nav__link> fn specs.egress.toServices.k8sServiceSelector.selector.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoservicesk8sserviceselectorselectorwithmatchlabelsmixin class=md-nav__link> fn specs.egress.toServices.k8sServiceSelector.selector.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegresstoservicesk8sserviceselectorselectormatchexpressions class=md-nav__link> obj specs.egress.toServices.k8sServiceSelector.selector.matchExpressions </a> <nav class=md-nav aria-label="obj specs.egress.toServices.k8sServiceSelector.selector.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegresstoservicesk8sserviceselectorselectormatchexpressionswithkey class=md-nav__link> fn specs.egress.toServices.k8sServiceSelector.selector.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoservicesk8sserviceselectorselectormatchexpressionswithoperator class=md-nav__link> fn specs.egress.toServices.k8sServiceSelector.selector.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoservicesk8sserviceselectorselectormatchexpressionswithvalues class=md-nav__link> fn specs.egress.toServices.k8sServiceSelector.selector.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specsegresstoservicesk8sserviceselectorselectormatchexpressionswithvaluesmixin class=md-nav__link> fn specs.egress.toServices.k8sServiceSelector.selector.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdeny class=md-nav__link> obj specs.egressDeny </a> <nav class=md-nav aria-label="obj specs.egressDeny"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenywithicmps class=md-nav__link> fn specs.egressDeny.withIcmps </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithicmpsmixin class=md-nav__link> fn specs.egressDeny.withIcmpsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtocidr class=md-nav__link> fn specs.egressDeny.withToCIDR </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtocidrmixin class=md-nav__link> fn specs.egressDeny.withToCIDRMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtocidrset class=md-nav__link> fn specs.egressDeny.withToCIDRSet </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtocidrsetmixin class=md-nav__link> fn specs.egressDeny.withToCIDRSetMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtoendpoints class=md-nav__link> fn specs.egressDeny.withToEndpoints </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtoendpointsmixin class=md-nav__link> fn specs.egressDeny.withToEndpointsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtoentities class=md-nav__link> fn specs.egressDeny.withToEntities </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtoentitiesmixin class=md-nav__link> fn specs.egressDeny.withToEntitiesMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtogroups class=md-nav__link> fn specs.egressDeny.withToGroups </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtogroupsmixin class=md-nav__link> fn specs.egressDeny.withToGroupsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtoports class=md-nav__link> fn specs.egressDeny.withToPorts </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtoportsmixin class=md-nav__link> fn specs.egressDeny.withToPortsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtorequires class=md-nav__link> fn specs.egressDeny.withToRequires </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtorequiresmixin class=md-nav__link> fn specs.egressDeny.withToRequiresMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtoservices class=md-nav__link> fn specs.egressDeny.withToServices </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenywithtoservicesmixin class=md-nav__link> fn specs.egressDeny.withToServicesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdenyicmps class=md-nav__link> obj specs.egressDeny.icmps </a> <nav class=md-nav aria-label="obj specs.egressDeny.icmps"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenyicmpswithfields class=md-nav__link> fn specs.egressDeny.icmps.withFields </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenyicmpswithfieldsmixin class=md-nav__link> fn specs.egressDeny.icmps.withFieldsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdenyicmpsfields class=md-nav__link> obj specs.egressDeny.icmps.fields </a> <nav class=md-nav aria-label="obj specs.egressDeny.icmps.fields"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenyicmpsfieldswithfamily class=md-nav__link> fn specs.egressDeny.icmps.fields.withFamily </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenyicmpsfieldswithtype class=md-nav__link> fn specs.egressDeny.icmps.fields.withType </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdenytocidrset class=md-nav__link> obj specs.egressDeny.toCIDRSet </a> <nav class=md-nav aria-label="obj specs.egressDeny.toCIDRSet"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenytocidrsetwithcidr class=md-nav__link> fn specs.egressDeny.toCIDRSet.withCidr </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytocidrsetwithexcept class=md-nav__link> fn specs.egressDeny.toCIDRSet.withExcept </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytocidrsetwithexceptmixin class=md-nav__link> fn specs.egressDeny.toCIDRSet.withExceptMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdenytoendpoints class=md-nav__link> obj specs.egressDeny.toEndpoints </a> <nav class=md-nav aria-label="obj specs.egressDeny.toEndpoints"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenytoendpointswithmatchexpressions class=md-nav__link> fn specs.egressDeny.toEndpoints.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoendpointswithmatchexpressionsmixin class=md-nav__link> fn specs.egressDeny.toEndpoints.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoendpointswithmatchlabels class=md-nav__link> fn specs.egressDeny.toEndpoints.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoendpointswithmatchlabelsmixin class=md-nav__link> fn specs.egressDeny.toEndpoints.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdenytoendpointsmatchexpressions class=md-nav__link> obj specs.egressDeny.toEndpoints.matchExpressions </a> <nav class=md-nav aria-label="obj specs.egressDeny.toEndpoints.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenytoendpointsmatchexpressionswithkey class=md-nav__link> fn specs.egressDeny.toEndpoints.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoendpointsmatchexpressionswithoperator class=md-nav__link> fn specs.egressDeny.toEndpoints.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoendpointsmatchexpressionswithvalues class=md-nav__link> fn specs.egressDeny.toEndpoints.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoendpointsmatchexpressionswithvaluesmixin class=md-nav__link> fn specs.egressDeny.toEndpoints.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdenytogroups class=md-nav__link> obj specs.egressDeny.toGroups </a> </li> <li class=md-nav__item> <a href=#obj-specsegressdenytogroupsaws class=md-nav__link> obj specs.egressDeny.toGroups.aws </a> <nav class=md-nav aria-label="obj specs.egressDeny.toGroups.aws"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenytogroupsawswithlabels class=md-nav__link> fn specs.egressDeny.toGroups.aws.withLabels </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytogroupsawswithlabelsmixin class=md-nav__link> fn specs.egressDeny.toGroups.aws.withLabelsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytogroupsawswithregion class=md-nav__link> fn specs.egressDeny.toGroups.aws.withRegion </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytogroupsawswithsecuritygroupsids class=md-nav__link> fn specs.egressDeny.toGroups.aws.withSecurityGroupsIds </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytogroupsawswithsecuritygroupsidsmixin class=md-nav__link> fn specs.egressDeny.toGroups.aws.withSecurityGroupsIdsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytogroupsawswithsecuritygroupsnames class=md-nav__link> fn specs.egressDeny.toGroups.aws.withSecurityGroupsNames </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytogroupsawswithsecuritygroupsnamesmixin class=md-nav__link> fn specs.egressDeny.toGroups.aws.withSecurityGroupsNamesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdenytoports class=md-nav__link> obj specs.egressDeny.toPorts </a> <nav class=md-nav aria-label="obj specs.egressDeny.toPorts"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenytoportswithports class=md-nav__link> fn specs.egressDeny.toPorts.withPorts </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoportswithportsmixin class=md-nav__link> fn specs.egressDeny.toPorts.withPortsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdenytoportsports class=md-nav__link> obj specs.egressDeny.toPorts.ports </a> <nav class=md-nav aria-label="obj specs.egressDeny.toPorts.ports"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenytoportsportswithport class=md-nav__link> fn specs.egressDeny.toPorts.ports.withPort </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoportsportswithprotocol class=md-nav__link> fn specs.egressDeny.toPorts.ports.withProtocol </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdenytorequires class=md-nav__link> obj specs.egressDeny.toRequires </a> <nav class=md-nav aria-label="obj specs.egressDeny.toRequires"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenytorequireswithmatchexpressions class=md-nav__link> fn specs.egressDeny.toRequires.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytorequireswithmatchexpressionsmixin class=md-nav__link> fn specs.egressDeny.toRequires.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytorequireswithmatchlabels class=md-nav__link> fn specs.egressDeny.toRequires.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytorequireswithmatchlabelsmixin class=md-nav__link> fn specs.egressDeny.toRequires.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdenytorequiresmatchexpressions class=md-nav__link> obj specs.egressDeny.toRequires.matchExpressions </a> <nav class=md-nav aria-label="obj specs.egressDeny.toRequires.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenytorequiresmatchexpressionswithkey class=md-nav__link> fn specs.egressDeny.toRequires.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytorequiresmatchexpressionswithoperator class=md-nav__link> fn specs.egressDeny.toRequires.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytorequiresmatchexpressionswithvalues class=md-nav__link> fn specs.egressDeny.toRequires.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytorequiresmatchexpressionswithvaluesmixin class=md-nav__link> fn specs.egressDeny.toRequires.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdenytoservices class=md-nav__link> obj specs.egressDeny.toServices </a> </li> <li class=md-nav__item> <a href=#obj-specsegressdenytoservicesk8sservice class=md-nav__link> obj specs.egressDeny.toServices.k8sService </a> <nav class=md-nav aria-label="obj specs.egressDeny.toServices.k8sService"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenytoservicesk8sservicewithnamespace class=md-nav__link> fn specs.egressDeny.toServices.k8sService.withNamespace </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoservicesk8sservicewithservicename class=md-nav__link> fn specs.egressDeny.toServices.k8sService.withServiceName </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdenytoservicesk8sserviceselector class=md-nav__link> obj specs.egressDeny.toServices.k8sServiceSelector </a> <nav class=md-nav aria-label="obj specs.egressDeny.toServices.k8sServiceSelector"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenytoservicesk8sserviceselectorwithnamespace class=md-nav__link> fn specs.egressDeny.toServices.k8sServiceSelector.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdenytoservicesk8sserviceselectorselector class=md-nav__link> obj specs.egressDeny.toServices.k8sServiceSelector.selector </a> <nav class=md-nav aria-label="obj specs.egressDeny.toServices.k8sServiceSelector.selector"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenytoservicesk8sserviceselectorselectorwithmatchexpressions class=md-nav__link> fn specs.egressDeny.toServices.k8sServiceSelector.selector.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoservicesk8sserviceselectorselectorwithmatchexpressionsmixin class=md-nav__link> fn specs.egressDeny.toServices.k8sServiceSelector.selector.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoservicesk8sserviceselectorselectorwithmatchlabels class=md-nav__link> fn specs.egressDeny.toServices.k8sServiceSelector.selector.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoservicesk8sserviceselectorselectorwithmatchlabelsmixin class=md-nav__link> fn specs.egressDeny.toServices.k8sServiceSelector.selector.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsegressdenytoservicesk8sserviceselectorselectormatchexpressions class=md-nav__link> obj specs.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions </a> <nav class=md-nav aria-label="obj specs.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsegressdenytoservicesk8sserviceselectorselectormatchexpressionswithkey class=md-nav__link> fn specs.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoservicesk8sserviceselectorselectormatchexpressionswithoperator class=md-nav__link> fn specs.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoservicesk8sserviceselectorselectormatchexpressionswithvalues class=md-nav__link> fn specs.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specsegressdenytoservicesk8sserviceselectorselectormatchexpressionswithvaluesmixin class=md-nav__link> fn specs.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsendpointselector class=md-nav__link> obj specs.endpointSelector </a> <nav class=md-nav aria-label="obj specs.endpointSelector"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsendpointselectorwithmatchexpressions class=md-nav__link> fn specs.endpointSelector.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specsendpointselectorwithmatchexpressionsmixin class=md-nav__link> fn specs.endpointSelector.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsendpointselectorwithmatchlabels class=md-nav__link> fn specs.endpointSelector.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specsendpointselectorwithmatchlabelsmixin class=md-nav__link> fn specs.endpointSelector.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsendpointselectormatchexpressions class=md-nav__link> obj specs.endpointSelector.matchExpressions </a> <nav class=md-nav aria-label="obj specs.endpointSelector.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsendpointselectormatchexpressionswithkey class=md-nav__link> fn specs.endpointSelector.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specsendpointselectormatchexpressionswithoperator class=md-nav__link> fn specs.endpointSelector.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specsendpointselectormatchexpressionswithvalues class=md-nav__link> fn specs.endpointSelector.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specsendpointselectormatchexpressionswithvaluesmixin class=md-nav__link> fn specs.endpointSelector.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingress class=md-nav__link> obj specs.ingress </a> <nav class=md-nav aria-label="obj specs.ingress"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingresswithfromcidr class=md-nav__link> fn specs.ingress.withFromCIDR </a> </li> <li class=md-nav__item> <a href=#fn-specsingresswithfromcidrmixin class=md-nav__link> fn specs.ingress.withFromCIDRMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingresswithfromcidrset class=md-nav__link> fn specs.ingress.withFromCIDRSet </a> </li> <li class=md-nav__item> <a href=#fn-specsingresswithfromcidrsetmixin class=md-nav__link> fn specs.ingress.withFromCIDRSetMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingresswithfromendpoints class=md-nav__link> fn specs.ingress.withFromEndpoints </a> </li> <li class=md-nav__item> <a href=#fn-specsingresswithfromendpointsmixin class=md-nav__link> fn specs.ingress.withFromEndpointsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingresswithfromentities class=md-nav__link> fn specs.ingress.withFromEntities </a> </li> <li class=md-nav__item> <a href=#fn-specsingresswithfromentitiesmixin class=md-nav__link> fn specs.ingress.withFromEntitiesMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingresswithfromrequires class=md-nav__link> fn specs.ingress.withFromRequires </a> </li> <li class=md-nav__item> <a href=#fn-specsingresswithfromrequiresmixin class=md-nav__link> fn specs.ingress.withFromRequiresMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingresswithicmps class=md-nav__link> fn specs.ingress.withIcmps </a> </li> <li class=md-nav__item> <a href=#fn-specsingresswithicmpsmixin class=md-nav__link> fn specs.ingress.withIcmpsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingresswithtoports class=md-nav__link> fn specs.ingress.withToPorts </a> </li> <li class=md-nav__item> <a href=#fn-specsingresswithtoportsmixin class=md-nav__link> fn specs.ingress.withToPortsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressfromcidrset class=md-nav__link> obj specs.ingress.fromCIDRSet </a> <nav class=md-nav aria-label="obj specs.ingress.fromCIDRSet"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressfromcidrsetwithcidr class=md-nav__link> fn specs.ingress.fromCIDRSet.withCidr </a> </li> <li class=md-nav__item> <a href=#fn-specsingressfromcidrsetwithexcept class=md-nav__link> fn specs.ingress.fromCIDRSet.withExcept </a> </li> <li class=md-nav__item> <a href=#fn-specsingressfromcidrsetwithexceptmixin class=md-nav__link> fn specs.ingress.fromCIDRSet.withExceptMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressfromendpoints class=md-nav__link> obj specs.ingress.fromEndpoints </a> <nav class=md-nav aria-label="obj specs.ingress.fromEndpoints"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressfromendpointswithmatchexpressions class=md-nav__link> fn specs.ingress.fromEndpoints.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specsingressfromendpointswithmatchexpressionsmixin class=md-nav__link> fn specs.ingress.fromEndpoints.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingressfromendpointswithmatchlabels class=md-nav__link> fn specs.ingress.fromEndpoints.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specsingressfromendpointswithmatchlabelsmixin class=md-nav__link> fn specs.ingress.fromEndpoints.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressfromendpointsmatchexpressions class=md-nav__link> obj specs.ingress.fromEndpoints.matchExpressions </a> <nav class=md-nav aria-label="obj specs.ingress.fromEndpoints.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressfromendpointsmatchexpressionswithkey class=md-nav__link> fn specs.ingress.fromEndpoints.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specsingressfromendpointsmatchexpressionswithoperator class=md-nav__link> fn specs.ingress.fromEndpoints.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specsingressfromendpointsmatchexpressionswithvalues class=md-nav__link> fn specs.ingress.fromEndpoints.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specsingressfromendpointsmatchexpressionswithvaluesmixin class=md-nav__link> fn specs.ingress.fromEndpoints.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressfromrequires class=md-nav__link> obj specs.ingress.fromRequires </a> <nav class=md-nav aria-label="obj specs.ingress.fromRequires"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressfromrequireswithmatchexpressions class=md-nav__link> fn specs.ingress.fromRequires.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specsingressfromrequireswithmatchexpressionsmixin class=md-nav__link> fn specs.ingress.fromRequires.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingressfromrequireswithmatchlabels class=md-nav__link> fn specs.ingress.fromRequires.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specsingressfromrequireswithmatchlabelsmixin class=md-nav__link> fn specs.ingress.fromRequires.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressfromrequiresmatchexpressions class=md-nav__link> obj specs.ingress.fromRequires.matchExpressions </a> <nav class=md-nav aria-label="obj specs.ingress.fromRequires.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressfromrequiresmatchexpressionswithkey class=md-nav__link> fn specs.ingress.fromRequires.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specsingressfromrequiresmatchexpressionswithoperator class=md-nav__link> fn specs.ingress.fromRequires.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specsingressfromrequiresmatchexpressionswithvalues class=md-nav__link> fn specs.ingress.fromRequires.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specsingressfromrequiresmatchexpressionswithvaluesmixin class=md-nav__link> fn specs.ingress.fromRequires.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressicmps class=md-nav__link> obj specs.ingress.icmps </a> <nav class=md-nav aria-label="obj specs.ingress.icmps"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressicmpswithfields class=md-nav__link> fn specs.ingress.icmps.withFields </a> </li> <li class=md-nav__item> <a href=#fn-specsingressicmpswithfieldsmixin class=md-nav__link> fn specs.ingress.icmps.withFieldsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressicmpsfields class=md-nav__link> obj specs.ingress.icmps.fields </a> <nav class=md-nav aria-label="obj specs.ingress.icmps.fields"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressicmpsfieldswithfamily class=md-nav__link> fn specs.ingress.icmps.fields.withFamily </a> </li> <li class=md-nav__item> <a href=#fn-specsingressicmpsfieldswithtype class=md-nav__link> fn specs.ingress.icmps.fields.withType </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingresstoports class=md-nav__link> obj specs.ingress.toPorts </a> <nav class=md-nav aria-label="obj specs.ingress.toPorts"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingresstoportswithports class=md-nav__link> fn specs.ingress.toPorts.withPorts </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportswithportsmixin class=md-nav__link> fn specs.ingress.toPorts.withPortsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingresstoportsoriginatingtls class=md-nav__link> obj specs.ingress.toPorts.originatingTLS </a> <nav class=md-nav aria-label="obj specs.ingress.toPorts.originatingTLS"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingresstoportsoriginatingtlswithcertificate class=md-nav__link> fn specs.ingress.toPorts.originatingTLS.withCertificate </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsoriginatingtlswithprivatekey class=md-nav__link> fn specs.ingress.toPorts.originatingTLS.withPrivateKey </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsoriginatingtlswithtrustedca class=md-nav__link> fn specs.ingress.toPorts.originatingTLS.withTrustedCA </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingresstoportsoriginatingtlssecret class=md-nav__link> obj specs.ingress.toPorts.originatingTLS.secret </a> <nav class=md-nav aria-label="obj specs.ingress.toPorts.originatingTLS.secret"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingresstoportsoriginatingtlssecretwithname class=md-nav__link> fn specs.ingress.toPorts.originatingTLS.secret.withName </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsoriginatingtlssecretwithnamespace class=md-nav__link> fn specs.ingress.toPorts.originatingTLS.secret.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingresstoportsports class=md-nav__link> obj specs.ingress.toPorts.ports </a> <nav class=md-nav aria-label="obj specs.ingress.toPorts.ports"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingresstoportsportswithport class=md-nav__link> fn specs.ingress.toPorts.ports.withPort </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsportswithprotocol class=md-nav__link> fn specs.ingress.toPorts.ports.withProtocol </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingresstoportsrules class=md-nav__link> obj specs.ingress.toPorts.rules </a> <nav class=md-nav aria-label="obj specs.ingress.toPorts.rules"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleswithdns class=md-nav__link> fn specs.ingress.toPorts.rules.withDns </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleswithdnsmixin class=md-nav__link> fn specs.ingress.toPorts.rules.withDnsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleswithhttp class=md-nav__link> fn specs.ingress.toPorts.rules.withHttp </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleswithhttpmixin class=md-nav__link> fn specs.ingress.toPorts.rules.withHttpMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleswithkafka class=md-nav__link> fn specs.ingress.toPorts.rules.withKafka </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleswithkafkamixin class=md-nav__link> fn specs.ingress.toPorts.rules.withKafkaMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleswithl7 class=md-nav__link> fn specs.ingress.toPorts.rules.withL7 </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleswithl7mixin class=md-nav__link> fn specs.ingress.toPorts.rules.withL7Mixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleswithl7proto class=md-nav__link> fn specs.ingress.toPorts.rules.withL7proto </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingresstoportsrulesdns class=md-nav__link> obj specs.ingress.toPorts.rules.dns </a> <nav class=md-nav aria-label="obj specs.ingress.toPorts.rules.dns"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingresstoportsrulesdnswithmatchname class=md-nav__link> fn specs.ingress.toPorts.rules.dns.withMatchName </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsrulesdnswithmatchpattern class=md-nav__link> fn specs.ingress.toPorts.rules.dns.withMatchPattern </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingresstoportsruleshttp class=md-nav__link> obj specs.ingress.toPorts.rules.http </a> <nav class=md-nav aria-label="obj specs.ingress.toPorts.rules.http"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleshttpwithheadermatches class=md-nav__link> fn specs.ingress.toPorts.rules.http.withHeaderMatches </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleshttpwithheadermatchesmixin class=md-nav__link> fn specs.ingress.toPorts.rules.http.withHeaderMatchesMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleshttpwithheaders class=md-nav__link> fn specs.ingress.toPorts.rules.http.withHeaders </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleshttpwithheadersmixin class=md-nav__link> fn specs.ingress.toPorts.rules.http.withHeadersMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleshttpwithhost class=md-nav__link> fn specs.ingress.toPorts.rules.http.withHost </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleshttpwithmethod class=md-nav__link> fn specs.ingress.toPorts.rules.http.withMethod </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleshttpwithpath class=md-nav__link> fn specs.ingress.toPorts.rules.http.withPath </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingresstoportsruleshttpheadermatches class=md-nav__link> obj specs.ingress.toPorts.rules.http.headerMatches </a> <nav class=md-nav aria-label="obj specs.ingress.toPorts.rules.http.headerMatches"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleshttpheadermatcheswithmismatch class=md-nav__link> fn specs.ingress.toPorts.rules.http.headerMatches.withMismatch </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleshttpheadermatcheswithname class=md-nav__link> fn specs.ingress.toPorts.rules.http.headerMatches.withName </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleshttpheadermatcheswithvalue class=md-nav__link> fn specs.ingress.toPorts.rules.http.headerMatches.withValue </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingresstoportsruleshttpheadermatchessecret class=md-nav__link> obj specs.ingress.toPorts.rules.http.headerMatches.secret </a> <nav class=md-nav aria-label="obj specs.ingress.toPorts.rules.http.headerMatches.secret"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleshttpheadermatchessecretwithname class=md-nav__link> fn specs.ingress.toPorts.rules.http.headerMatches.secret.withName </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleshttpheadermatchessecretwithnamespace class=md-nav__link> fn specs.ingress.toPorts.rules.http.headerMatches.secret.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingresstoportsruleskafka class=md-nav__link> obj specs.ingress.toPorts.rules.kafka </a> <nav class=md-nav aria-label="obj specs.ingress.toPorts.rules.kafka"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleskafkawithapikey class=md-nav__link> fn specs.ingress.toPorts.rules.kafka.withApiKey </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleskafkawithapiversion class=md-nav__link> fn specs.ingress.toPorts.rules.kafka.withApiVersion </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleskafkawithclientid class=md-nav__link> fn specs.ingress.toPorts.rules.kafka.withClientID </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleskafkawithrole class=md-nav__link> fn specs.ingress.toPorts.rules.kafka.withRole </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsruleskafkawithtopic class=md-nav__link> fn specs.ingress.toPorts.rules.kafka.withTopic </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingresstoportsterminatingtls class=md-nav__link> obj specs.ingress.toPorts.terminatingTLS </a> <nav class=md-nav aria-label="obj specs.ingress.toPorts.terminatingTLS"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingresstoportsterminatingtlswithcertificate class=md-nav__link> fn specs.ingress.toPorts.terminatingTLS.withCertificate </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsterminatingtlswithprivatekey class=md-nav__link> fn specs.ingress.toPorts.terminatingTLS.withPrivateKey </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsterminatingtlswithtrustedca class=md-nav__link> fn specs.ingress.toPorts.terminatingTLS.withTrustedCA </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingresstoportsterminatingtlssecret class=md-nav__link> obj specs.ingress.toPorts.terminatingTLS.secret </a> <nav class=md-nav aria-label="obj specs.ingress.toPorts.terminatingTLS.secret"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingresstoportsterminatingtlssecretwithname class=md-nav__link> fn specs.ingress.toPorts.terminatingTLS.secret.withName </a> </li> <li class=md-nav__item> <a href=#fn-specsingresstoportsterminatingtlssecretwithnamespace class=md-nav__link> fn specs.ingress.toPorts.terminatingTLS.secret.withNamespace </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressdeny class=md-nav__link> obj specs.ingressDeny </a> <nav class=md-nav aria-label="obj specs.ingressDeny"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressdenywithfromcidr class=md-nav__link> fn specs.ingressDeny.withFromCIDR </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenywithfromcidrmixin class=md-nav__link> fn specs.ingressDeny.withFromCIDRMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenywithfromcidrset class=md-nav__link> fn specs.ingressDeny.withFromCIDRSet </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenywithfromcidrsetmixin class=md-nav__link> fn specs.ingressDeny.withFromCIDRSetMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenywithfromendpoints class=md-nav__link> fn specs.ingressDeny.withFromEndpoints </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenywithfromendpointsmixin class=md-nav__link> fn specs.ingressDeny.withFromEndpointsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenywithfromentities class=md-nav__link> fn specs.ingressDeny.withFromEntities </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenywithfromentitiesmixin class=md-nav__link> fn specs.ingressDeny.withFromEntitiesMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenywithfromrequires class=md-nav__link> fn specs.ingressDeny.withFromRequires </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenywithfromrequiresmixin class=md-nav__link> fn specs.ingressDeny.withFromRequiresMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenywithicmps class=md-nav__link> fn specs.ingressDeny.withIcmps </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenywithicmpsmixin class=md-nav__link> fn specs.ingressDeny.withIcmpsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenywithtoports class=md-nav__link> fn specs.ingressDeny.withToPorts </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenywithtoportsmixin class=md-nav__link> fn specs.ingressDeny.withToPortsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressdenyfromcidrset class=md-nav__link> obj specs.ingressDeny.fromCIDRSet </a> <nav class=md-nav aria-label="obj specs.ingressDeny.fromCIDRSet"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressdenyfromcidrsetwithcidr class=md-nav__link> fn specs.ingressDeny.fromCIDRSet.withCidr </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyfromcidrsetwithexcept class=md-nav__link> fn specs.ingressDeny.fromCIDRSet.withExcept </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyfromcidrsetwithexceptmixin class=md-nav__link> fn specs.ingressDeny.fromCIDRSet.withExceptMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressdenyfromendpoints class=md-nav__link> obj specs.ingressDeny.fromEndpoints </a> <nav class=md-nav aria-label="obj specs.ingressDeny.fromEndpoints"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressdenyfromendpointswithmatchexpressions class=md-nav__link> fn specs.ingressDeny.fromEndpoints.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyfromendpointswithmatchexpressionsmixin class=md-nav__link> fn specs.ingressDeny.fromEndpoints.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyfromendpointswithmatchlabels class=md-nav__link> fn specs.ingressDeny.fromEndpoints.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyfromendpointswithmatchlabelsmixin class=md-nav__link> fn specs.ingressDeny.fromEndpoints.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressdenyfromendpointsmatchexpressions class=md-nav__link> obj specs.ingressDeny.fromEndpoints.matchExpressions </a> <nav class=md-nav aria-label="obj specs.ingressDeny.fromEndpoints.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressdenyfromendpointsmatchexpressionswithkey class=md-nav__link> fn specs.ingressDeny.fromEndpoints.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyfromendpointsmatchexpressionswithoperator class=md-nav__link> fn specs.ingressDeny.fromEndpoints.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyfromendpointsmatchexpressionswithvalues class=md-nav__link> fn specs.ingressDeny.fromEndpoints.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyfromendpointsmatchexpressionswithvaluesmixin class=md-nav__link> fn specs.ingressDeny.fromEndpoints.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressdenyfromrequires class=md-nav__link> obj specs.ingressDeny.fromRequires </a> <nav class=md-nav aria-label="obj specs.ingressDeny.fromRequires"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressdenyfromrequireswithmatchexpressions class=md-nav__link> fn specs.ingressDeny.fromRequires.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyfromrequireswithmatchexpressionsmixin class=md-nav__link> fn specs.ingressDeny.fromRequires.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyfromrequireswithmatchlabels class=md-nav__link> fn specs.ingressDeny.fromRequires.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyfromrequireswithmatchlabelsmixin class=md-nav__link> fn specs.ingressDeny.fromRequires.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressdenyfromrequiresmatchexpressions class=md-nav__link> obj specs.ingressDeny.fromRequires.matchExpressions </a> <nav class=md-nav aria-label="obj specs.ingressDeny.fromRequires.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressdenyfromrequiresmatchexpressionswithkey class=md-nav__link> fn specs.ingressDeny.fromRequires.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyfromrequiresmatchexpressionswithoperator class=md-nav__link> fn specs.ingressDeny.fromRequires.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyfromrequiresmatchexpressionswithvalues class=md-nav__link> fn specs.ingressDeny.fromRequires.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyfromrequiresmatchexpressionswithvaluesmixin class=md-nav__link> fn specs.ingressDeny.fromRequires.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressdenyicmps class=md-nav__link> obj specs.ingressDeny.icmps </a> <nav class=md-nav aria-label="obj specs.ingressDeny.icmps"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressdenyicmpswithfields class=md-nav__link> fn specs.ingressDeny.icmps.withFields </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyicmpswithfieldsmixin class=md-nav__link> fn specs.ingressDeny.icmps.withFieldsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressdenyicmpsfields class=md-nav__link> obj specs.ingressDeny.icmps.fields </a> <nav class=md-nav aria-label="obj specs.ingressDeny.icmps.fields"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressdenyicmpsfieldswithfamily class=md-nav__link> fn specs.ingressDeny.icmps.fields.withFamily </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenyicmpsfieldswithtype class=md-nav__link> fn specs.ingressDeny.icmps.fields.withType </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressdenytoports class=md-nav__link> obj specs.ingressDeny.toPorts </a> <nav class=md-nav aria-label="obj specs.ingressDeny.toPorts"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressdenytoportswithports class=md-nav__link> fn specs.ingressDeny.toPorts.withPorts </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenytoportswithportsmixin class=md-nav__link> fn specs.ingressDeny.toPorts.withPortsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsingressdenytoportsports class=md-nav__link> obj specs.ingressDeny.toPorts.ports </a> <nav class=md-nav aria-label="obj specs.ingressDeny.toPorts.ports"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsingressdenytoportsportswithport class=md-nav__link> fn specs.ingressDeny.toPorts.ports.withPort </a> </li> <li class=md-nav__item> <a href=#fn-specsingressdenytoportsportswithprotocol class=md-nav__link> fn specs.ingressDeny.toPorts.ports.withProtocol </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specslabels class=md-nav__link> obj specs.labels </a> <nav class=md-nav aria-label="obj specs.labels"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specslabelswithkey class=md-nav__link> fn specs.labels.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specslabelswithsource class=md-nav__link> fn specs.labels.withSource </a> </li> <li class=md-nav__item> <a href=#fn-specslabelswithvalue class=md-nav__link> fn specs.labels.withValue </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsnodeselector class=md-nav__link> obj specs.nodeSelector </a> <nav class=md-nav aria-label="obj specs.nodeSelector"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsnodeselectorwithmatchexpressions class=md-nav__link> fn specs.nodeSelector.withMatchExpressions </a> </li> <li class=md-nav__item> <a href=#fn-specsnodeselectorwithmatchexpressionsmixin class=md-nav__link> fn specs.nodeSelector.withMatchExpressionsMixin </a> </li> <li class=md-nav__item> <a href=#fn-specsnodeselectorwithmatchlabels class=md-nav__link> fn specs.nodeSelector.withMatchLabels </a> </li> <li class=md-nav__item> <a href=#fn-specsnodeselectorwithmatchlabelsmixin class=md-nav__link> fn specs.nodeSelector.withMatchLabelsMixin </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#obj-specsnodeselectormatchexpressions class=md-nav__link> obj specs.nodeSelector.matchExpressions </a> <nav class=md-nav aria-label="obj specs.nodeSelector.matchExpressions"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#fn-specsnodeselectormatchexpressionswithkey class=md-nav__link> fn specs.nodeSelector.matchExpressions.withKey </a> </li> <li class=md-nav__item> <a href=#fn-specsnodeselectormatchexpressionswithoperator class=md-nav__link> fn specs.nodeSelector.matchExpressions.withOperator </a> </li> <li class=md-nav__item> <a href=#fn-specsnodeselectormatchexpressionswithvalues class=md-nav__link> fn specs.nodeSelector.matchExpressions.withValues </a> </li> <li class=md-nav__item> <a href=#fn-specsnodeselectormatchexpressionswithvaluesmixin class=md-nav__link> fn specs.nodeSelector.matchExpressions.withValuesMixin </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <h1 id=ciliumv2ciliumnetworkpolicy>cilium.v2.ciliumNetworkPolicy</h1> <p>"CiliumNetworkPolicy is a Kubernetes third-party resource with an extended version of NetworkPolicy."</p> <h2 id=index>Index</h2> <ul> <li><a href=#fn-new><code>fn new(name)</code></a></li> <li><a href=#fn-withspecs><code>fn withSpecs(specs)</code></a></li> <li><a href=#fn-withspecsmixin><code>fn withSpecsMixin(specs)</code></a></li> <li><a href=#obj-metadata><code>obj metadata</code></a></li> <li><a href=#fn-metadatawithannotations><code>fn withAnnotations(annotations)</code></a></li> <li><a href=#fn-metadatawithannotationsmixin><code>fn withAnnotationsMixin(annotations)</code></a></li> <li><a href=#fn-metadatawithclustername><code>fn withClusterName(clusterName)</code></a></li> <li><a href=#fn-metadatawithcreationtimestamp><code>fn withCreationTimestamp(creationTimestamp)</code></a></li> <li><a href=#fn-metadatawithdeletiongraceperiodseconds><code>fn withDeletionGracePeriodSeconds(deletionGracePeriodSeconds)</code></a></li> <li><a href=#fn-metadatawithdeletiontimestamp><code>fn withDeletionTimestamp(deletionTimestamp)</code></a></li> <li><a href=#fn-metadatawithfinalizers><code>fn withFinalizers(finalizers)</code></a></li> <li><a href=#fn-metadatawithfinalizersmixin><code>fn withFinalizersMixin(finalizers)</code></a></li> <li><a href=#fn-metadatawithgeneratename><code>fn withGenerateName(generateName)</code></a></li> <li><a href=#fn-metadatawithgeneration><code>fn withGeneration(generation)</code></a></li> <li><a href=#fn-metadatawithlabels><code>fn withLabels(labels)</code></a></li> <li><a href=#fn-metadatawithlabelsmixin><code>fn withLabelsMixin(labels)</code></a></li> <li><a href=#fn-metadatawithname><code>fn withName(name)</code></a></li> <li><a href=#fn-metadatawithnamespace><code>fn withNamespace(namespace)</code></a></li> <li><a href=#fn-metadatawithownerreferences><code>fn withOwnerReferences(ownerReferences)</code></a></li> <li><a href=#fn-metadatawithownerreferencesmixin><code>fn withOwnerReferencesMixin(ownerReferences)</code></a></li> <li><a href=#fn-metadatawithresourceversion><code>fn withResourceVersion(resourceVersion)</code></a></li> <li><a href=#fn-metadatawithselflink><code>fn withSelfLink(selfLink)</code></a></li> <li><a href=#fn-metadatawithuid><code>fn withUid(uid)</code></a></li> <li><a href=#obj-spec><code>obj spec</code></a></li> <li><a href=#fn-specwithdescription><code>fn withDescription(description)</code></a></li> <li><a href=#fn-specwithegress><code>fn withEgress(egress)</code></a></li> <li><a href=#fn-specwithegressdeny><code>fn withEgressDeny(egressDeny)</code></a></li> <li><a href=#fn-specwithegressdenymixin><code>fn withEgressDenyMixin(egressDeny)</code></a></li> <li><a href=#fn-specwithegressmixin><code>fn withEgressMixin(egress)</code></a></li> <li><a href=#fn-specwithingress><code>fn withIngress(ingress)</code></a></li> <li><a href=#fn-specwithingressdeny><code>fn withIngressDeny(ingressDeny)</code></a></li> <li><a href=#fn-specwithingressdenymixin><code>fn withIngressDenyMixin(ingressDeny)</code></a></li> <li><a href=#fn-specwithingressmixin><code>fn withIngressMixin(ingress)</code></a></li> <li><a href=#fn-specwithlabels><code>fn withLabels(labels)</code></a></li> <li><a href=#fn-specwithlabelsmixin><code>fn withLabelsMixin(labels)</code></a></li> <li><a href=#obj-specegress><code>obj spec.egress</code></a><ul> <li><a href=#fn-specegresswithicmps><code>fn withIcmps(icmps)</code></a></li> <li><a href=#fn-specegresswithicmpsmixin><code>fn withIcmpsMixin(icmps)</code></a></li> <li><a href=#fn-specegresswithtocidr><code>fn withToCIDR(toCIDR)</code></a></li> <li><a href=#fn-specegresswithtocidrmixin><code>fn withToCIDRMixin(toCIDR)</code></a></li> <li><a href=#fn-specegresswithtocidrset><code>fn withToCIDRSet(toCIDRSet)</code></a></li> <li><a href=#fn-specegresswithtocidrsetmixin><code>fn withToCIDRSetMixin(toCIDRSet)</code></a></li> <li><a href=#fn-specegresswithtoendpoints><code>fn withToEndpoints(toEndpoints)</code></a></li> <li><a href=#fn-specegresswithtoendpointsmixin><code>fn withToEndpointsMixin(toEndpoints)</code></a></li> <li><a href=#fn-specegresswithtoentities><code>fn withToEntities(toEntities)</code></a></li> <li><a href=#fn-specegresswithtoentitiesmixin><code>fn withToEntitiesMixin(toEntities)</code></a></li> <li><a href=#fn-specegresswithtofqdns><code>fn withToFQDNs(toFQDNs)</code></a></li> <li><a href=#fn-specegresswithtofqdnsmixin><code>fn withToFQDNsMixin(toFQDNs)</code></a></li> <li><a href=#fn-specegresswithtogroups><code>fn withToGroups(toGroups)</code></a></li> <li><a href=#fn-specegresswithtogroupsmixin><code>fn withToGroupsMixin(toGroups)</code></a></li> <li><a href=#fn-specegresswithtoports><code>fn withToPorts(toPorts)</code></a></li> <li><a href=#fn-specegresswithtoportsmixin><code>fn withToPortsMixin(toPorts)</code></a></li> <li><a href=#fn-specegresswithtorequires><code>fn withToRequires(toRequires)</code></a></li> <li><a href=#fn-specegresswithtorequiresmixin><code>fn withToRequiresMixin(toRequires)</code></a></li> <li><a href=#fn-specegresswithtoservices><code>fn withToServices(toServices)</code></a></li> <li><a href=#fn-specegresswithtoservicesmixin><code>fn withToServicesMixin(toServices)</code></a></li> <li><a href=#obj-specegressicmps><code>obj spec.egress.icmps</code></a></li> <li><a href=#fn-specegressicmpswithfields><code>fn withFields(fields)</code></a></li> <li><a href=#fn-specegressicmpswithfieldsmixin><code>fn withFieldsMixin(fields)</code></a></li> <li><a href=#obj-specegressicmpsfields><code>obj spec.egress.icmps.fields</code></a><ul> <li><a href=#fn-specegressicmpsfieldswithfamily><code>fn withFamily(family)</code></a></li> <li><a href=#fn-specegressicmpsfieldswithtype><code>fn withType(type)</code></a></li> </ul> </li> <li><a href=#obj-specegresstocidrset><code>obj spec.egress.toCIDRSet</code></a></li> <li><a href=#fn-specegresstocidrsetwithcidr><code>fn withCidr(cidr)</code></a></li> <li><a href=#fn-specegresstocidrsetwithexcept><code>fn withExcept(except)</code></a></li> <li><a href=#fn-specegresstocidrsetwithexceptmixin><code>fn withExceptMixin(except)</code></a></li> <li><a href=#obj-specegresstoendpoints><code>obj spec.egress.toEndpoints</code></a></li> <li><a href=#fn-specegresstoendpointswithmatchexpressions><code>fn withMatchExpressions(matchExpressions)</code></a></li> <li><a href=#fn-specegresstoendpointswithmatchexpressionsmixin><code>fn withMatchExpressionsMixin(matchExpressions)</code></a></li> <li><a href=#fn-specegresstoendpointswithmatchlabels><code>fn withMatchLabels(matchLabels)</code></a></li> <li><a href=#fn-specegresstoendpointswithmatchlabelsmixin><code>fn withMatchLabelsMixin(matchLabels)</code></a></li> <li><a href=#obj-specegresstoendpointsmatchexpressions><code>obj spec.egress.toEndpoints.matchExpressions</code></a><ul> <li><a href=#fn-specegresstoendpointsmatchexpressionswithkey><code>fn withKey(key)</code></a></li> <li><a href=#fn-specegresstoendpointsmatchexpressionswithoperator><code>fn withOperator(operator)</code></a></li> <li><a href=#fn-specegresstoendpointsmatchexpressionswithvalues><code>fn withValues(values)</code></a></li> <li><a href=#fn-specegresstoendpointsmatchexpressionswithvaluesmixin><code>fn withValuesMixin(values)</code></a></li> </ul> </li> <li><a href=#obj-specegresstofqdns><code>obj spec.egress.toFQDNs</code></a></li> <li><a href=#fn-specegresstofqdnswithmatchname><code>fn withMatchName(matchName)</code></a></li> <li><a href=#fn-specegresstofqdnswithmatchpattern><code>fn withMatchPattern(matchPattern)</code></a></li> <li><a href=#obj-specegresstogroups><code>obj spec.egress.toGroups</code></a></li> <li><a href=#obj-specegresstogroupsaws><code>obj spec.egress.toGroups.aws</code></a><ul> <li><a href=#fn-specegresstogroupsawswithlabels><code>fn withLabels(labels)</code></a></li> <li><a href=#fn-specegresstogroupsawswithlabelsmixin><code>fn withLabelsMixin(labels)</code></a></li> <li><a href=#fn-specegresstogroupsawswithregion><code>fn withRegion(region)</code></a></li> <li><a href=#fn-specegresstogroupsawswithsecuritygroupsids><code>fn withSecurityGroupsIds(securityGroupsIds)</code></a></li> <li><a href=#fn-specegresstogroupsawswithsecuritygroupsidsmixin><code>fn withSecurityGroupsIdsMixin(securityGroupsIds)</code></a></li> <li><a href=#fn-specegresstogroupsawswithsecuritygroupsnames><code>fn withSecurityGroupsNames(securityGroupsNames)</code></a></li> <li><a href=#fn-specegresstogroupsawswithsecuritygroupsnamesmixin><code>fn withSecurityGroupsNamesMixin(securityGroupsNames)</code></a></li> </ul> </li> <li><a href=#obj-specegresstoports><code>obj spec.egress.toPorts</code></a></li> <li><a href=#fn-specegresstoportswithports><code>fn withPorts(ports)</code></a></li> <li><a href=#fn-specegresstoportswithportsmixin><code>fn withPortsMixin(ports)</code></a></li> <li><a href=#obj-specegresstoportsoriginatingtls><code>obj spec.egress.toPorts.originatingTLS</code></a><ul> <li><a href=#fn-specegresstoportsoriginatingtlswithcertificate><code>fn withCertificate(certificate)</code></a></li> <li><a href=#fn-specegresstoportsoriginatingtlswithprivatekey><code>fn withPrivateKey(privateKey)</code></a></li> <li><a href=#fn-specegresstoportsoriginatingtlswithtrustedca><code>fn withTrustedCA(trustedCA)</code></a></li> <li><a href=#obj-specegresstoportsoriginatingtlssecret><code>obj spec.egress.toPorts.originatingTLS.secret</code></a></li> <li><a href=#fn-specegresstoportsoriginatingtlssecretwithname><code>fn withName(name)</code></a></li> <li><a href=#fn-specegresstoportsoriginatingtlssecretwithnamespace><code>fn withNamespace(namespace)</code></a></li> </ul> </li> <li><a href=#obj-specegresstoportsports><code>obj spec.egress.toPorts.ports</code></a><ul> <li><a href=#fn-specegresstoportsportswithport><code>fn withPort(port)</code></a></li> <li><a href=#fn-specegresstoportsportswithprotocol><code>fn withProtocol(protocol)</code></a></li> </ul> </li> <li><a href=#obj-specegresstoportsrules><code>obj spec.egress.toPorts.rules</code></a><ul> <li><a href=#fn-specegresstoportsruleswithdns><code>fn withDns(dns)</code></a></li> <li><a href=#fn-specegresstoportsruleswithdnsmixin><code>fn withDnsMixin(dns)</code></a></li> <li><a href=#fn-specegresstoportsruleswithhttp><code>fn withHttp(http)</code></a></li> <li><a href=#fn-specegresstoportsruleswithhttpmixin><code>fn withHttpMixin(http)</code></a></li> <li><a href=#fn-specegresstoportsruleswithkafka><code>fn withKafka(kafka)</code></a></li> <li><a href=#fn-specegresstoportsruleswithkafkamixin><code>fn withKafkaMixin(kafka)</code></a></li> <li><a href=#fn-specegresstoportsruleswithl7><code>fn withL7(l7)</code></a></li> <li><a href=#fn-specegresstoportsruleswithl7mixin><code>fn withL7Mixin(l7)</code></a></li> <li><a href=#fn-specegresstoportsruleswithl7proto><code>fn withL7proto(l7proto)</code></a></li> <li><a href=#obj-specegresstoportsrulesdns><code>obj spec.egress.toPorts.rules.dns</code></a></li> <li><a href=#fn-specegresstoportsrulesdnswithmatchname><code>fn withMatchName(matchName)</code></a></li> <li><a href=#fn-specegresstoportsrulesdnswithmatchpattern><code>fn withMatchPattern(matchPattern)</code></a></li> <li><a href=#obj-specegresstoportsruleshttp><code>obj spec.egress.toPorts.rules.http</code></a></li> <li><a href=#fn-specegresstoportsruleshttpwithheadermatches><code>fn withHeaderMatches(headerMatches)</code></a></li> <li><a href=#fn-specegresstoportsruleshttpwithheadermatchesmixin><code>fn withHeaderMatchesMixin(headerMatches)</code></a></li> <li><a href=#fn-specegresstoportsruleshttpwithheaders><code>fn withHeaders(headers)</code></a></li> <li><a href=#fn-specegresstoportsruleshttpwithheadersmixin><code>fn withHeadersMixin(headers)</code></a></li> <li><a href=#fn-specegresstoportsruleshttpwithhost><code>fn withHost(host)</code></a></li> <li><a href=#fn-specegresstoportsruleshttpwithmethod><code>fn withMethod(method)</code></a></li> <li><a href=#fn-specegresstoportsruleshttpwithpath><code>fn withPath(path)</code></a></li> <li><a href=#obj-specegresstoportsruleshttpheadermatches><code>obj spec.egress.toPorts.rules.http.headerMatches</code></a><ul> <li><a href=#fn-specegresstoportsruleshttpheadermatcheswithmismatch><code>fn withMismatch(mismatch)</code></a></li> <li><a href=#fn-specegresstoportsruleshttpheadermatcheswithname><code>fn withName(name)</code></a></li> <li><a href=#fn-specegresstoportsruleshttpheadermatcheswithvalue><code>fn withValue(value)</code></a></li> <li><a href=#obj-specegresstoportsruleshttpheadermatchessecret><code>obj spec.egress.toPorts.rules.http.headerMatches.secret</code></a></li> <li><a href=#fn-specegresstoportsruleshttpheadermatchessecretwithname><code>fn withName(name)</code></a></li> <li><a href=#fn-specegresstoportsruleshttpheadermatchessecretwithnamespace><code>fn withNamespace(namespace)</code></a></li> </ul> </li> <li><a href=#obj-specegresstoportsruleskafka><code>obj spec.egress.toPorts.rules.kafka</code></a></li> <li><a href=#fn-specegresstoportsruleskafkawithapikey><code>fn withApiKey(apiKey)</code></a></li> <li><a href=#fn-specegresstoportsruleskafkawithapiversion><code>fn withApiVersion(apiVersion)</code></a></li> <li><a href=#fn-specegresstoportsruleskafkawithclientid><code>fn withClientID(clientID)</code></a></li> <li><a href=#fn-specegresstoportsruleskafkawithrole><code>fn withRole(role)</code></a></li> <li><a href=#fn-specegresstoportsruleskafkawithtopic><code>fn withTopic(topic)</code></a></li> </ul> </li> <li><a href=#obj-specegresstoportsterminatingtls><code>obj spec.egress.toPorts.terminatingTLS</code></a><ul> <li><a href=#fn-specegresstoportsterminatingtlswithcertificate><code>fn withCertificate(certificate)</code></a></li> <li><a href=#fn-specegresstoportsterminatingtlswithprivatekey><code>fn withPrivateKey(privateKey)</code></a></li> <li><a href=#fn-specegresstoportsterminatingtlswithtrustedca><code>fn withTrustedCA(trustedCA)</code></a></li> <li><a href=#obj-specegresstoportsterminatingtlssecret><code>obj spec.egress.toPorts.terminatingTLS.secret</code></a></li> <li><a href=#fn-specegresstoportsterminatingtlssecretwithname><code>fn withName(name)</code></a></li> <li><a href=#fn-specegresstoportsterminatingtlssecretwithnamespace><code>fn withNamespace(namespace)</code></a></li> </ul> </li> <li><a href=#obj-specegresstorequires><code>obj spec.egress.toRequires</code></a></li> <li><a href=#fn-specegresstorequireswithmatchexpressions><code>fn withMatchExpressions(matchExpressions)</code></a></li> <li><a href=#fn-specegresstorequireswithmatchexpressionsmixin><code>fn withMatchExpressionsMixin(matchExpressions)</code></a></li> <li><a href=#fn-specegresstorequireswithmatchlabels><code>fn withMatchLabels(matchLabels)</code></a></li> <li><a href=#fn-specegresstorequireswithmatchlabelsmixin><code>fn withMatchLabelsMixin(matchLabels)</code></a></li> <li><a href=#obj-specegresstorequiresmatchexpressions><code>obj spec.egress.toRequires.matchExpressions</code></a><ul> <li><a href=#fn-specegresstorequiresmatchexpressionswithkey><code>fn withKey(key)</code></a></li> <li><a href=#fn-specegresstorequiresmatchexpressionswithoperator><code>fn withOperator(operator)</code></a></li> <li><a href=#fn-specegresstorequiresmatchexpressionswithvalues><code>fn withValues(values)</code></a></li> <li><a href=#fn-specegresstorequiresmatchexpressionswithvaluesmixin><code>fn withValuesMixin(values)</code></a></li> </ul> </li> <li><a href=#obj-specegresstoservices><code>obj spec.egress.toServices</code></a></li> <li><a href=#obj-specegresstoservicesk8sservice><code>obj spec.egress.toServices.k8sService</code></a><ul> <li><a href=#fn-specegresstoservicesk8sservicewithnamespace><code>fn withNamespace(namespace)</code></a></li> <li><a href=#fn-specegresstoservicesk8sservicewithservicename><code>fn withServiceName(serviceName)</code></a></li> </ul> </li> <li><a href=#obj-specegresstoservicesk8sserviceselector><code>obj spec.egress.toServices.k8sServiceSelector</code></a><ul> <li><a href=#fn-specegresstoservicesk8sserviceselectorwithnamespace><code>fn withNamespace(namespace)</code></a></li> <li><a href=#obj-specegresstoservicesk8sserviceselectorselector><code>obj spec.egress.toServices.k8sServiceSelector.selector</code></a></li> <li><a href=#fn-specegresstoservicesk8sserviceselectorselectorwithmatchexpressions><code>fn withMatchExpressions(matchExpressions)</code></a></li> <li><a href=#fn-specegresstoservicesk8sserviceselectorselectorwithmatchexpressionsmixin><code>fn withMatchExpressionsMixin(matchExpressions)</code></a></li> <li><a href=#fn-specegresstoservicesk8sserviceselectorselectorwithmatchlabels><code>fn withMatchLabels(matchLabels)</code></a></li> <li><a href=#fn-specegresstoservicesk8sserviceselectorselectorwithmatchlabelsmixin><code>fn withMatchLabelsMixin(matchLabels)</code></a></li> <li><a href=#obj-specegresstoservicesk8sserviceselectorselectormatchexpressions><code>obj spec.egress.toServices.k8sServiceSelector.selector.matchExpressions</code></a><ul> <li><a href=#fn-specegresstoservicesk8sserviceselectorselectormatchexpressionswithkey><code>fn withKey(key)</code></a></li> <li><a href=#fn-specegresstoservicesk8sserviceselectorselectormatchexpressionswithoperator><code>fn withOperator(operator)</code></a></li> <li><a href=#fn-specegresstoservicesk8sserviceselectorselectormatchexpressionswithvalues><code>fn withValues(values)</code></a></li> <li><a href=#fn-specegresstoservicesk8sserviceselectorselectormatchexpressionswithvaluesmixin><code>fn withValuesMixin(values)</code></a></li> </ul> </li> </ul> </li> </ul> </li> <li><a href=#obj-specegressdeny><code>obj spec.egressDeny</code></a><ul> <li><a href=#fn-specegressdenywithicmps><code>fn withIcmps(icmps)</code></a></li> <li><a href=#fn-specegressdenywithicmpsmixin><code>fn withIcmpsMixin(icmps)</code></a></li> <li><a href=#fn-specegressdenywithtocidr><code>fn withToCIDR(toCIDR)</code></a></li> <li><a href=#fn-specegressdenywithtocidrmixin><code>fn withToCIDRMixin(toCIDR)</code></a></li> <li><a href=#fn-specegressdenywithtocidrset><code>fn withToCIDRSet(toCIDRSet)</code></a></li> <li><a href=#fn-specegressdenywithtocidrsetmixin><code>fn withToCIDRSetMixin(toCIDRSet)</code></a></li> <li><a href=#fn-specegressdenywithtoendpoints><code>fn withToEndpoints(toEndpoints)</code></a></li> <li><a href=#fn-specegressdenywithtoendpointsmixin><code>fn withToEndpointsMixin(toEndpoints)</code></a></li> <li><a href=#fn-specegressdenywithtoentities><code>fn withToEntities(toEntities)</code></a></li> <li><a href=#fn-specegressdenywithtoentitiesmixin><code>fn withToEntitiesMixin(toEntities)</code></a></li> <li><a href=#fn-specegressdenywithtogroups><code>fn withToGroups(toGroups)</code></a></li> <li><a href=#fn-specegressdenywithtogroupsmixin><code>fn withToGroupsMixin(toGroups)</code></a></li> <li><a href=#fn-specegressdenywithtoports><code>fn withToPorts(toPorts)</code></a></li> <li><a href=#fn-specegressdenywithtoportsmixin><code>fn withToPortsMixin(toPorts)</code></a></li> <li><a href=#fn-specegressdenywithtorequires><code>fn withToRequires(toRequires)</code></a></li> <li><a href=#fn-specegressdenywithtorequiresmixin><code>fn withToRequiresMixin(toRequires)</code></a></li> <li><a href=#fn-specegressdenywithtoservices><code>fn withToServices(toServices)</code></a></li> <li><a href=#fn-specegressdenywithtoservicesmixin><code>fn withToServicesMixin(toServices)</code></a></li> <li><a href=#obj-specegressdenyicmps><code>obj spec.egressDeny.icmps</code></a></li> <li><a href=#fn-specegressdenyicmpswithfields><code>fn withFields(fields)</code></a></li> <li><a href=#fn-specegressdenyicmpswithfieldsmixin><code>fn withFieldsMixin(fields)</code></a></li> <li><a href=#obj-specegressdenyicmpsfields><code>obj spec.egressDeny.icmps.fields</code></a><ul> <li><a href=#fn-specegressdenyicmpsfieldswithfamily><code>fn withFamily(family)</code></a></li> <li><a href=#fn-specegressdenyicmpsfieldswithtype><code>fn withType(type)</code></a></li> </ul> </li> <li><a href=#obj-specegressdenytocidrset><code>obj spec.egressDeny.toCIDRSet</code></a></li> <li><a href=#fn-specegressdenytocidrsetwithcidr><code>fn withCidr(cidr)</code></a></li> <li><a href=#fn-specegressdenytocidrsetwithexcept><code>fn withExcept(except)</code></a></li> <li><a href=#fn-specegressdenytocidrsetwithexceptmixin><code>fn withExceptMixin(except)</code></a></li> <li><a href=#obj-specegressdenytoendpoints><code>obj spec.egressDeny.toEndpoints</code></a></li> <li><a href=#fn-specegressdenytoendpointswithmatchexpressions><code>fn withMatchExpressions(matchExpressions)</code></a></li> <li><a href=#fn-specegressdenytoendpointswithmatchexpressionsmixin><code>fn withMatchExpressionsMixin(matchExpressions)</code></a></li> <li><a href=#fn-specegressdenytoendpointswithmatchlabels><code>fn withMatchLabels(matchLabels)</code></a></li> <li><a href=#fn-specegressdenytoendpointswithmatchlabelsmixin><code>fn withMatchLabelsMixin(matchLabels)</code></a></li> <li><a href=#obj-specegressdenytoendpointsmatchexpressions><code>obj spec.egressDeny.toEndpoints.matchExpressions</code></a><ul> <li><a href=#fn-specegressdenytoendpointsmatchexpressionswithkey><code>fn withKey(key)</code></a></li> <li><a href=#fn-specegressdenytoendpointsmatchexpressionswithoperator><code>fn withOperator(operator)</code></a></li> <li><a href=#fn-specegressdenytoendpointsmatchexpressionswithvalues><code>fn withValues(values)</code></a></li> <li><a href=#fn-specegressdenytoendpointsmatchexpressionswithvaluesmixin><code>fn withValuesMixin(values)</code></a></li> </ul> </li> <li><a href=#obj-specegressdenytogroups><code>obj spec.egressDeny.toGroups</code></a></li> <li><a href=#obj-specegressdenytogroupsaws><code>obj spec.egressDeny.toGroups.aws</code></a><ul> <li><a href=#fn-specegressdenytogroupsawswithlabels><code>fn withLabels(labels)</code></a></li> <li><a href=#fn-specegressdenytogroupsawswithlabelsmixin><code>fn withLabelsMixin(labels)</code></a></li> <li><a href=#fn-specegressdenytogroupsawswithregion><code>fn withRegion(region)</code></a></li> <li><a href=#fn-specegressdenytogroupsawswithsecuritygroupsids><code>fn withSecurityGroupsIds(securityGroupsIds)</code></a></li> <li><a href=#fn-specegressdenytogroupsawswithsecuritygroupsidsmixin><code>fn withSecurityGroupsIdsMixin(securityGroupsIds)</code></a></li> <li><a href=#fn-specegressdenytogroupsawswithsecuritygroupsnames><code>fn withSecurityGroupsNames(securityGroupsNames)</code></a></li> <li><a href=#fn-specegressdenytogroupsawswithsecuritygroupsnamesmixin><code>fn withSecurityGroupsNamesMixin(securityGroupsNames)</code></a></li> </ul> </li> <li><a href=#obj-specegressdenytoports><code>obj spec.egressDeny.toPorts</code></a></li> <li><a href=#fn-specegressdenytoportswithports><code>fn withPorts(ports)</code></a></li> <li><a href=#fn-specegressdenytoportswithportsmixin><code>fn withPortsMixin(ports)</code></a></li> <li><a href=#obj-specegressdenytoportsports><code>obj spec.egressDeny.toPorts.ports</code></a><ul> <li><a href=#fn-specegressdenytoportsportswithport><code>fn withPort(port)</code></a></li> <li><a href=#fn-specegressdenytoportsportswithprotocol><code>fn withProtocol(protocol)</code></a></li> </ul> </li> <li><a href=#obj-specegressdenytorequires><code>obj spec.egressDeny.toRequires</code></a></li> <li><a href=#fn-specegressdenytorequireswithmatchexpressions><code>fn withMatchExpressions(matchExpressions)</code></a></li> <li><a href=#fn-specegressdenytorequireswithmatchexpressionsmixin><code>fn withMatchExpressionsMixin(matchExpressions)</code></a></li> <li><a href=#fn-specegressdenytorequireswithmatchlabels><code>fn withMatchLabels(matchLabels)</code></a></li> <li><a href=#fn-specegressdenytorequireswithmatchlabelsmixin><code>fn withMatchLabelsMixin(matchLabels)</code></a></li> <li><a href=#obj-specegressdenytorequiresmatchexpressions><code>obj spec.egressDeny.toRequires.matchExpressions</code></a><ul> <li><a href=#fn-specegressdenytorequiresmatchexpressionswithkey><code>fn withKey(key)</code></a></li> <li><a href=#fn-specegressdenytorequiresmatchexpressionswithoperator><code>fn withOperator(operator)</code></a></li> <li><a href=#fn-specegressdenytorequiresmatchexpressionswithvalues><code>fn withValues(values)</code></a></li> <li><a href=#fn-specegressdenytorequiresmatchexpressionswithvaluesmixin><code>fn withValuesMixin(values)</code></a></li> </ul> </li> <li><a href=#obj-specegressdenytoservices><code>obj spec.egressDeny.toServices</code></a></li> <li><a href=#obj-specegressdenytoservicesk8sservice><code>obj spec.egressDeny.toServices.k8sService</code></a><ul> <li><a href=#fn-specegressdenytoservicesk8sservicewithnamespace><code>fn withNamespace(namespace)</code></a></li> <li><a href=#fn-specegressdenytoservicesk8sservicewithservicename><code>fn withServiceName(serviceName)</code></a></li> </ul> </li> <li><a href=#obj-specegressdenytoservicesk8sserviceselector><code>obj spec.egressDeny.toServices.k8sServiceSelector</code></a><ul> <li><a href=#fn-specegressdenytoservicesk8sserviceselectorwithnamespace><code>fn withNamespace(namespace)</code></a></li> <li><a href=#obj-specegressdenytoservicesk8sserviceselectorselector><code>obj spec.egressDeny.toServices.k8sServiceSelector.selector</code></a></li> <li><a href=#fn-specegressdenytoservicesk8sserviceselectorselectorwithmatchexpressions><code>fn withMatchExpressions(matchExpressions)</code></a></li> <li><a href=#fn-specegressdenytoservicesk8sserviceselectorselectorwithmatchexpressionsmixin><code>fn withMatchExpressionsMixin(matchExpressions)</code></a></li> <li><a href=#fn-specegressdenytoservicesk8sserviceselectorselectorwithmatchlabels><code>fn withMatchLabels(matchLabels)</code></a></li> <li><a href=#fn-specegressdenytoservicesk8sserviceselectorselectorwithmatchlabelsmixin><code>fn withMatchLabelsMixin(matchLabels)</code></a></li> <li><a href=#obj-specegressdenytoservicesk8sserviceselectorselectormatchexpressions><code>obj spec.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions</code></a><ul> <li><a href=#fn-specegressdenytoservicesk8sserviceselectorselectormatchexpressionswithkey><code>fn withKey(key)</code></a></li> <li><a href=#fn-specegressdenytoservicesk8sserviceselectorselectormatchexpressionswithoperator><code>fn withOperator(operator)</code></a></li> <li><a href=#fn-specegressdenytoservicesk8sserviceselectorselectormatchexpressionswithvalues><code>fn withValues(values)</code></a></li> <li><a href=#fn-specegressdenytoservicesk8sserviceselectorselectormatchexpressionswithvaluesmixin><code>fn withValuesMixin(values)</code></a></li> </ul> </li> </ul> </li> </ul> </li> <li><a href=#obj-specendpointselector><code>obj spec.endpointSelector</code></a><ul> <li><a href=#fn-specendpointselectorwithmatchexpressions><code>fn withMatchExpressions(matchExpressions)</code></a></li> <li><a href=#fn-specendpointselectorwithmatchexpressionsmixin><code>fn withMatchExpressionsMixin(matchExpressions)</code></a></li> <li><a href=#fn-specendpointselectorwithmatchlabels><code>fn withMatchLabels(matchLabels)</code></a></li> <li><a href=#fn-specendpointselectorwithmatchlabelsmixin><code>fn withMatchLabelsMixin(matchLabels)</code></a></li> <li><a href=#obj-specendpointselectormatchexpressions><code>obj spec.endpointSelector.matchExpressions</code></a></li> <li><a href=#fn-specendpointselectormatchexpressionswithkey><code>fn withKey(key)</code></a></li> <li><a href=#fn-specendpointselectormatchexpressionswithoperator><code>fn withOperator(operator)</code></a></li> <li><a href=#fn-specendpointselectormatchexpressionswithvalues><code>fn withValues(values)</code></a></li> <li><a href=#fn-specendpointselectormatchexpressionswithvaluesmixin><code>fn withValuesMixin(values)</code></a></li> </ul> </li> <li><a href=#obj-specingress><code>obj spec.ingress</code></a><ul> <li><a href=#fn-specingresswithfromcidr><code>fn withFromCIDR(fromCIDR)</code></a></li> <li><a href=#fn-specingresswithfromcidrmixin><code>fn withFromCIDRMixin(fromCIDR)</code></a></li> <li><a href=#fn-specingresswithfromcidrset><code>fn withFromCIDRSet(fromCIDRSet)</code></a></li> <li><a href=#fn-specingresswithfromcidrsetmixin><code>fn withFromCIDRSetMixin(fromCIDRSet)</code></a></li> <li><a href=#fn-specingresswithfromendpoints><code>fn withFromEndpoints(fromEndpoints)</code></a></li> <li><a href=#fn-specingresswithfromendpointsmixin><code>fn withFromEndpointsMixin(fromEndpoints)</code></a></li> <li><a href=#fn-specingresswithfromentities><code>fn withFromEntities(fromEntities)</code></a></li> <li><a href=#fn-specingresswithfromentitiesmixin><code>fn withFromEntitiesMixin(fromEntities)</code></a></li> <li><a href=#fn-specingresswithfromrequires><code>fn withFromRequires(fromRequires)</code></a></li> <li><a href=#fn-specingresswithfromrequiresmixin><code>fn withFromRequiresMixin(fromRequires)</code></a></li> <li><a href=#fn-specingresswithicmps><code>fn withIcmps(icmps)</code></a></li> <li><a href=#fn-specingresswithicmpsmixin><code>fn withIcmpsMixin(icmps)</code></a></li> <li><a href=#fn-specingresswithtoports><code>fn withToPorts(toPorts)</code></a></li> <li><a href=#fn-specingresswithtoportsmixin><code>fn withToPortsMixin(toPorts)</code></a></li> <li><a href=#obj-specingressfromcidrset><code>obj spec.ingress.fromCIDRSet</code></a></li> <li><a href=#fn-specingressfromcidrsetwithcidr><code>fn withCidr(cidr)</code></a></li> <li><a href=#fn-specingressfromcidrsetwithexcept><code>fn withExcept(except)</code></a></li> <li><a href=#fn-specingressfromcidrsetwithexceptmixin><code>fn withExceptMixin(except)</code></a></li> <li><a href=#obj-specingressfromendpoints><code>obj spec.ingress.fromEndpoints</code></a></li> <li><a href=#fn-specingressfromendpointswithmatchexpressions><code>fn withMatchExpressions(matchExpressions)</code></a></li> <li><a href=#fn-specingressfromendpointswithmatchexpressionsmixin><code>fn withMatchExpressionsMixin(matchExpressions)</code></a></li> <li><a href=#fn-specingressfromendpointswithmatchlabels><code>fn withMatchLabels(matchLabels)</code></a></li> <li><a href=#fn-specingressfromendpointswithmatchlabelsmixin><code>fn withMatchLabelsMixin(matchLabels)</code></a></li> <li><a href=#obj-specingressfromendpointsmatchexpressions><code>obj spec.ingress.fromEndpoints.matchExpressions</code></a><ul> <li><a href=#fn-specingressfromendpointsmatchexpressionswithkey><code>fn withKey(key)</code></a></li> <li><a href=#fn-specingressfromendpointsmatchexpressionswithoperator><code>fn withOperator(operator)</code></a></li> <li><a href=#fn-specingressfromendpointsmatchexpressionswithvalues><code>fn withValues(values)</code></a></li> <li><a href=#fn-specingressfromendpointsmatchexpressionswithvaluesmixin><code>fn withValuesMixin(values)</code></a></li> </ul> </li> <li><a href=#obj-specingressfromrequires><code>obj spec.ingress.fromRequires</code></a></li> <li><a href=#fn-specingressfromrequireswithmatchexpressions><code>fn withMatchExpressions(matchExpressions)</code></a></li> <li><a href=#fn-specingressfromrequireswithmatchexpressionsmixin><code>fn withMatchExpressionsMixin(matchExpressions)</code></a></li> <li><a href=#fn-specingressfromrequireswithmatchlabels><code>fn withMatchLabels(matchLabels)</code></a></li> <li><a href=#fn-specingressfromrequireswithmatchlabelsmixin><code>fn withMatchLabelsMixin(matchLabels)</code></a></li> <li><a href=#obj-specingressfromrequiresmatchexpressions><code>obj spec.ingress.fromRequires.matchExpressions</code></a><ul> <li><a href=#fn-specingressfromrequiresmatchexpressionswithkey><code>fn withKey(key)</code></a></li> <li><a href=#fn-specingressfromrequiresmatchexpressionswithoperator><code>fn withOperator(operator)</code></a></li> <li><a href=#fn-specingressfromrequiresmatchexpressionswithvalues><code>fn withValues(values)</code></a></li> <li><a href=#fn-specingressfromrequiresmatchexpressionswithvaluesmixin><code>fn withValuesMixin(values)</code></a></li> </ul> </li> <li><a href=#obj-specingressicmps><code>obj spec.ingress.icmps</code></a></li> <li><a href=#fn-specingressicmpswithfields><code>fn withFields(fields)</code></a></li> <li><a href=#fn-specingressicmpswithfieldsmixin><code>fn withFieldsMixin(fields)</code></a></li> <li><a href=#obj-specingressicmpsfields><code>obj spec.ingress.icmps.fields</code></a><ul> <li><a href=#fn-specingressicmpsfieldswithfamily><code>fn withFamily(family)</code></a></li> <li><a href=#fn-specingressicmpsfieldswithtype><code>fn withType(type)</code></a></li> </ul> </li> <li><a href=#obj-specingresstoports><code>obj spec.ingress.toPorts</code></a></li> <li><a href=#fn-specingresstoportswithports><code>fn withPorts(ports)</code></a></li> <li><a href=#fn-specingresstoportswithportsmixin><code>fn withPortsMixin(ports)</code></a></li> <li><a href=#obj-specingresstoportsoriginatingtls><code>obj spec.ingress.toPorts.originatingTLS</code></a><ul> <li><a href=#fn-specingresstoportsoriginatingtlswithcertificate><code>fn withCertificate(certificate)</code></a></li> <li><a href=#fn-specingresstoportsoriginatingtlswithprivatekey><code>fn withPrivateKey(privateKey)</code></a></li> <li><a href=#fn-specingresstoportsoriginatingtlswithtrustedca><code>fn withTrustedCA(trustedCA)</code></a></li> <li><a href=#obj-specingresstoportsoriginatingtlssecret><code>obj spec.ingress.toPorts.originatingTLS.secret</code></a></li> <li><a href=#fn-specingresstoportsoriginatingtlssecretwithname><code>fn withName(name)</code></a></li> <li><a href=#fn-specingresstoportsoriginatingtlssecretwithnamespace><code>fn withNamespace(namespace)</code></a></li> </ul> </li> <li><a href=#obj-specingresstoportsports><code>obj spec.ingress.toPorts.ports</code></a><ul> <li><a href=#fn-specingresstoportsportswithport><code>fn withPort(port)</code></a></li> <li><a href=#fn-specingresstoportsportswithprotocol><code>fn withProtocol(protocol)</code></a></li> </ul> </li> <li><a href=#obj-specingresstoportsrules><code>obj spec.ingress.toPorts.rules</code></a><ul> <li><a href=#fn-specingresstoportsruleswithdns><code>fn withDns(dns)</code></a></li> <li><a href=#fn-specingresstoportsruleswithdnsmixin><code>fn withDnsMixin(dns)</code></a></li> <li><a href=#fn-specingresstoportsruleswithhttp><code>fn withHttp(http)</code></a></li> <li><a href=#fn-specingresstoportsruleswithhttpmixin><code>fn withHttpMixin(http)</code></a></li> <li><a href=#fn-specingresstoportsruleswithkafka><code>fn withKafka(kafka)</code></a></li> <li><a href=#fn-specingresstoportsruleswithkafkamixin><code>fn withKafkaMixin(kafka)</code></a></li> <li><a href=#fn-specingresstoportsruleswithl7><code>fn withL7(l7)</code></a></li> <li><a href=#fn-specingresstoportsruleswithl7mixin><code>fn withL7Mixin(l7)</code></a></li> <li><a href=#fn-specingresstoportsruleswithl7proto><code>fn withL7proto(l7proto)</code></a></li> <li><a href=#obj-specingresstoportsrulesdns><code>obj spec.ingress.toPorts.rules.dns</code></a></li> <li><a href=#fn-specingresstoportsrulesdnswithmatchname><code>fn withMatchName(matchName)</code></a></li> <li><a href=#fn-specingresstoportsrulesdnswithmatchpattern><code>fn withMatchPattern(matchPattern)</code></a></li> <li><a href=#obj-specingresstoportsruleshttp><code>obj spec.ingress.toPorts.rules.http</code></a></li> <li><a href=#fn-specingresstoportsruleshttpwithheadermatches><code>fn withHeaderMatches(headerMatches)</code></a></li> <li><a href=#fn-specingresstoportsruleshttpwithheadermatchesmixin><code>fn withHeaderMatchesMixin(headerMatches)</code></a></li> <li><a href=#fn-specingresstoportsruleshttpwithheaders><code>fn withHeaders(headers)</code></a></li> <li><a href=#fn-specingresstoportsruleshttpwithheadersmixin><code>fn withHeadersMixin(headers)</code></a></li> <li><a href=#fn-specingresstoportsruleshttpwithhost><code>fn withHost(host)</code></a></li> <li><a href=#fn-specingresstoportsruleshttpwithmethod><code>fn withMethod(method)</code></a></li> <li><a href=#fn-specingresstoportsruleshttpwithpath><code>fn withPath(path)</code></a></li> <li><a href=#obj-specingresstoportsruleshttpheadermatches><code>obj spec.ingress.toPorts.rules.http.headerMatches</code></a><ul> <li><a href=#fn-specingresstoportsruleshttpheadermatcheswithmismatch><code>fn withMismatch(mismatch)</code></a></li> <li><a href=#fn-specingresstoportsruleshttpheadermatcheswithname><code>fn withName(name)</code></a></li> <li><a href=#fn-specingresstoportsruleshttpheadermatcheswithvalue><code>fn withValue(value)</code></a></li> <li><a href=#obj-specingresstoportsruleshttpheadermatchessecret><code>obj spec.ingress.toPorts.rules.http.headerMatches.secret</code></a></li> <li><a href=#fn-specingresstoportsruleshttpheadermatchessecretwithname><code>fn withName(name)</code></a></li> <li><a href=#fn-specingresstoportsruleshttpheadermatchessecretwithnamespace><code>fn withNamespace(namespace)</code></a></li> </ul> </li> <li><a href=#obj-specingresstoportsruleskafka><code>obj spec.ingress.toPorts.rules.kafka</code></a></li> <li><a href=#fn-specingresstoportsruleskafkawithapikey><code>fn withApiKey(apiKey)</code></a></li> <li><a href=#fn-specingresstoportsruleskafkawithapiversion><code>fn withApiVersion(apiVersion)</code></a></li> <li><a href=#fn-specingresstoportsruleskafkawithclientid><code>fn withClientID(clientID)</code></a></li> <li><a href=#fn-specingresstoportsruleskafkawithrole><code>fn withRole(role)</code></a></li> <li><a href=#fn-specingresstoportsruleskafkawithtopic><code>fn withTopic(topic)</code></a></li> </ul> </li> <li><a href=#obj-specingresstoportsterminatingtls><code>obj spec.ingress.toPorts.terminatingTLS</code></a><ul> <li><a href=#fn-specingresstoportsterminatingtlswithcertificate><code>fn withCertificate(certificate)</code></a></li> <li><a href=#fn-specingresstoportsterminatingtlswithprivatekey><code>fn withPrivateKey(privateKey)</code></a></li> <li><a href=#fn-specingresstoportsterminatingtlswithtrustedca><code>fn withTrustedCA(trustedCA)</code></a></li> <li><a href=#obj-specingresstoportsterminatingtlssecret><code>obj spec.ingress.toPorts.terminatingTLS.secret</code></a></li> <li><a href=#fn-specingresstoportsterminatingtlssecretwithname><code>fn withName(name)</code></a></li> <li><a href=#fn-specingresstoportsterminatingtlssecretwithnamespace><code>fn withNamespace(namespace)</code></a></li> </ul> </li> </ul> </li> <li><a href=#obj-specingressdeny><code>obj spec.ingressDeny</code></a><ul> <li><a href=#fn-specingressdenywithfromcidr><code>fn withFromCIDR(fromCIDR)</code></a></li> <li><a href=#fn-specingressdenywithfromcidrmixin><code>fn withFromCIDRMixin(fromCIDR)</code></a></li> <li><a href=#fn-specingressdenywithfromcidrset><code>fn withFromCIDRSet(fromCIDRSet)</code></a></li> <li><a href=#fn-specingressdenywithfromcidrsetmixin><code>fn withFromCIDRSetMixin(fromCIDRSet)</code></a></li> <li><a href=#fn-specingressdenywithfromendpoints><code>fn withFromEndpoints(fromEndpoints)</code></a></li> <li><a href=#fn-specingressdenywithfromendpointsmixin><code>fn withFromEndpointsMixin(fromEndpoints)</code></a></li> <li><a href=#fn-specingressdenywithfromentities><code>fn withFromEntities(fromEntities)</code></a></li> <li><a href=#fn-specingressdenywithfromentitiesmixin><code>fn withFromEntitiesMixin(fromEntities)</code></a></li> <li><a href=#fn-specingressdenywithfromrequires><code>fn withFromRequires(fromRequires)</code></a></li> <li><a href=#fn-specingressdenywithfromrequiresmixin><code>fn withFromRequiresMixin(fromRequires)</code></a></li> <li><a href=#fn-specingressdenywithicmps><code>fn withIcmps(icmps)</code></a></li> <li><a href=#fn-specingressdenywithicmpsmixin><code>fn withIcmpsMixin(icmps)</code></a></li> <li><a href=#fn-specingressdenywithtoports><code>fn withToPorts(toPorts)</code></a></li> <li><a href=#fn-specingressdenywithtoportsmixin><code>fn withToPortsMixin(toPorts)</code></a></li> <li><a href=#obj-specingressdenyfromcidrset><code>obj spec.ingressDeny.fromCIDRSet</code></a></li> <li><a href=#fn-specingressdenyfromcidrsetwithcidr><code>fn withCidr(cidr)</code></a></li> <li><a href=#fn-specingressdenyfromcidrsetwithexcept><code>fn withExcept(except)</code></a></li> <li><a href=#fn-specingressdenyfromcidrsetwithexceptmixin><code>fn withExceptMixin(except)</code></a></li> <li><a href=#obj-specingressdenyfromendpoints><code>obj spec.ingressDeny.fromEndpoints</code></a></li> <li><a href=#fn-specingressdenyfromendpointswithmatchexpressions><code>fn withMatchExpressions(matchExpressions)</code></a></li> <li><a href=#fn-specingressdenyfromendpointswithmatchexpressionsmixin><code>fn withMatchExpressionsMixin(matchExpressions)</code></a></li> <li><a href=#fn-specingressdenyfromendpointswithmatchlabels><code>fn withMatchLabels(matchLabels)</code></a></li> <li><a href=#fn-specingressdenyfromendpointswithmatchlabelsmixin><code>fn withMatchLabelsMixin(matchLabels)</code></a></li> <li><a href=#obj-specingressdenyfromendpointsmatchexpressions><code>obj spec.ingressDeny.fromEndpoints.matchExpressions</code></a><ul> <li><a href=#fn-specingressdenyfromendpointsmatchexpressionswithkey><code>fn withKey(key)</code></a></li> <li><a href=#fn-specingressdenyfromendpointsmatchexpressionswithoperator><code>fn withOperator(operator)</code></a></li> <li><a href=#fn-specingressdenyfromendpointsmatchexpressionswithvalues><code>fn withValues(values)</code></a></li> <li><a href=#fn-specingressdenyfromendpointsmatchexpressionswithvaluesmixin><code>fn withValuesMixin(values)</code></a></li> </ul> </li> <li><a href=#obj-specingressdenyfromrequires><code>obj spec.ingressDeny.fromRequires</code></a></li> <li><a href=#fn-specingressdenyfromrequireswithmatchexpressions><code>fn withMatchExpressions(matchExpressions)</code></a></li> <li><a href=#fn-specingressdenyfromrequireswithmatchexpressionsmixin><code>fn withMatchExpressionsMixin(matchExpressions)</code></a></li> <li><a href=#fn-specingressdenyfromrequireswithmatchlabels><code>fn withMatchLabels(matchLabels)</code></a></li> <li><a href=#fn-specingressdenyfromrequireswithmatchlabelsmixin><code>fn withMatchLabelsMixin(matchLabels)</code></a></li> <li><a href=#obj-specingressdenyfromrequiresmatchexpressions><code>obj spec.ingressDeny.fromRequires.matchExpressions</code></a><ul> <li><a href=#fn-specingressdenyfromrequiresmatchexpressionswithkey><code>fn withKey(key)</code></a></li> <li><a href=#fn-specingressdenyfromrequiresmatchexpressionswithoperator><code>fn withOperator(operator)</code></a></li> <li><a href=#fn-specingressdenyfromrequiresmatchexpressionswithvalues><code>fn withValues(values)</code></a></li> <li><a href=#fn-specingressdenyfromrequiresmatchexpressionswithvaluesmixin><code>fn withValuesMixin(values)</code></a></li> </ul> </li> <li><a href=#obj-specingressdenyicmps><code>obj spec.ingressDeny.icmps</code></a></li> <li><a href=#fn-specingressdenyicmpswithfields><code>fn withFields(fields)</code></a></li> <li><a href=#fn-specingressdenyicmpswithfieldsmixin><code>fn withFieldsMixin(fields)</code></a></li> <li><a href=#obj-specingressdenyicmpsfields><code>obj spec.ingressDeny.icmps.fields</code></a><ul> <li><a href=#fn-specingressdenyicmpsfieldswithfamily><code>fn withFamily(family)</code></a></li> <li><a href=#fn-specingressdenyicmpsfieldswithtype><code>fn withType(type)</code></a></li> </ul> </li> <li><a href=#obj-specingressdenytoports><code>obj spec.ingressDeny.toPorts</code></a></li> <li><a href=#fn-specingressdenytoportswithports><code>fn withPorts(ports)</code></a></li> <li><a href=#fn-specingressdenytoportswithportsmixin><code>fn withPortsMixin(ports)</code></a></li> <li><a href=#obj-specingressdenytoportsports><code>obj spec.ingressDeny.toPorts.ports</code></a><ul> <li><a href=#fn-specingressdenytoportsportswithport><code>fn withPort(port)</code></a></li> <li><a href=#fn-specingressdenytoportsportswithprotocol><code>fn withProtocol(protocol)</code></a></li> </ul> </li> </ul> </li> <li><a href=#obj-speclabels><code>obj spec.labels</code></a><ul> <li><a href=#fn-speclabelswithkey><code>fn withKey(key)</code></a></li> <li><a href=#fn-speclabelswithsource><code>fn withSource(source)</code></a></li> <li><a href=#fn-speclabelswithvalue><code>fn withValue(value)</code></a></li> </ul> </li> <li><a href=#obj-specnodeselector><code>obj spec.nodeSelector</code></a><ul> <li><a href=#fn-specnodeselectorwithmatchexpressions><code>fn withMatchExpressions(matchExpressions)</code></a></li> <li><a href=#fn-specnodeselectorwithmatchexpressionsmixin><code>fn withMatchExpressionsMixin(matchExpressions)</code></a></li> <li><a href=#fn-specnodeselectorwithmatchlabels><code>fn withMatchLabels(matchLabels)</code></a></li> <li><a href=#fn-specnodeselectorwithmatchlabelsmixin><code>fn withMatchLabelsMixin(matchLabels)</code></a></li> <li><a href=#obj-specnodeselectormatchexpressions><code>obj spec.nodeSelector.matchExpressions</code></a></li> <li><a href=#fn-specnodeselectormatchexpressionswithkey><code>fn withKey(key)</code></a></li> <li><a href=#fn-specnodeselectormatchexpressionswithoperator><code>fn withOperator(operator)</code></a></li> <li><a href=#fn-specnodeselectormatchexpressionswithvalues><code>fn withValues(values)</code></a></li> <li><a href=#fn-specnodeselectormatchexpressionswithvaluesmixin><code>fn withValuesMixin(values)</code></a></li> </ul> </li> <li><a href=#obj-specs><code>obj specs</code></a></li> <li><a href=#fn-specswithdescription><code>fn withDescription(description)</code></a></li> <li><a href=#fn-specswithegress><code>fn withEgress(egress)</code></a></li> <li><a href=#fn-specswithegressdeny><code>fn withEgressDeny(egressDeny)</code></a></li> <li><a href=#fn-specswithegressdenymixin><code>fn withEgressDenyMixin(egressDeny)</code></a></li> <li><a href=#fn-specswithegressmixin><code>fn withEgressMixin(egress)</code></a></li> <li><a href=#fn-specswithingress><code>fn withIngress(ingress)</code></a></li> <li><a href=#fn-specswithingressdeny><code>fn withIngressDeny(ingressDeny)</code></a></li> <li><a href=#fn-specswithingressdenymixin><code>fn withIngressDenyMixin(ingressDeny)</code></a></li> <li><a href=#fn-specswithingressmixin><code>fn withIngressMixin(ingress)</code></a></li> <li><a href=#fn-specswithlabels><code>fn withLabels(labels)</code></a></li> <li><a href=#fn-specswithlabelsmixin><code>fn withLabelsMixin(labels)</code></a></li> <li><a href=#obj-specsegress><code>obj specs.egress</code></a><ul> <li><a href=#fn-specsegresswithicmps><code>fn withIcmps(icmps)</code></a></li> <li><a href=#fn-specsegresswithicmpsmixin><code>fn withIcmpsMixin(icmps)</code></a></li> <li><a href=#fn-specsegresswithtocidr><code>fn withToCIDR(toCIDR)</code></a></li> <li><a href=#fn-specsegresswithtocidrmixin><code>fn withToCIDRMixin(toCIDR)</code></a></li> <li><a href=#fn-specsegresswithtocidrset><code>fn withToCIDRSet(toCIDRSet)</code></a></li> <li><a href=#fn-specsegresswithtocidrsetmixin><code>fn withToCIDRSetMixin(toCIDRSet)</code></a></li> <li><a href=#fn-specsegresswithtoendpoints><code>fn withToEndpoints(toEndpoints)</code></a></li> <li><a href=#fn-specsegresswithtoendpointsmixin><code>fn withToEndpointsMixin(toEndpoints)</code></a></li> <li><a href=#fn-specsegresswithtoentities><code>fn withToEntities(toEntities)</code></a></li> <li><a href=#fn-specsegresswithtoentitiesmixin><code>fn withToEntitiesMixin(toEntities)</code></a></li> <li><a href=#fn-specsegresswithtofqdns><code>fn withToFQDNs(toFQDNs)</code></a></li> <li><a href=#fn-specsegresswithtofqdnsmixin><code>fn withToFQDNsMixin(toFQDNs)</code></a></li> <li><a href=#fn-specsegresswithtogroups><code>fn withToGroups(toGroups)</code></a></li> <li><a href=#fn-specsegresswithtogroupsmixin><code>fn withToGroupsMixin(toGroups)</code></a></li> <li><a href=#fn-specsegresswithtoports><code>fn withToPorts(toPorts)</code></a></li> <li><a href=#fn-specsegresswithtoportsmixin><code>fn withToPortsMixin(toPorts)</code></a></li> <li><a href=#fn-specsegresswithtorequires><code>fn withToRequires(toRequires)</code></a></li> <li><a href=#fn-specsegresswithtorequiresmixin><code>fn withToRequiresMixin(toRequires)</code></a></li> <li><a href=#fn-specsegresswithtoservices><code>fn withToServices(toServices)</code></a></li> <li><a href=#fn-specsegresswithtoservicesmixin><code>fn withToServicesMixin(toServices)</code></a></li> <li><a href=#obj-specsegressicmps><code>obj specs.egress.icmps</code></a></li> <li><a href=#fn-specsegressicmpswithfields><code>fn withFields(fields)</code></a></li> <li><a href=#fn-specsegressicmpswithfieldsmixin><code>fn withFieldsMixin(fields)</code></a></li> <li><a href=#obj-specsegressicmpsfields><code>obj specs.egress.icmps.fields</code></a><ul> <li><a href=#fn-specsegressicmpsfieldswithfamily><code>fn withFamily(family)</code></a></li> <li><a href=#fn-specsegressicmpsfieldswithtype><code>fn withType(type)</code></a></li> </ul> </li> <li><a href=#obj-specsegresstocidrset><code>obj specs.egress.toCIDRSet</code></a></li> <li><a href=#fn-specsegresstocidrsetwithcidr><code>fn withCidr(cidr)</code></a></li> <li><a href=#fn-specsegresstocidrsetwithexcept><code>fn withExcept(except)</code></a></li> <li><a href=#fn-specsegresstocidrsetwithexceptmixin><code>fn withExceptMixin(except)</code></a></li> <li><a href=#obj-specsegresstoendpoints><code>obj specs.egress.toEndpoints</code></a></li> <li><a href=#fn-specsegresstoendpointswithmatchexpressions><code>fn withMatchExpressions(matchExpressions)</code></a></li> <li><a href=#fn-specsegresstoendpointswithmatchexpressionsmixin><code>fn withMatchExpressionsMixin(matchExpressions)</code></a></li> <li><a href=#fn-specsegresstoendpointswithmatchlabels><code>fn withMatchLabels(matchLabels)</code></a></li> <li><a href=#fn-specsegresstoendpointswithmatchlabelsmixin><code>fn withMatchLabelsMixin(matchLabels)</code></a></li> <li><a href=#obj-specsegresstoendpointsmatchexpressions><code>obj specs.egress.toEndpoints.matchExpressions</code></a><ul> <li><a href=#fn-specsegresstoendpointsmatchexpressionswithkey><code>fn withKey(key)</code></a></li> <li><a href=#fn-specsegresstoendpointsmatchexpressionswithoperator><code>fn withOperator(operator)</code></a></li> <li><a href=#fn-specsegresstoendpointsmatchexpressionswithvalues><code>fn withValues(values)</code></a></li> <li><a href=#fn-specsegresstoendpointsmatchexpressionswithvaluesmixin><code>fn withValuesMixin(values)</code></a></li> </ul> </li> <li><a href=#obj-specsegresstofqdns><code>obj specs.egress.toFQDNs</code></a></li> <li><a href=#fn-specsegresstofqdnswithmatchname><code>fn withMatchName(matchName)</code></a></li> <li><a href=#fn-specsegresstofqdnswithmatchpattern><code>fn withMatchPattern(matchPattern)</code></a></li> <li><a href=#obj-specsegresstogroups><code>obj specs.egress.toGroups</code></a></li> <li><a href=#obj-specsegresstogroupsaws><code>obj specs.egress.toGroups.aws</code></a><ul> <li><a href=#fn-specsegresstogroupsawswithlabels><code>fn withLabels(labels)</code></a></li> <li><a href=#fn-specsegresstogroupsawswithlabelsmixin><code>fn withLabelsMixin(labels)</code></a></li> <li><a href=#fn-specsegresstogroupsawswithregion><code>fn withRegion(region)</code></a></li> <li><a href=#fn-specsegresstogroupsawswithsecuritygroupsids><code>fn withSecurityGroupsIds(securityGroupsIds)</code></a></li> <li><a href=#fn-specsegresstogroupsawswithsecuritygroupsidsmixin><code>fn withSecurityGroupsIdsMixin(securityGroupsIds)</code></a></li> <li><a href=#fn-specsegresstogroupsawswithsecuritygroupsnames><code>fn withSecurityGroupsNames(securityGroupsNames)</code></a></li> <li><a href=#fn-specsegresstogroupsawswithsecuritygroupsnamesmixin><code>fn withSecurityGroupsNamesMixin(securityGroupsNames)</code></a></li> </ul> </li> <li><a href=#obj-specsegresstoports><code>obj specs.egress.toPorts</code></a></li> <li><a href=#fn-specsegresstoportswithports><code>fn withPorts(ports)</code></a></li> <li><a href=#fn-specsegresstoportswithportsmixin><code>fn withPortsMixin(ports)</code></a></li> <li><a href=#obj-specsegresstoportsoriginatingtls><code>obj specs.egress.toPorts.originatingTLS</code></a><ul> <li><a href=#fn-specsegresstoportsoriginatingtlswithcertificate><code>fn withCertificate(certificate)</code></a></li> <li><a href=#fn-specsegresstoportsoriginatingtlswithprivatekey><code>fn withPrivateKey(privateKey)</code></a></li> <li><a href=#fn-specsegresstoportsoriginatingtlswithtrustedca><code>fn withTrustedCA(trustedCA)</code></a></li> <li><a href=#obj-specsegresstoportsoriginatingtlssecret><code>obj specs.egress.toPorts.originatingTLS.secret</code></a></li> <li><a href=#fn-specsegresstoportsoriginatingtlssecretwithname><code>fn withName(name)</code></a></li> <li><a href=#fn-specsegresstoportsoriginatingtlssecretwithnamespace><code>fn withNamespace(namespace)</code></a></li> </ul> </li> <li><a href=#obj-specsegresstoportsports><code>obj specs.egress.toPorts.ports</code></a><ul> <li><a href=#fn-specsegresstoportsportswithport><code>fn withPort(port)</code></a></li> <li><a href=#fn-specsegresstoportsportswithprotocol><code>fn withProtocol(protocol)</code></a></li> </ul> </li> <li><a href=#obj-specsegresstoportsrules><code>obj specs.egress.toPorts.rules</code></a><ul> <li><a href=#fn-specsegresstoportsruleswithdns><code>fn withDns(dns)</code></a></li> <li><a href=#fn-specsegresstoportsruleswithdnsmixin><code>fn withDnsMixin(dns)</code></a></li> <li><a href=#fn-specsegresstoportsruleswithhttp><code>fn withHttp(http)</code></a></li> <li><a href=#fn-specsegresstoportsruleswithhttpmixin><code>fn withHttpMixin(http)</code></a></li> <li><a href=#fn-specsegresstoportsruleswithkafka><code>fn withKafka(kafka)</code></a></li> <li><a href=#fn-specsegresstoportsruleswithkafkamixin><code>fn withKafkaMixin(kafka)</code></a></li> <li><a href=#fn-specsegresstoportsruleswithl7><code>fn withL7(l7)</code></a></li> <li><a href=#fn-specsegresstoportsruleswithl7mixin><code>fn withL7Mixin(l7)</code></a></li> <li><a href=#fn-specsegresstoportsruleswithl7proto><code>fn withL7proto(l7proto)</code></a></li> <li><a href=#obj-specsegresstoportsrulesdns><code>obj specs.egress.toPorts.rules.dns</code></a></li> <li><a href=#fn-specsegresstoportsrulesdnswithmatchname><code>fn withMatchName(matchName)</code></a></li> <li><a href=#fn-specsegresstoportsrulesdnswithmatchpattern><code>fn withMatchPattern(matchPattern)</code></a></li> <li><a href=#obj-specsegresstoportsruleshttp><code>obj specs.egress.toPorts.rules.http</code></a></li> <li><a href=#fn-specsegresstoportsruleshttpwithheadermatches><code>fn withHeaderMatches(headerMatches)</code></a></li> <li><a href=#fn-specsegresstoportsruleshttpwithheadermatchesmixin><code>fn withHeaderMatchesMixin(headerMatches)</code></a></li> <li><a href=#fn-specsegresstoportsruleshttpwithheaders><code>fn withHeaders(headers)</code></a></li> <li><a href=#fn-specsegresstoportsruleshttpwithheadersmixin><code>fn withHeadersMixin(headers)</code></a></li> <li><a href=#fn-specsegresstoportsruleshttpwithhost><code>fn withHost(host)</code></a></li> <li><a href=#fn-specsegresstoportsruleshttpwithmethod><code>fn withMethod(method)</code></a></li> <li><a href=#fn-specsegresstoportsruleshttpwithpath><code>fn withPath(path)</code></a></li> <li><a href=#obj-specsegresstoportsruleshttpheadermatches><code>obj specs.egress.toPorts.rules.http.headerMatches</code></a><ul> <li><a href=#fn-specsegresstoportsruleshttpheadermatcheswithmismatch><code>fn withMismatch(mismatch)</code></a></li> <li><a href=#fn-specsegresstoportsruleshttpheadermatcheswithname><code>fn withName(name)</code></a></li> <li><a href=#fn-specsegresstoportsruleshttpheadermatcheswithvalue><code>fn withValue(value)</code></a></li> <li><a href=#obj-specsegresstoportsruleshttpheadermatchessecret><code>obj specs.egress.toPorts.rules.http.headerMatches.secret</code></a></li> <li><a href=#fn-specsegresstoportsruleshttpheadermatchessecretwithname><code>fn withName(name)</code></a></li> <li><a href=#fn-specsegresstoportsruleshttpheadermatchessecretwithnamespace><code>fn withNamespace(namespace)</code></a></li> </ul> </li> <li><a href=#obj-specsegresstoportsruleskafka><code>obj specs.egress.toPorts.rules.kafka</code></a></li> <li><a href=#fn-specsegresstoportsruleskafkawithapikey><code>fn withApiKey(apiKey)</code></a></li> <li><a href=#fn-specsegresstoportsruleskafkawithapiversion><code>fn withApiVersion(apiVersion)</code></a></li> <li><a href=#fn-specsegresstoportsruleskafkawithclientid><code>fn withClientID(clientID)</code></a></li> <li><a href=#fn-specsegresstoportsruleskafkawithrole><code>fn withRole(role)</code></a></li> <li><a href=#fn-specsegresstoportsruleskafkawithtopic><code>fn withTopic(topic)</code></a></li> </ul> </li> <li><a href=#obj-specsegresstoportsterminatingtls><code>obj specs.egress.toPorts.terminatingTLS</code></a><ul> <li><a href=#fn-specsegresstoportsterminatingtlswithcertificate><code>fn withCertificate(certificate)</code></a></li> <li><a href=#fn-specsegresstoportsterminatingtlswithprivatekey><code>fn withPrivateKey(privateKey)</code></a></li> <li><a href=#fn-specsegresstoportsterminatingtlswithtrustedca><code>fn withTrustedCA(trustedCA)</code></a></li> <li><a href=#obj-specsegresstoportsterminatingtlssecret><code>obj specs.egress.toPorts.terminatingTLS.secret</code></a></li> <li><a href=#fn-specsegresstoportsterminatingtlssecretwithname><code>fn withName(name)</code></a></li> <li><a href=#fn-specsegresstoportsterminatingtlssecretwithnamespace><code>fn withNamespace(namespace)</code></a></li> </ul> </li> <li><a href=#obj-specsegresstorequires><code>obj specs.egress.toRequires</code></a></li> <li><a href=#fn-specsegresstorequireswithmatchexpressions><code>fn withMatchExpressions(matchExpressions)</code></a></li> <li><a href=#fn-specsegresstorequireswithmatchexpressionsmixin><code>fn withMatchExpressionsMixin(matchExpressions)</code></a></li> <li><a href=#fn-specsegresstorequireswithmatchlabels><code>fn withMatchLabels(matchLabels)</code></a></li> <li><a href=#fn-specsegresstorequireswithmatchlabelsmixin><code>fn withMatchLabelsMixin(matchLabels)</code></a></li> <li><a href=#obj-specsegresstorequiresmatchexpressions><code>obj specs.egress.toRequires.matchExpressions</code></a><ul> <li><a href=#fn-specsegresstorequiresmatchexpressionswithkey><code>fn withKey(key)</code></a></li> <li><a href=#fn-specsegresstorequiresmatchexpressionswithoperator><code>fn withOperator(operator)</code></a></li> <li><a href=#fn-specsegresstorequiresmatchexpressionswithvalues><code>fn withValues(values)</code></a></li> <li><a href=#fn-specsegresstorequiresmatchexpressionswithvaluesmixin><code>fn withValuesMixin(values)</code></a></li> </ul> </li> <li><a href=#obj-specsegresstoservices><code>obj specs.egress.toServices</code></a></li> <li><a href=#obj-specsegresstoservicesk8sservice><code>obj specs.egress.toServices.k8sService</code></a><ul> <li><a href=#fn-specsegresstoservicesk8sservicewithnamespace><code>fn withNamespace(namespace)</code></a></li> <li><a href=#fn-specsegresstoservicesk8sservicewithservicename><code>fn withServiceName(serviceName)</code></a></li> </ul> </li> <li><a href=#obj-specsegresstoservicesk8sserviceselector><code>obj specs.egress.toServices.k8sServiceSelector</code></a><ul> <li><a href=#fn-specsegresstoservicesk8sserviceselectorwithnamespace><code>fn withNamespace(namespace)</code></a></li> <li><a href=#obj-specsegresstoservicesk8sserviceselectorselector><code>obj specs.egress.toServices.k8sServiceSelector.selector</code></a></li> <li><a href=#fn-specsegresstoservicesk8sserviceselectorselectorwithmatchexpressions><code>fn withMatchExpressions(matchExpressions)</code></a></li> <li><a href=#fn-specsegresstoservicesk8sserviceselectorselectorwithmatchexpressionsmixin><code>fn withMatchExpressionsMixin(matchExpressions)</code></a></li> <li><a href=#fn-specsegresstoservicesk8sserviceselectorselectorwithmatchlabels><code>fn withMatchLabels(matchLabels)</code></a></li> <li><a href=#fn-specsegresstoservicesk8sserviceselectorselectorwithmatchlabelsmixin><code>fn withMatchLabelsMixin(matchLabels)</code></a></li> <li><a href=#obj-specsegresstoservicesk8sserviceselectorselectormatchexpressions><code>obj specs.egress.toServices.k8sServiceSelector.selector.matchExpressions</code></a><ul> <li><a href=#fn-specsegresstoservicesk8sserviceselectorselectormatchexpressionswithkey><code>fn withKey(key)</code></a></li> <li><a href=#fn-specsegresstoservicesk8sserviceselectorselectormatchexpressionswithoperator><code>fn withOperator(operator)</code></a></li> <li><a href=#fn-specsegresstoservicesk8sserviceselectorselectormatchexpressionswithvalues><code>fn withValues(values)</code></a></li> <li><a href=#fn-specsegresstoservicesk8sserviceselectorselectormatchexpressionswithvaluesmixin><code>fn withValuesMixin(values)</code></a></li> </ul> </li> </ul> </li> </ul> </li> <li><a href=#obj-specsegressdeny><code>obj specs.egressDeny</code></a><ul> <li><a href=#fn-specsegressdenywithicmps><code>fn withIcmps(icmps)</code></a></li> <li><a href=#fn-specsegressdenywithicmpsmixin><code>fn withIcmpsMixin(icmps)</code></a></li> <li><a href=#fn-specsegressdenywithtocidr><code>fn withToCIDR(toCIDR)</code></a></li> <li><a href=#fn-specsegressdenywithtocidrmixin><code>fn withToCIDRMixin(toCIDR)</code></a></li> <li><a href=#fn-specsegressdenywithtocidrset><code>fn withToCIDRSet(toCIDRSet)</code></a></li> <li><a href=#fn-specsegressdenywithtocidrsetmixin><code>fn withToCIDRSetMixin(toCIDRSet)</code></a></li> <li><a href=#fn-specsegressdenywithtoendpoints><code>fn withToEndpoints(toEndpoints)</code></a></li> <li><a href=#fn-specsegressdenywithtoendpointsmixin><code>fn withToEndpointsMixin(toEndpoints)</code></a></li> <li><a href=#fn-specsegressdenywithtoentities><code>fn withToEntities(toEntities)</code></a></li> <li><a href=#fn-specsegressdenywithtoentitiesmixin><code>fn withToEntitiesMixin(toEntities)</code></a></li> <li><a href=#fn-specsegressdenywithtogroups><code>fn withToGroups(toGroups)</code></a></li> <li><a href=#fn-specsegressdenywithtogroupsmixin><code>fn withToGroupsMixin(toGroups)</code></a></li> <li><a href=#fn-specsegressdenywithtoports><code>fn withToPorts(toPorts)</code></a></li> <li><a href=#fn-specsegressdenywithtoportsmixin><code>fn withToPortsMixin(toPorts)</code></a></li> <li><a href=#fn-specsegressdenywithtorequires><code>fn withToRequires(toRequires)</code></a></li> <li><a href=#fn-specsegressdenywithtorequiresmixin><code>fn withToRequiresMixin(toRequires)</code></a></li> <li><a href=#fn-specsegressdenywithtoservices><code>fn withToServices(toServices)</code></a></li> <li><a href=#fn-specsegressdenywithtoservicesmixin><code>fn withToServicesMixin(toServices)</code></a></li> <li><a href=#obj-specsegressdenyicmps><code>obj specs.egressDeny.icmps</code></a></li> <li><a href=#fn-specsegressdenyicmpswithfields><code>fn withFields(fields)</code></a></li> <li><a href=#fn-specsegressdenyicmpswithfieldsmixin><code>fn withFieldsMixin(fields)</code></a></li> <li><a href=#obj-specsegressdenyicmpsfields><code>obj specs.egressDeny.icmps.fields</code></a><ul> <li><a href=#fn-specsegressdenyicmpsfieldswithfamily><code>fn withFamily(family)</code></a></li> <li><a href=#fn-specsegressdenyicmpsfieldswithtype><code>fn withType(type)</code></a></li> </ul> </li> <li><a href=#obj-specsegressdenytocidrset><code>obj specs.egressDeny.toCIDRSet</code></a></li> <li><a href=#fn-specsegressdenytocidrsetwithcidr><code>fn withCidr(cidr)</code></a></li> <li><a href=#fn-specsegressdenytocidrsetwithexcept><code>fn withExcept(except)</code></a></li> <li><a href=#fn-specsegressdenytocidrsetwithexceptmixin><code>fn withExceptMixin(except)</code></a></li> <li><a href=#obj-specsegressdenytoendpoints><code>obj specs.egressDeny.toEndpoints</code></a></li> <li><a href=#fn-specsegressdenytoendpointswithmatchexpressions><code>fn withMatchExpressions(matchExpressions)</code></a></li> <li><a href=#fn-specsegressdenytoendpointswithmatchexpressionsmixin><code>fn withMatchExpressionsMixin(matchExpressions)</code></a></li> <li><a href=#fn-specsegressdenytoendpointswithmatchlabels><code>fn withMatchLabels(matchLabels)</code></a></li> <li><a href=#fn-specsegressdenytoendpointswithmatchlabelsmixin><code>fn withMatchLabelsMixin(matchLabels)</code></a></li> <li><a href=#obj-specsegressdenytoendpointsmatchexpressions><code>obj specs.egressDeny.toEndpoints.matchExpressions</code></a><ul> <li><a href=#fn-specsegressdenytoendpointsmatchexpressionswithkey><code>fn withKey(key)</code></a></li> <li><a href=#fn-specsegressdenytoendpointsmatchexpressionswithoperator><code>fn withOperator(operator)</code></a></li> <li><a href=#fn-specsegressdenytoendpointsmatchexpressionswithvalues><code>fn withValues(values)</code></a></li> <li><a href=#fn-specsegressdenytoendpointsmatchexpressionswithvaluesmixin><code>fn withValuesMixin(values)</code></a></li> </ul> </li> <li><a href=#obj-specsegressdenytogroups><code>obj specs.egressDeny.toGroups</code></a></li> <li><a href=#obj-specsegressdenytogroupsaws><code>obj specs.egressDeny.toGroups.aws</code></a><ul> <li><a href=#fn-specsegressdenytogroupsawswithlabels><code>fn withLabels(labels)</code></a></li> <li><a href=#fn-specsegressdenytogroupsawswithlabelsmixin><code>fn withLabelsMixin(labels)</code></a></li> <li><a href=#fn-specsegressdenytogroupsawswithregion><code>fn withRegion(region)</code></a></li> <li><a href=#fn-specsegressdenytogroupsawswithsecuritygroupsids><code>fn withSecurityGroupsIds(securityGroupsIds)</code></a></li> <li><a href=#fn-specsegressdenytogroupsawswithsecuritygroupsidsmixin><code>fn withSecurityGroupsIdsMixin(securityGroupsIds)</code></a></li> <li><a href=#fn-specsegressdenytogroupsawswithsecuritygroupsnames><code>fn withSecurityGroupsNames(securityGroupsNames)</code></a></li> <li><a href=#fn-specsegressdenytogroupsawswithsecuritygroupsnamesmixin><code>fn withSecurityGroupsNamesMixin(securityGroupsNames)</code></a></li> </ul> </li> <li><a href=#obj-specsegressdenytoports><code>obj specs.egressDeny.toPorts</code></a></li> <li><a href=#fn-specsegressdenytoportswithports><code>fn withPorts(ports)</code></a></li> <li><a href=#fn-specsegressdenytoportswithportsmixin><code>fn withPortsMixin(ports)</code></a></li> <li><a href=#obj-specsegressdenytoportsports><code>obj specs.egressDeny.toPorts.ports</code></a><ul> <li><a href=#fn-specsegressdenytoportsportswithport><code>fn withPort(port)</code></a></li> <li><a href=#fn-specsegressdenytoportsportswithprotocol><code>fn withProtocol(protocol)</code></a></li> </ul> </li> <li><a href=#obj-specsegressdenytorequires><code>obj specs.egressDeny.toRequires</code></a></li> <li><a href=#fn-specsegressdenytorequireswithmatchexpressions><code>fn withMatchExpressions(matchExpressions)</code></a></li> <li><a href=#fn-specsegressdenytorequireswithmatchexpressionsmixin><code>fn withMatchExpressionsMixin(matchExpressions)</code></a></li> <li><a href=#fn-specsegressdenytorequireswithmatchlabels><code>fn withMatchLabels(matchLabels)</code></a></li> <li><a href=#fn-specsegressdenytorequireswithmatchlabelsmixin><code>fn withMatchLabelsMixin(matchLabels)</code></a></li> <li><a href=#obj-specsegressdenytorequiresmatchexpressions><code>obj specs.egressDeny.toRequires.matchExpressions</code></a><ul> <li><a href=#fn-specsegressdenytorequiresmatchexpressionswithkey><code>fn withKey(key)</code></a></li> <li><a href=#fn-specsegressdenytorequiresmatchexpressionswithoperator><code>fn withOperator(operator)</code></a></li> <li><a href=#fn-specsegressdenytorequiresmatchexpressionswithvalues><code>fn withValues(values)</code></a></li> <li><a href=#fn-specsegressdenytorequiresmatchexpressionswithvaluesmixin><code>fn withValuesMixin(values)</code></a></li> </ul> </li> <li><a href=#obj-specsegressdenytoservices><code>obj specs.egressDeny.toServices</code></a></li> <li><a href=#obj-specsegressdenytoservicesk8sservice><code>obj specs.egressDeny.toServices.k8sService</code></a><ul> <li><a href=#fn-specsegressdenytoservicesk8sservicewithnamespace><code>fn withNamespace(namespace)</code></a></li> <li><a href=#fn-specsegressdenytoservicesk8sservicewithservicename><code>fn withServiceName(serviceName)</code></a></li> </ul> </li> <li><a href=#obj-specsegressdenytoservicesk8sserviceselector><code>obj specs.egressDeny.toServices.k8sServiceSelector</code></a><ul> <li><a href=#fn-specsegressdenytoservicesk8sserviceselectorwithnamespace><code>fn withNamespace(namespace)</code></a></li> <li><a href=#obj-specsegressdenytoservicesk8sserviceselectorselector><code>obj specs.egressDeny.toServices.k8sServiceSelector.selector</code></a></li> <li><a href=#fn-specsegressdenytoservicesk8sserviceselectorselectorwithmatchexpressions><code>fn withMatchExpressions(matchExpressions)</code></a></li> <li><a href=#fn-specsegressdenytoservicesk8sserviceselectorselectorwithmatchexpressionsmixin><code>fn withMatchExpressionsMixin(matchExpressions)</code></a></li> <li><a href=#fn-specsegressdenytoservicesk8sserviceselectorselectorwithmatchlabels><code>fn withMatchLabels(matchLabels)</code></a></li> <li><a href=#fn-specsegressdenytoservicesk8sserviceselectorselectorwithmatchlabelsmixin><code>fn withMatchLabelsMixin(matchLabels)</code></a></li> <li><a href=#obj-specsegressdenytoservicesk8sserviceselectorselectormatchexpressions><code>obj specs.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions</code></a><ul> <li><a href=#fn-specsegressdenytoservicesk8sserviceselectorselectormatchexpressionswithkey><code>fn withKey(key)</code></a></li> <li><a href=#fn-specsegressdenytoservicesk8sserviceselectorselectormatchexpressionswithoperator><code>fn withOperator(operator)</code></a></li> <li><a href=#fn-specsegressdenytoservicesk8sserviceselectorselectormatchexpressionswithvalues><code>fn withValues(values)</code></a></li> <li><a href=#fn-specsegressdenytoservicesk8sserviceselectorselectormatchexpressionswithvaluesmixin><code>fn withValuesMixin(values)</code></a></li> </ul> </li> </ul> </li> </ul> </li> <li><a href=#obj-specsendpointselector><code>obj specs.endpointSelector</code></a><ul> <li><a href=#fn-specsendpointselectorwithmatchexpressions><code>fn withMatchExpressions(matchExpressions)</code></a></li> <li><a href=#fn-specsendpointselectorwithmatchexpressionsmixin><code>fn withMatchExpressionsMixin(matchExpressions)</code></a></li> <li><a href=#fn-specsendpointselectorwithmatchlabels><code>fn withMatchLabels(matchLabels)</code></a></li> <li><a href=#fn-specsendpointselectorwithmatchlabelsmixin><code>fn withMatchLabelsMixin(matchLabels)</code></a></li> <li><a href=#obj-specsendpointselectormatchexpressions><code>obj specs.endpointSelector.matchExpressions</code></a></li> <li><a href=#fn-specsendpointselectormatchexpressionswithkey><code>fn withKey(key)</code></a></li> <li><a href=#fn-specsendpointselectormatchexpressionswithoperator><code>fn withOperator(operator)</code></a></li> <li><a href=#fn-specsendpointselectormatchexpressionswithvalues><code>fn withValues(values)</code></a></li> <li><a href=#fn-specsendpointselectormatchexpressionswithvaluesmixin><code>fn withValuesMixin(values)</code></a></li> </ul> </li> <li><a href=#obj-specsingress><code>obj specs.ingress</code></a><ul> <li><a href=#fn-specsingresswithfromcidr><code>fn withFromCIDR(fromCIDR)</code></a></li> <li><a href=#fn-specsingresswithfromcidrmixin><code>fn withFromCIDRMixin(fromCIDR)</code></a></li> <li><a href=#fn-specsingresswithfromcidrset><code>fn withFromCIDRSet(fromCIDRSet)</code></a></li> <li><a href=#fn-specsingresswithfromcidrsetmixin><code>fn withFromCIDRSetMixin(fromCIDRSet)</code></a></li> <li><a href=#fn-specsingresswithfromendpoints><code>fn withFromEndpoints(fromEndpoints)</code></a></li> <li><a href=#fn-specsingresswithfromendpointsmixin><code>fn withFromEndpointsMixin(fromEndpoints)</code></a></li> <li><a href=#fn-specsingresswithfromentities><code>fn withFromEntities(fromEntities)</code></a></li> <li><a href=#fn-specsingresswithfromentitiesmixin><code>fn withFromEntitiesMixin(fromEntities)</code></a></li> <li><a href=#fn-specsingresswithfromrequires><code>fn withFromRequires(fromRequires)</code></a></li> <li><a href=#fn-specsingresswithfromrequiresmixin><code>fn withFromRequiresMixin(fromRequires)</code></a></li> <li><a href=#fn-specsingresswithicmps><code>fn withIcmps(icmps)</code></a></li> <li><a href=#fn-specsingresswithicmpsmixin><code>fn withIcmpsMixin(icmps)</code></a></li> <li><a href=#fn-specsingresswithtoports><code>fn withToPorts(toPorts)</code></a></li> <li><a href=#fn-specsingresswithtoportsmixin><code>fn withToPortsMixin(toPorts)</code></a></li> <li><a href=#obj-specsingressfromcidrset><code>obj specs.ingress.fromCIDRSet</code></a></li> <li><a href=#fn-specsingressfromcidrsetwithcidr><code>fn withCidr(cidr)</code></a></li> <li><a href=#fn-specsingressfromcidrsetwithexcept><code>fn withExcept(except)</code></a></li> <li><a href=#fn-specsingressfromcidrsetwithexceptmixin><code>fn withExceptMixin(except)</code></a></li> <li><a href=#obj-specsingressfromendpoints><code>obj specs.ingress.fromEndpoints</code></a></li> <li><a href=#fn-specsingressfromendpointswithmatchexpressions><code>fn withMatchExpressions(matchExpressions)</code></a></li> <li><a href=#fn-specsingressfromendpointswithmatchexpressionsmixin><code>fn withMatchExpressionsMixin(matchExpressions)</code></a></li> <li><a href=#fn-specsingressfromendpointswithmatchlabels><code>fn withMatchLabels(matchLabels)</code></a></li> <li><a href=#fn-specsingressfromendpointswithmatchlabelsmixin><code>fn withMatchLabelsMixin(matchLabels)</code></a></li> <li><a href=#obj-specsingressfromendpointsmatchexpressions><code>obj specs.ingress.fromEndpoints.matchExpressions</code></a><ul> <li><a href=#fn-specsingressfromendpointsmatchexpressionswithkey><code>fn withKey(key)</code></a></li> <li><a href=#fn-specsingressfromendpointsmatchexpressionswithoperator><code>fn withOperator(operator)</code></a></li> <li><a href=#fn-specsingressfromendpointsmatchexpressionswithvalues><code>fn withValues(values)</code></a></li> <li><a href=#fn-specsingressfromendpointsmatchexpressionswithvaluesmixin><code>fn withValuesMixin(values)</code></a></li> </ul> </li> <li><a href=#obj-specsingressfromrequires><code>obj specs.ingress.fromRequires</code></a></li> <li><a href=#fn-specsingressfromrequireswithmatchexpressions><code>fn withMatchExpressions(matchExpressions)</code></a></li> <li><a href=#fn-specsingressfromrequireswithmatchexpressionsmixin><code>fn withMatchExpressionsMixin(matchExpressions)</code></a></li> <li><a href=#fn-specsingressfromrequireswithmatchlabels><code>fn withMatchLabels(matchLabels)</code></a></li> <li><a href=#fn-specsingressfromrequireswithmatchlabelsmixin><code>fn withMatchLabelsMixin(matchLabels)</code></a></li> <li><a href=#obj-specsingressfromrequiresmatchexpressions><code>obj specs.ingress.fromRequires.matchExpressions</code></a><ul> <li><a href=#fn-specsingressfromrequiresmatchexpressionswithkey><code>fn withKey(key)</code></a></li> <li><a href=#fn-specsingressfromrequiresmatchexpressionswithoperator><code>fn withOperator(operator)</code></a></li> <li><a href=#fn-specsingressfromrequiresmatchexpressionswithvalues><code>fn withValues(values)</code></a></li> <li><a href=#fn-specsingressfromrequiresmatchexpressionswithvaluesmixin><code>fn withValuesMixin(values)</code></a></li> </ul> </li> <li><a href=#obj-specsingressicmps><code>obj specs.ingress.icmps</code></a></li> <li><a href=#fn-specsingressicmpswithfields><code>fn withFields(fields)</code></a></li> <li><a href=#fn-specsingressicmpswithfieldsmixin><code>fn withFieldsMixin(fields)</code></a></li> <li><a href=#obj-specsingressicmpsfields><code>obj specs.ingress.icmps.fields</code></a><ul> <li><a href=#fn-specsingressicmpsfieldswithfamily><code>fn withFamily(family)</code></a></li> <li><a href=#fn-specsingressicmpsfieldswithtype><code>fn withType(type)</code></a></li> </ul> </li> <li><a href=#obj-specsingresstoports><code>obj specs.ingress.toPorts</code></a></li> <li><a href=#fn-specsingresstoportswithports><code>fn withPorts(ports)</code></a></li> <li><a href=#fn-specsingresstoportswithportsmixin><code>fn withPortsMixin(ports)</code></a></li> <li><a href=#obj-specsingresstoportsoriginatingtls><code>obj specs.ingress.toPorts.originatingTLS</code></a><ul> <li><a href=#fn-specsingresstoportsoriginatingtlswithcertificate><code>fn withCertificate(certificate)</code></a></li> <li><a href=#fn-specsingresstoportsoriginatingtlswithprivatekey><code>fn withPrivateKey(privateKey)</code></a></li> <li><a href=#fn-specsingresstoportsoriginatingtlswithtrustedca><code>fn withTrustedCA(trustedCA)</code></a></li> <li><a href=#obj-specsingresstoportsoriginatingtlssecret><code>obj specs.ingress.toPorts.originatingTLS.secret</code></a></li> <li><a href=#fn-specsingresstoportsoriginatingtlssecretwithname><code>fn withName(name)</code></a></li> <li><a href=#fn-specsingresstoportsoriginatingtlssecretwithnamespace><code>fn withNamespace(namespace)</code></a></li> </ul> </li> <li><a href=#obj-specsingresstoportsports><code>obj specs.ingress.toPorts.ports</code></a><ul> <li><a href=#fn-specsingresstoportsportswithport><code>fn withPort(port)</code></a></li> <li><a href=#fn-specsingresstoportsportswithprotocol><code>fn withProtocol(protocol)</code></a></li> </ul> </li> <li><a href=#obj-specsingresstoportsrules><code>obj specs.ingress.toPorts.rules</code></a><ul> <li><a href=#fn-specsingresstoportsruleswithdns><code>fn withDns(dns)</code></a></li> <li><a href=#fn-specsingresstoportsruleswithdnsmixin><code>fn withDnsMixin(dns)</code></a></li> <li><a href=#fn-specsingresstoportsruleswithhttp><code>fn withHttp(http)</code></a></li> <li><a href=#fn-specsingresstoportsruleswithhttpmixin><code>fn withHttpMixin(http)</code></a></li> <li><a href=#fn-specsingresstoportsruleswithkafka><code>fn withKafka(kafka)</code></a></li> <li><a href=#fn-specsingresstoportsruleswithkafkamixin><code>fn withKafkaMixin(kafka)</code></a></li> <li><a href=#fn-specsingresstoportsruleswithl7><code>fn withL7(l7)</code></a></li> <li><a href=#fn-specsingresstoportsruleswithl7mixin><code>fn withL7Mixin(l7)</code></a></li> <li><a href=#fn-specsingresstoportsruleswithl7proto><code>fn withL7proto(l7proto)</code></a></li> <li><a href=#obj-specsingresstoportsrulesdns><code>obj specs.ingress.toPorts.rules.dns</code></a></li> <li><a href=#fn-specsingresstoportsrulesdnswithmatchname><code>fn withMatchName(matchName)</code></a></li> <li><a href=#fn-specsingresstoportsrulesdnswithmatchpattern><code>fn withMatchPattern(matchPattern)</code></a></li> <li><a href=#obj-specsingresstoportsruleshttp><code>obj specs.ingress.toPorts.rules.http</code></a></li> <li><a href=#fn-specsingresstoportsruleshttpwithheadermatches><code>fn withHeaderMatches(headerMatches)</code></a></li> <li><a href=#fn-specsingresstoportsruleshttpwithheadermatchesmixin><code>fn withHeaderMatchesMixin(headerMatches)</code></a></li> <li><a href=#fn-specsingresstoportsruleshttpwithheaders><code>fn withHeaders(headers)</code></a></li> <li><a href=#fn-specsingresstoportsruleshttpwithheadersmixin><code>fn withHeadersMixin(headers)</code></a></li> <li><a href=#fn-specsingresstoportsruleshttpwithhost><code>fn withHost(host)</code></a></li> <li><a href=#fn-specsingresstoportsruleshttpwithmethod><code>fn withMethod(method)</code></a></li> <li><a href=#fn-specsingresstoportsruleshttpwithpath><code>fn withPath(path)</code></a></li> <li><a href=#obj-specsingresstoportsruleshttpheadermatches><code>obj specs.ingress.toPorts.rules.http.headerMatches</code></a><ul> <li><a href=#fn-specsingresstoportsruleshttpheadermatcheswithmismatch><code>fn withMismatch(mismatch)</code></a></li> <li><a href=#fn-specsingresstoportsruleshttpheadermatcheswithname><code>fn withName(name)</code></a></li> <li><a href=#fn-specsingresstoportsruleshttpheadermatcheswithvalue><code>fn withValue(value)</code></a></li> <li><a href=#obj-specsingresstoportsruleshttpheadermatchessecret><code>obj specs.ingress.toPorts.rules.http.headerMatches.secret</code></a></li> <li><a href=#fn-specsingresstoportsruleshttpheadermatchessecretwithname><code>fn withName(name)</code></a></li> <li><a href=#fn-specsingresstoportsruleshttpheadermatchessecretwithnamespace><code>fn withNamespace(namespace)</code></a></li> </ul> </li> <li><a href=#obj-specsingresstoportsruleskafka><code>obj specs.ingress.toPorts.rules.kafka</code></a></li> <li><a href=#fn-specsingresstoportsruleskafkawithapikey><code>fn withApiKey(apiKey)</code></a></li> <li><a href=#fn-specsingresstoportsruleskafkawithapiversion><code>fn withApiVersion(apiVersion)</code></a></li> <li><a href=#fn-specsingresstoportsruleskafkawithclientid><code>fn withClientID(clientID)</code></a></li> <li><a href=#fn-specsingresstoportsruleskafkawithrole><code>fn withRole(role)</code></a></li> <li><a href=#fn-specsingresstoportsruleskafkawithtopic><code>fn withTopic(topic)</code></a></li> </ul> </li> <li><a href=#obj-specsingresstoportsterminatingtls><code>obj specs.ingress.toPorts.terminatingTLS</code></a><ul> <li><a href=#fn-specsingresstoportsterminatingtlswithcertificate><code>fn withCertificate(certificate)</code></a></li> <li><a href=#fn-specsingresstoportsterminatingtlswithprivatekey><code>fn withPrivateKey(privateKey)</code></a></li> <li><a href=#fn-specsingresstoportsterminatingtlswithtrustedca><code>fn withTrustedCA(trustedCA)</code></a></li> <li><a href=#obj-specsingresstoportsterminatingtlssecret><code>obj specs.ingress.toPorts.terminatingTLS.secret</code></a></li> <li><a href=#fn-specsingresstoportsterminatingtlssecretwithname><code>fn withName(name)</code></a></li> <li><a href=#fn-specsingresstoportsterminatingtlssecretwithnamespace><code>fn withNamespace(namespace)</code></a></li> </ul> </li> </ul> </li> <li><a href=#obj-specsingressdeny><code>obj specs.ingressDeny</code></a><ul> <li><a href=#fn-specsingressdenywithfromcidr><code>fn withFromCIDR(fromCIDR)</code></a></li> <li><a href=#fn-specsingressdenywithfromcidrmixin><code>fn withFromCIDRMixin(fromCIDR)</code></a></li> <li><a href=#fn-specsingressdenywithfromcidrset><code>fn withFromCIDRSet(fromCIDRSet)</code></a></li> <li><a href=#fn-specsingressdenywithfromcidrsetmixin><code>fn withFromCIDRSetMixin(fromCIDRSet)</code></a></li> <li><a href=#fn-specsingressdenywithfromendpoints><code>fn withFromEndpoints(fromEndpoints)</code></a></li> <li><a href=#fn-specsingressdenywithfromendpointsmixin><code>fn withFromEndpointsMixin(fromEndpoints)</code></a></li> <li><a href=#fn-specsingressdenywithfromentities><code>fn withFromEntities(fromEntities)</code></a></li> <li><a href=#fn-specsingressdenywithfromentitiesmixin><code>fn withFromEntitiesMixin(fromEntities)</code></a></li> <li><a href=#fn-specsingressdenywithfromrequires><code>fn withFromRequires(fromRequires)</code></a></li> <li><a href=#fn-specsingressdenywithfromrequiresmixin><code>fn withFromRequiresMixin(fromRequires)</code></a></li> <li><a href=#fn-specsingressdenywithicmps><code>fn withIcmps(icmps)</code></a></li> <li><a href=#fn-specsingressdenywithicmpsmixin><code>fn withIcmpsMixin(icmps)</code></a></li> <li><a href=#fn-specsingressdenywithtoports><code>fn withToPorts(toPorts)</code></a></li> <li><a href=#fn-specsingressdenywithtoportsmixin><code>fn withToPortsMixin(toPorts)</code></a></li> <li><a href=#obj-specsingressdenyfromcidrset><code>obj specs.ingressDeny.fromCIDRSet</code></a></li> <li><a href=#fn-specsingressdenyfromcidrsetwithcidr><code>fn withCidr(cidr)</code></a></li> <li><a href=#fn-specsingressdenyfromcidrsetwithexcept><code>fn withExcept(except)</code></a></li> <li><a href=#fn-specsingressdenyfromcidrsetwithexceptmixin><code>fn withExceptMixin(except)</code></a></li> <li><a href=#obj-specsingressdenyfromendpoints><code>obj specs.ingressDeny.fromEndpoints</code></a></li> <li><a href=#fn-specsingressdenyfromendpointswithmatchexpressions><code>fn withMatchExpressions(matchExpressions)</code></a></li> <li><a href=#fn-specsingressdenyfromendpointswithmatchexpressionsmixin><code>fn withMatchExpressionsMixin(matchExpressions)</code></a></li> <li><a href=#fn-specsingressdenyfromendpointswithmatchlabels><code>fn withMatchLabels(matchLabels)</code></a></li> <li><a href=#fn-specsingressdenyfromendpointswithmatchlabelsmixin><code>fn withMatchLabelsMixin(matchLabels)</code></a></li> <li><a href=#obj-specsingressdenyfromendpointsmatchexpressions><code>obj specs.ingressDeny.fromEndpoints.matchExpressions</code></a><ul> <li><a href=#fn-specsingressdenyfromendpointsmatchexpressionswithkey><code>fn withKey(key)</code></a></li> <li><a href=#fn-specsingressdenyfromendpointsmatchexpressionswithoperator><code>fn withOperator(operator)</code></a></li> <li><a href=#fn-specsingressdenyfromendpointsmatchexpressionswithvalues><code>fn withValues(values)</code></a></li> <li><a href=#fn-specsingressdenyfromendpointsmatchexpressionswithvaluesmixin><code>fn withValuesMixin(values)</code></a></li> </ul> </li> <li><a href=#obj-specsingressdenyfromrequires><code>obj specs.ingressDeny.fromRequires</code></a></li> <li><a href=#fn-specsingressdenyfromrequireswithmatchexpressions><code>fn withMatchExpressions(matchExpressions)</code></a></li> <li><a href=#fn-specsingressdenyfromrequireswithmatchexpressionsmixin><code>fn withMatchExpressionsMixin(matchExpressions)</code></a></li> <li><a href=#fn-specsingressdenyfromrequireswithmatchlabels><code>fn withMatchLabels(matchLabels)</code></a></li> <li><a href=#fn-specsingressdenyfromrequireswithmatchlabelsmixin><code>fn withMatchLabelsMixin(matchLabels)</code></a></li> <li><a href=#obj-specsingressdenyfromrequiresmatchexpressions><code>obj specs.ingressDeny.fromRequires.matchExpressions</code></a><ul> <li><a href=#fn-specsingressdenyfromrequiresmatchexpressionswithkey><code>fn withKey(key)</code></a></li> <li><a href=#fn-specsingressdenyfromrequiresmatchexpressionswithoperator><code>fn withOperator(operator)</code></a></li> <li><a href=#fn-specsingressdenyfromrequiresmatchexpressionswithvalues><code>fn withValues(values)</code></a></li> <li><a href=#fn-specsingressdenyfromrequiresmatchexpressionswithvaluesmixin><code>fn withValuesMixin(values)</code></a></li> </ul> </li> <li><a href=#obj-specsingressdenyicmps><code>obj specs.ingressDeny.icmps</code></a></li> <li><a href=#fn-specsingressdenyicmpswithfields><code>fn withFields(fields)</code></a></li> <li><a href=#fn-specsingressdenyicmpswithfieldsmixin><code>fn withFieldsMixin(fields)</code></a></li> <li><a href=#obj-specsingressdenyicmpsfields><code>obj specs.ingressDeny.icmps.fields</code></a><ul> <li><a href=#fn-specsingressdenyicmpsfieldswithfamily><code>fn withFamily(family)</code></a></li> <li><a href=#fn-specsingressdenyicmpsfieldswithtype><code>fn withType(type)</code></a></li> </ul> </li> <li><a href=#obj-specsingressdenytoports><code>obj specs.ingressDeny.toPorts</code></a></li> <li><a href=#fn-specsingressdenytoportswithports><code>fn withPorts(ports)</code></a></li> <li><a href=#fn-specsingressdenytoportswithportsmixin><code>fn withPortsMixin(ports)</code></a></li> <li><a href=#obj-specsingressdenytoportsports><code>obj specs.ingressDeny.toPorts.ports</code></a><ul> <li><a href=#fn-specsingressdenytoportsportswithport><code>fn withPort(port)</code></a></li> <li><a href=#fn-specsingressdenytoportsportswithprotocol><code>fn withProtocol(protocol)</code></a></li> </ul> </li> </ul> </li> <li><a href=#obj-specslabels><code>obj specs.labels</code></a><ul> <li><a href=#fn-specslabelswithkey><code>fn withKey(key)</code></a></li> <li><a href=#fn-specslabelswithsource><code>fn withSource(source)</code></a></li> <li><a href=#fn-specslabelswithvalue><code>fn withValue(value)</code></a></li> </ul> </li> <li><a href=#obj-specsnodeselector><code>obj specs.nodeSelector</code></a><ul> <li><a href=#fn-specsnodeselectorwithmatchexpressions><code>fn withMatchExpressions(matchExpressions)</code></a></li> <li><a href=#fn-specsnodeselectorwithmatchexpressionsmixin><code>fn withMatchExpressionsMixin(matchExpressions)</code></a></li> <li><a href=#fn-specsnodeselectorwithmatchlabels><code>fn withMatchLabels(matchLabels)</code></a></li> <li><a href=#fn-specsnodeselectorwithmatchlabelsmixin><code>fn withMatchLabelsMixin(matchLabels)</code></a></li> <li><a href=#obj-specsnodeselectormatchexpressions><code>obj specs.nodeSelector.matchExpressions</code></a></li> <li><a href=#fn-specsnodeselectormatchexpressionswithkey><code>fn withKey(key)</code></a></li> <li><a href=#fn-specsnodeselectormatchexpressionswithoperator><code>fn withOperator(operator)</code></a></li> <li><a href=#fn-specsnodeselectormatchexpressionswithvalues><code>fn withValues(values)</code></a></li> <li><a href=#fn-specsnodeselectormatchexpressionswithvaluesmixin><code>fn withValuesMixin(values)</code></a></li> </ul> </li> </ul> <h2 id=fields>Fields</h2> <h3 id=fn-new>fn new</h3> <div class=highlight><pre><span></span><code><span class=ow>new</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>new returns an instance of CiliumNetworkPolicy</p> <h3 id=fn-withspecs>fn withSpecs</h3> <div class=highlight><pre><span></span><code><span class=nx>withSpecs</span><span class=p>(</span><span class=nx>specs</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Specs is a list of desired Cilium specific rule specification."</p> <h3 id=fn-withspecsmixin>fn withSpecsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withSpecsMixin</span><span class=p>(</span><span class=nx>specs</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Specs is a list of desired Cilium specific rule specification."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-metadata>obj metadata</h2> <p>"ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create."</p> <h3 id=fn-metadatawithannotations>fn metadata.withAnnotations</h3> <div class=highlight><pre><span></span><code><span class=nx>withAnnotations</span><span class=p>(</span><span class=nx>annotations</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"</p> <h3 id=fn-metadatawithannotationsmixin>fn metadata.withAnnotationsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withAnnotationsMixin</span><span class=p>(</span><span class=nx>annotations</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-metadatawithclustername>fn metadata.withClusterName</h3> <div class=highlight><pre><span></span><code><span class=nx>withClusterName</span><span class=p>(</span><span class=nx>clusterName</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request."</p> <h3 id=fn-metadatawithcreationtimestamp>fn metadata.withCreationTimestamp</h3> <div class=highlight><pre><span></span><code><span class=nx>withCreationTimestamp</span><span class=p>(</span><span class=nx>creationTimestamp</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON. Wrappers are provided for many of the factory methods that the time package offers."</p> <h3 id=fn-metadatawithdeletiongraceperiodseconds>fn metadata.withDeletionGracePeriodSeconds</h3> <div class=highlight><pre><span></span><code><span class=nx>withDeletionGracePeriodSeconds</span><span class=p>(</span><span class=nx>deletionGracePeriodSeconds</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only."</p> <h3 id=fn-metadatawithdeletiontimestamp>fn metadata.withDeletionTimestamp</h3> <div class=highlight><pre><span></span><code><span class=nx>withDeletionTimestamp</span><span class=p>(</span><span class=nx>deletionTimestamp</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON. Wrappers are provided for many of the factory methods that the time package offers."</p> <h3 id=fn-metadatawithfinalizers>fn metadata.withFinalizers</h3> <div class=highlight><pre><span></span><code><span class=nx>withFinalizers</span><span class=p>(</span><span class=nx>finalizers</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order. Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."</p> <h3 id=fn-metadatawithfinalizersmixin>fn metadata.withFinalizersMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withFinalizersMixin</span><span class=p>(</span><span class=nx>finalizers</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order. Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-metadatawithgeneratename>fn metadata.withGenerateName</h3> <div class=highlight><pre><span></span><code><span class=nx>withGenerateName</span><span class=p>(</span><span class=nx>generateName</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\n\nIf this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).\n\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency"</p> <h3 id=fn-metadatawithgeneration>fn metadata.withGeneration</h3> <div class=highlight><pre><span></span><code><span class=nx>withGeneration</span><span class=p>(</span><span class=nx>generation</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"A sequence number representing a specific generation of the desired state. Populated by the system. Read-only."</p> <h3 id=fn-metadatawithlabels>fn metadata.withLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withLabels</span><span class=p>(</span><span class=nx>labels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"</p> <h3 id=fn-metadatawithlabelsmixin>fn metadata.withLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withLabelsMixin</span><span class=p>(</span><span class=nx>labels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-metadatawithname>fn metadata.withName</h3> <div class=highlight><pre><span></span><code><span class=nx>withName</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names"</p> <h3 id=fn-metadatawithnamespace>fn metadata.withNamespace</h3> <div class=highlight><pre><span></span><code><span class=nx>withNamespace</span><span class=p>(</span><span class=nx>namespace</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \"default\" namespace, but \"default\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\n\nMust be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces"</p> <h3 id=fn-metadatawithownerreferences>fn metadata.withOwnerReferences</h3> <div class=highlight><pre><span></span><code><span class=nx>withOwnerReferences</span><span class=p>(</span><span class=nx>ownerReferences</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."</p> <h3 id=fn-metadatawithownerreferencesmixin>fn metadata.withOwnerReferencesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withOwnerReferencesMixin</span><span class=p>(</span><span class=nx>ownerReferences</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-metadatawithresourceversion>fn metadata.withResourceVersion</h3> <div class=highlight><pre><span></span><code><span class=nx>withResourceVersion</span><span class=p>(</span><span class=nx>resourceVersion</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\n\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency"</p> <h3 id=fn-metadatawithselflink>fn metadata.withSelfLink</h3> <div class=highlight><pre><span></span><code><span class=nx>withSelfLink</span><span class=p>(</span><span class=nx>selfLink</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"SelfLink is a URL representing this object. Populated by the system. Read-only.\n\nDEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release."</p> <h3 id=fn-metadatawithuid>fn metadata.withUid</h3> <div class=highlight><pre><span></span><code><span class=nx>withUid</span><span class=p>(</span><span class=nx>uid</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\n\nPopulated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids"</p> <h2 id=obj-spec>obj spec</h2> <p>"Spec is the desired Cilium specific rule specification."</p> <h3 id=fn-specwithdescription>fn spec.withDescription</h3> <div class=highlight><pre><span></span><code><span class=nx>withDescription</span><span class=p>(</span><span class=nx>description</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Description is a free form string, it can be used by the creator of the rule to store human readable explanation of the purpose of this rule. Rules cannot be identified by comment."</p> <h3 id=fn-specwithegress>fn spec.withEgress</h3> <div class=highlight><pre><span></span><code><span class=nx>withEgress</span><span class=p>(</span><span class=nx>egress</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Egress is a list of EgressRule which are enforced at egress. If omitted or empty, this rule does not apply at egress."</p> <h3 id=fn-specwithegressdeny>fn spec.withEgressDeny</h3> <div class=highlight><pre><span></span><code><span class=nx>withEgressDeny</span><span class=p>(</span><span class=nx>egressDeny</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"EgressDeny is a list of EgressDenyRule which are enforced at egress. Any rule inserted here will by denied regardless of the allowed egress rules in the 'egress' field. If omitted or empty, this rule does not apply at egress."</p> <h3 id=fn-specwithegressdenymixin>fn spec.withEgressDenyMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withEgressDenyMixin</span><span class=p>(</span><span class=nx>egressDeny</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"EgressDeny is a list of EgressDenyRule which are enforced at egress. Any rule inserted here will by denied regardless of the allowed egress rules in the 'egress' field. If omitted or empty, this rule does not apply at egress."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specwithegressmixin>fn spec.withEgressMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withEgressMixin</span><span class=p>(</span><span class=nx>egress</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Egress is a list of EgressRule which are enforced at egress. If omitted or empty, this rule does not apply at egress."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specwithingress>fn spec.withIngress</h3> <div class=highlight><pre><span></span><code><span class=nx>withIngress</span><span class=p>(</span><span class=nx>ingress</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Ingress is a list of IngressRule which are enforced at ingress. If omitted or empty, this rule does not apply at ingress."</p> <h3 id=fn-specwithingressdeny>fn spec.withIngressDeny</h3> <div class=highlight><pre><span></span><code><span class=nx>withIngressDeny</span><span class=p>(</span><span class=nx>ingressDeny</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"IngressDeny is a list of IngressDenyRule which are enforced at ingress. Any rule inserted here will by denied regardless of the allowed ingress rules in the 'ingress' field. If omitted or empty, this rule does not apply at ingress."</p> <h3 id=fn-specwithingressdenymixin>fn spec.withIngressDenyMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withIngressDenyMixin</span><span class=p>(</span><span class=nx>ingressDeny</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"IngressDeny is a list of IngressDenyRule which are enforced at ingress. Any rule inserted here will by denied regardless of the allowed ingress rules in the 'ingress' field. If omitted or empty, this rule does not apply at ingress."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specwithingressmixin>fn spec.withIngressMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withIngressMixin</span><span class=p>(</span><span class=nx>ingress</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Ingress is a list of IngressRule which are enforced at ingress. If omitted or empty, this rule does not apply at ingress."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specwithlabels>fn spec.withLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withLabels</span><span class=p>(</span><span class=nx>labels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Labels is a list of optional strings which can be used to re-identify the rule or to store metadata. It is possible to lookup or delete strings based on labels. Labels are not required to be unique, multiple rules can have overlapping or identical labels."</p> <h3 id=fn-specwithlabelsmixin>fn spec.withLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withLabelsMixin</span><span class=p>(</span><span class=nx>labels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Labels is a list of optional strings which can be used to re-identify the rule or to store metadata. It is possible to lookup or delete strings based on labels. Labels are not required to be unique, multiple rules can have overlapping or identical labels."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specegress>obj spec.egress</h2> <p>"Egress is a list of EgressRule which are enforced at egress. If omitted or empty, this rule does not apply at egress."</p> <h3 id=fn-specegresswithicmps>fn spec.egress.withIcmps</h3> <div class=highlight><pre><span></span><code><span class=nx>withIcmps</span><span class=p>(</span><span class=nx>icmps</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to connect to. \n Example: Any endpoint with the label \"app=httpd\" is allowed to initiate type 8 ICMP connections."</p> <h3 id=fn-specegresswithicmpsmixin>fn spec.egress.withIcmpsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withIcmpsMixin</span><span class=p>(</span><span class=nx>icmps</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to connect to. \n Example: Any endpoint with the label \"app=httpd\" is allowed to initiate type 8 ICMP connections."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegresswithtocidr>fn spec.egress.withToCIDR</h3> <div class=highlight><pre><span></span><code><span class=nx>withToCIDR</span><span class=p>(</span><span class=nx>toCIDR</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24"</p> <h3 id=fn-specegresswithtocidrmixin>fn spec.egress.withToCIDRMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToCIDRMixin</span><span class=p>(</span><span class=nx>toCIDR</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegresswithtocidrset>fn spec.egress.withToCIDRSet</h3> <div class=highlight><pre><span></span><code><span class=nx>withToCIDRSet</span><span class=p>(</span><span class=nx>toCIDRSet</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28."</p> <h3 id=fn-specegresswithtocidrsetmixin>fn spec.egress.withToCIDRSetMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToCIDRSetMixin</span><span class=p>(</span><span class=nx>toCIDRSet</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegresswithtoendpoints>fn spec.egress.withToEndpoints</h3> <div class=highlight><pre><span></span><code><span class=nx>withToEndpoints</span><span class=p>(</span><span class=nx>toEndpoints</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate. \n Example: Any endpoint with the label \"role=frontend\" can communicate with any endpoint carrying the label \"role=backend\"."</p> <h3 id=fn-specegresswithtoendpointsmixin>fn spec.egress.withToEndpointsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToEndpointsMixin</span><span class=p>(</span><span class=nx>toEndpoints</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate. \n Example: Any endpoint with the label \"role=frontend\" can communicate with any endpoint carrying the label \"role=backend\"."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegresswithtoentities>fn spec.egress.withToEntities</h3> <div class=highlight><pre><span></span><code><span class=nx>withToEntities</span><span class=p>(</span><span class=nx>toEntities</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are <code>world</code>, <code>cluster</code> and <code>host</code>"</p> <h3 id=fn-specegresswithtoentitiesmixin>fn spec.egress.withToEntitiesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToEntitiesMixin</span><span class=p>(</span><span class=nx>toEntities</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are <code>world</code>, <code>cluster</code> and <code>host</code>"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegresswithtofqdns>fn spec.egress.withToFQDNs</h3> <div class=highlight><pre><span></span><code><span class=nx>withToFQDNs</span><span class=p>(</span><span class=nx>toFQDNs</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToFQDN allows whitelisting DNS names in place of IPs. The IPs that result from DNS resolution of <code>ToFQDN.MatchName</code>s are added to the same EgressRule object as ToCIDRSet entries, and behave accordingly. Any L4 and L7 rules within this EgressRule will also apply to these IPs. The DNS -&gt; IP mapping is re-resolved periodically from within the cilium-agent, and the IPs in the DNS response are effected in the policy for selected pods as-is (i.e. the list of IPs is not modified in any way). Note: An explicit rule to allow for DNS traffic is needed for the pods, as ToFQDN counts as an egress rule and will enforce egress policy when PolicyEnforcment=default. Note: If the resolved IPs are IPs within the kubernetes cluster, the ToFQDN rule will not apply to that IP. Note: ToFQDN cannot occur in the same policy as other To* rules. \n The current implementation has a number of limitations: - The DNS resolution originates from cilium-agent, and not from the pods. Differences between the responses seen by cilium agent and a particular pod will whitelist the incorrect IP. - DNS TTLs are ignored, and cilium-agent will repoll on a short interval (5 seconds). Each change to the DNS data will trigger a policy regeneration. This may result in delayed updates to the policy for an endpoint when the data changes often or the system is under load."</p> <h3 id=fn-specegresswithtofqdnsmixin>fn spec.egress.withToFQDNsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToFQDNsMixin</span><span class=p>(</span><span class=nx>toFQDNs</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToFQDN allows whitelisting DNS names in place of IPs. The IPs that result from DNS resolution of <code>ToFQDN.MatchName</code>s are added to the same EgressRule object as ToCIDRSet entries, and behave accordingly. Any L4 and L7 rules within this EgressRule will also apply to these IPs. The DNS -&gt; IP mapping is re-resolved periodically from within the cilium-agent, and the IPs in the DNS response are effected in the policy for selected pods as-is (i.e. the list of IPs is not modified in any way). Note: An explicit rule to allow for DNS traffic is needed for the pods, as ToFQDN counts as an egress rule and will enforce egress policy when PolicyEnforcment=default. Note: If the resolved IPs are IPs within the kubernetes cluster, the ToFQDN rule will not apply to that IP. Note: ToFQDN cannot occur in the same policy as other To* rules. \n The current implementation has a number of limitations: - The DNS resolution originates from cilium-agent, and not from the pods. Differences between the responses seen by cilium agent and a particular pod will whitelist the incorrect IP. - DNS TTLs are ignored, and cilium-agent will repoll on a short interval (5 seconds). Each change to the DNS data will trigger a policy regeneration. This may result in delayed updates to the policy for an endpoint when the data changes often or the system is under load."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegresswithtogroups>fn spec.egress.withToGroups</h3> <div class=highlight><pre><span></span><code><span class=nx>withToGroups</span><span class=p>(</span><span class=nx>toGroups</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives: \n Example: toGroups: - aws: securityGroupsIds: - 'sg-XXXXXXXXXXXXX'"</p> <h3 id=fn-specegresswithtogroupsmixin>fn spec.egress.withToGroupsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToGroupsMixin</span><span class=p>(</span><span class=nx>toGroups</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives: \n Example: toGroups: - aws: securityGroupsIds: - 'sg-XXXXXXXXXXXXX'"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegresswithtoports>fn spec.egress.withToPorts</h3> <div class=highlight><pre><span></span><code><span class=nx>withToPorts</span><span class=p>(</span><span class=nx>toPorts</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to connect to. \n Example: Any endpoint with the label \"role=frontend\" is allowed to initiate connections to destination port 8080/tcp"</p> <h3 id=fn-specegresswithtoportsmixin>fn spec.egress.withToPortsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToPortsMixin</span><span class=p>(</span><span class=nx>toPorts</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to connect to. \n Example: Any endpoint with the label \"role=frontend\" is allowed to initiate connections to destination port 8080/tcp"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegresswithtorequires>fn spec.egress.withToRequires</h3> <div class=highlight><pre><span></span><code><span class=nx>withToRequires</span><span class=p>(</span><span class=nx>toRequires</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires any endpoint to which it communicates to also carry the label \"team=A\"."</p> <h3 id=fn-specegresswithtorequiresmixin>fn spec.egress.withToRequiresMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToRequiresMixin</span><span class=p>(</span><span class=nx>toRequires</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires any endpoint to which it communicates to also carry the label \"team=A\"."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegresswithtoservices>fn spec.egress.withToServices</h3> <div class=highlight><pre><span></span><code><span class=nx>withToServices</span><span class=p>(</span><span class=nx>toServices</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors. \n Example: Any endpoint with the label \"app=backend-app\" is allowed to initiate connections to all cidrs backing the \"external-service\" service"</p> <h3 id=fn-specegresswithtoservicesmixin>fn spec.egress.withToServicesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToServicesMixin</span><span class=p>(</span><span class=nx>toServices</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors. \n Example: Any endpoint with the label \"app=backend-app\" is allowed to initiate connections to all cidrs backing the \"external-service\" service"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specegressicmps>obj spec.egress.icmps</h2> <p>"ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to connect to. \n Example: Any endpoint with the label \"app=httpd\" is allowed to initiate type 8 ICMP connections."</p> <h3 id=fn-specegressicmpswithfields>fn spec.egress.icmps.withFields</h3> <div class=highlight><pre><span></span><code><span class=nx>withFields</span><span class=p>(</span><span class=nx>fields</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Fields is a list of ICMP fields."</p> <h3 id=fn-specegressicmpswithfieldsmixin>fn spec.egress.icmps.withFieldsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withFieldsMixin</span><span class=p>(</span><span class=nx>fields</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Fields is a list of ICMP fields."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specegressicmpsfields>obj spec.egress.icmps.fields</h2> <p>"Fields is a list of ICMP fields."</p> <h3 id=fn-specegressicmpsfieldswithfamily>fn spec.egress.icmps.fields.withFamily</h3> <div class=highlight><pre><span></span><code><span class=nx>withFamily</span><span class=p>(</span><span class=nx>family</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Family is a IP address version. Currently, we support <code>IPv4</code> and <code>IPv6</code>. <code>IPv4</code> is set as default."</p> <h3 id=fn-specegressicmpsfieldswithtype>fn spec.egress.icmps.fields.withType</h3> <div class=highlight><pre><span></span><code><span class=nx>withType</span><span class=p>(</span><span class=kr>type</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Type is a ICMP-type. It should be 0-255 (8bit)."</p> <h2 id=obj-specegresstocidrset>obj spec.egress.toCIDRSet</h2> <p>"ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28."</p> <h3 id=fn-specegresstocidrsetwithcidr>fn spec.egress.toCIDRSet.withCidr</h3> <div class=highlight><pre><span></span><code><span class=nx>withCidr</span><span class=p>(</span><span class=nx>cidr</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"CIDR is a CIDR prefix / IP Block."</p> <h3 id=fn-specegresstocidrsetwithexcept>fn spec.egress.toCIDRSet.withExcept</h3> <div class=highlight><pre><span></span><code><span class=nx>withExcept</span><span class=p>(</span><span class=nx>except</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules."</p> <h3 id=fn-specegresstocidrsetwithexceptmixin>fn spec.egress.toCIDRSet.withExceptMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withExceptMixin</span><span class=p>(</span><span class=nx>except</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specegresstoendpoints>obj spec.egress.toEndpoints</h2> <p>"ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate. \n Example: Any endpoint with the label \"role=frontend\" can communicate with any endpoint carrying the label \"role=backend\"."</p> <h3 id=fn-specegresstoendpointswithmatchexpressions>fn spec.egress.toEndpoints.withMatchExpressions</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressions</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specegresstoendpointswithmatchexpressionsmixin>fn spec.egress.toEndpoints.withMatchExpressionsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressionsMixin</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegresstoendpointswithmatchlabels>fn spec.egress.toEndpoints.withMatchLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabels</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <h3 id=fn-specegresstoendpointswithmatchlabelsmixin>fn spec.egress.toEndpoints.withMatchLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabelsMixin</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specegresstoendpointsmatchexpressions>obj spec.egress.toEndpoints.matchExpressions</h2> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specegresstoendpointsmatchexpressionswithkey>fn spec.egress.toEndpoints.matchExpressions.withKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withKey</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"key is the label key that the selector applies to."</p> <h3 id=fn-specegresstoendpointsmatchexpressionswithoperator>fn spec.egress.toEndpoints.matchExpressions.withOperator</h3> <div class=highlight><pre><span></span><code><span class=nx>withOperator</span><span class=p>(</span><span class=nx>operator</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist."</p> <h3 id=fn-specegresstoendpointsmatchexpressionswithvalues>fn spec.egress.toEndpoints.matchExpressions.withValues</h3> <div class=highlight><pre><span></span><code><span class=nx>withValues</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <h3 id=fn-specegresstoendpointsmatchexpressionswithvaluesmixin>fn spec.egress.toEndpoints.matchExpressions.withValuesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withValuesMixin</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specegresstofqdns>obj spec.egress.toFQDNs</h2> <p>"ToFQDN allows whitelisting DNS names in place of IPs. The IPs that result from DNS resolution of <code>ToFQDN.MatchName</code>s are added to the same EgressRule object as ToCIDRSet entries, and behave accordingly. Any L4 and L7 rules within this EgressRule will also apply to these IPs. The DNS -&gt; IP mapping is re-resolved periodically from within the cilium-agent, and the IPs in the DNS response are effected in the policy for selected pods as-is (i.e. the list of IPs is not modified in any way). Note: An explicit rule to allow for DNS traffic is needed for the pods, as ToFQDN counts as an egress rule and will enforce egress policy when PolicyEnforcment=default. Note: If the resolved IPs are IPs within the kubernetes cluster, the ToFQDN rule will not apply to that IP. Note: ToFQDN cannot occur in the same policy as other To* rules. \n The current implementation has a number of limitations: - The DNS resolution originates from cilium-agent, and not from the pods. Differences between the responses seen by cilium agent and a particular pod will whitelist the incorrect IP. - DNS TTLs are ignored, and cilium-agent will repoll on a short interval (5 seconds). Each change to the DNS data will trigger a policy regeneration. This may result in delayed updates to the policy for an endpoint when the data changes often or the system is under load."</p> <h3 id=fn-specegresstofqdnswithmatchname>fn spec.egress.toFQDNs.withMatchName</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchName</span><span class=p>(</span><span class=nx>matchName</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"MatchName matches literal DNS names. A trailing \".\" is automatically added when missing."</p> <h3 id=fn-specegresstofqdnswithmatchpattern>fn spec.egress.toFQDNs.withMatchPattern</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchPattern</span><span class=p>(</span><span class=nx>matchPattern</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"<em>\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"</em>\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: <code>*.cilium.io</code> matches subomains of cilium at that level www.cilium.io and blog.cilium.io match, cilium.io and google.com do not <code>*cilium.io</code> matches cilium.io and all subdomains ends with \"cilium.io\" except those containing \".\" separator, subcilium.io and sub-cilium.io match, www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\" sub.cilium.io and subdomain.cilium.io match, www.cilium.io, blog.cilium.io, cilium.io and google.com do not"</p> <h2 id=obj-specegresstogroups>obj spec.egress.toGroups</h2> <p>"ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives: \n Example: toGroups: - aws: securityGroupsIds: - 'sg-XXXXXXXXXXXXX'"</p> <h2 id=obj-specegresstogroupsaws>obj spec.egress.toGroups.aws</h2> <p>"AWSGroup is an structure that can be used to whitelisting information from AWS integration"</p> <h3 id=fn-specegresstogroupsawswithlabels>fn spec.egress.toGroups.aws.withLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withLabels</span><span class=p>(</span><span class=nx>labels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h3 id=fn-specegresstogroupsawswithlabelsmixin>fn spec.egress.toGroups.aws.withLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withLabelsMixin</span><span class=p>(</span><span class=nx>labels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegresstogroupsawswithregion>fn spec.egress.toGroups.aws.withRegion</h3> <div class=highlight><pre><span></span><code><span class=nx>withRegion</span><span class=p>(</span><span class=nx>region</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h3 id=fn-specegresstogroupsawswithsecuritygroupsids>fn spec.egress.toGroups.aws.withSecurityGroupsIds</h3> <div class=highlight><pre><span></span><code><span class=nx>withSecurityGroupsIds</span><span class=p>(</span><span class=nx>securityGroupsIds</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h3 id=fn-specegresstogroupsawswithsecuritygroupsidsmixin>fn spec.egress.toGroups.aws.withSecurityGroupsIdsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withSecurityGroupsIdsMixin</span><span class=p>(</span><span class=nx>securityGroupsIds</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegresstogroupsawswithsecuritygroupsnames>fn spec.egress.toGroups.aws.withSecurityGroupsNames</h3> <div class=highlight><pre><span></span><code><span class=nx>withSecurityGroupsNames</span><span class=p>(</span><span class=nx>securityGroupsNames</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h3 id=fn-specegresstogroupsawswithsecuritygroupsnamesmixin>fn spec.egress.toGroups.aws.withSecurityGroupsNamesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withSecurityGroupsNamesMixin</span><span class=p>(</span><span class=nx>securityGroupsNames</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specegresstoports>obj spec.egress.toPorts</h2> <p>"ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to connect to. \n Example: Any endpoint with the label \"role=frontend\" is allowed to initiate connections to destination port 8080/tcp"</p> <h3 id=fn-specegresstoportswithports>fn spec.egress.toPorts.withPorts</h3> <div class=highlight><pre><span></span><code><span class=nx>withPorts</span><span class=p>(</span><span class=nx>ports</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Ports is a list of L4 port/protocol"</p> <h3 id=fn-specegresstoportswithportsmixin>fn spec.egress.toPorts.withPortsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withPortsMixin</span><span class=p>(</span><span class=nx>ports</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Ports is a list of L4 port/protocol"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specegresstoportsoriginatingtls>obj spec.egress.toPorts.originatingTLS</h2> <p>"OriginatingTLS is the TLS context for the connections originated by the L7 proxy. For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint."</p> <h3 id=fn-specegresstoportsoriginatingtlswithcertificate>fn spec.egress.toPorts.originatingTLS.withCertificate</h3> <div class=highlight><pre><span></span><code><span class=nx>withCertificate</span><span class=p>(</span><span class=nx>certificate</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist."</p> <h3 id=fn-specegresstoportsoriginatingtlswithprivatekey>fn spec.egress.toPorts.originatingTLS.withPrivateKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withPrivateKey</span><span class=p>(</span><span class=nx>privateKey</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist."</p> <h3 id=fn-specegresstoportsoriginatingtlswithtrustedca>fn spec.egress.toPorts.originatingTLS.withTrustedCA</h3> <div class=highlight><pre><span></span><code><span class=nx>withTrustedCA</span><span class=p>(</span><span class=nx>trustedCA</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist."</p> <h2 id=obj-specegresstoportsoriginatingtlssecret>obj spec.egress.toPorts.originatingTLS.secret</h2> <p>"Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt' - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate."</p> <h3 id=fn-specegresstoportsoriginatingtlssecretwithname>fn spec.egress.toPorts.originatingTLS.secret.withName</h3> <div class=highlight><pre><span></span><code><span class=nx>withName</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Name is the name of the secret."</p> <h3 id=fn-specegresstoportsoriginatingtlssecretwithnamespace>fn spec.egress.toPorts.originatingTLS.secret.withNamespace</h3> <div class=highlight><pre><span></span><code><span class=nx>withNamespace</span><span class=p>(</span><span class=nx>namespace</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\")."</p> <h2 id=obj-specegresstoportsports>obj spec.egress.toPorts.ports</h2> <p>"Ports is a list of L4 port/protocol"</p> <h3 id=fn-specegresstoportsportswithport>fn spec.egress.toPorts.ports.withPort</h3> <div class=highlight><pre><span></span><code><span class=nx>withPort</span><span class=p>(</span><span class=nx>port</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end."</p> <h3 id=fn-specegresstoportsportswithprotocol>fn spec.egress.toPorts.ports.withProtocol</h3> <div class=highlight><pre><span></span><code><span class=nx>withProtocol</span><span class=p>(</span><span class=nx>protocol</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"\"/\"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this."</p> <h2 id=obj-specegresstoportsrules>obj spec.egress.toPorts.rules</h2> <p>"Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced."</p> <h3 id=fn-specegresstoportsruleswithdns>fn spec.egress.toPorts.rules.withDns</h3> <div class=highlight><pre><span></span><code><span class=nx>withDns</span><span class=p>(</span><span class=nx>dns</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"DNS-specific rules."</p> <h3 id=fn-specegresstoportsruleswithdnsmixin>fn spec.egress.toPorts.rules.withDnsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withDnsMixin</span><span class=p>(</span><span class=nx>dns</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"DNS-specific rules."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegresstoportsruleswithhttp>fn spec.egress.toPorts.rules.withHttp</h3> <div class=highlight><pre><span></span><code><span class=nx>withHttp</span><span class=p>(</span><span class=nx>http</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"HTTP specific rules."</p> <h3 id=fn-specegresstoportsruleswithhttpmixin>fn spec.egress.toPorts.rules.withHttpMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withHttpMixin</span><span class=p>(</span><span class=nx>http</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"HTTP specific rules."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegresstoportsruleswithkafka>fn spec.egress.toPorts.rules.withKafka</h3> <div class=highlight><pre><span></span><code><span class=nx>withKafka</span><span class=p>(</span><span class=nx>kafka</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Kafka-specific rules."</p> <h3 id=fn-specegresstoportsruleswithkafkamixin>fn spec.egress.toPorts.rules.withKafkaMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withKafkaMixin</span><span class=p>(</span><span class=nx>kafka</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Kafka-specific rules."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegresstoportsruleswithl7>fn spec.egress.toPorts.rules.withL7</h3> <div class=highlight><pre><span></span><code><span class=nx>withL7</span><span class=p>(</span><span class=nx>l7</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Key-value pair rules."</p> <h3 id=fn-specegresstoportsruleswithl7mixin>fn spec.egress.toPorts.rules.withL7Mixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withL7Mixin</span><span class=p>(</span><span class=nx>l7</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Key-value pair rules."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegresstoportsruleswithl7proto>fn spec.egress.toPorts.rules.withL7proto</h3> <div class=highlight><pre><span></span><code><span class=nx>withL7proto</span><span class=p>(</span><span class=nx>l7proto</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Name of the L7 protocol for which the Key-value pair rules apply."</p> <h2 id=obj-specegresstoportsrulesdns>obj spec.egress.toPorts.rules.dns</h2> <p>"DNS-specific rules."</p> <h3 id=fn-specegresstoportsrulesdnswithmatchname>fn spec.egress.toPorts.rules.dns.withMatchName</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchName</span><span class=p>(</span><span class=nx>matchName</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"MatchName matches literal DNS names. A trailing \".\" is automatically added when missing."</p> <h3 id=fn-specegresstoportsrulesdnswithmatchpattern>fn spec.egress.toPorts.rules.dns.withMatchPattern</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchPattern</span><span class=p>(</span><span class=nx>matchPattern</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"<em>\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"</em>\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: <code>*.cilium.io</code> matches subomains of cilium at that level www.cilium.io and blog.cilium.io match, cilium.io and google.com do not <code>*cilium.io</code> matches cilium.io and all subdomains ends with \"cilium.io\" except those containing \".\" separator, subcilium.io and sub-cilium.io match, www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\" sub.cilium.io and subdomain.cilium.io match, www.cilium.io, blog.cilium.io, cilium.io and google.com do not"</p> <h2 id=obj-specegresstoportsruleshttp>obj spec.egress.toPorts.rules.http</h2> <p>"HTTP specific rules."</p> <h3 id=fn-specegresstoportsruleshttpwithheadermatches>fn spec.egress.toPorts.rules.http.withHeaderMatches</h3> <div class=highlight><pre><span></span><code><span class=nx>withHeaderMatches</span><span class=p>(</span><span class=nx>headerMatches</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match."</p> <h3 id=fn-specegresstoportsruleshttpwithheadermatchesmixin>fn spec.egress.toPorts.rules.http.withHeaderMatchesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withHeaderMatchesMixin</span><span class=p>(</span><span class=nx>headerMatches</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegresstoportsruleshttpwithheaders>fn spec.egress.toPorts.rules.http.withHeaders</h3> <div class=highlight><pre><span></span><code><span class=nx>withHeaders</span><span class=p>(</span><span class=nx>headers</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present."</p> <h3 id=fn-specegresstoportsruleshttpwithheadersmixin>fn spec.egress.toPorts.rules.http.withHeadersMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withHeadersMixin</span><span class=p>(</span><span class=nx>headers</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegresstoportsruleshttpwithhost>fn spec.egress.toPorts.rules.http.withHost</h3> <div class=highlight><pre><span></span><code><span class=nx>withHost</span><span class=p>(</span><span class=nx>host</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Host is an extended POSIX regex matched against the host header of a request, e.g. \"foo.com\" \n If omitted or empty, the value of the host header is ignored."</p> <h3 id=fn-specegresstoportsruleshttpwithmethod>fn spec.egress.toPorts.rules.http.withMethod</h3> <div class=highlight><pre><span></span><code><span class=nx>withMethod</span><span class=p>(</span><span class=nx>method</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Method is an extended POSIX regex matched against the method of a request, e.g. \"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\", ... \n If omitted or empty, all methods are allowed."</p> <h3 id=fn-specegresstoportsruleshttpwithpath>fn spec.egress.toPorts.rules.http.withPath</h3> <div class=highlight><pre><span></span><code><span class=nx>withPath</span><span class=p>(</span><span class=nx>path</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Path is an extended POSIX regex matched against the path of a request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986. \n If omitted or empty, all paths are all allowed."</p> <h2 id=obj-specegresstoportsruleshttpheadermatches>obj spec.egress.toPorts.rules.http.headerMatches</h2> <p>"HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match."</p> <h3 id=fn-specegresstoportsruleshttpheadermatcheswithmismatch>fn spec.egress.toPorts.rules.http.headerMatches.withMismatch</h3> <div class=highlight><pre><span></span><code><span class=nx>withMismatch</span><span class=p>(</span><span class=nx>mismatch</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log."</p> <h3 id=fn-specegresstoportsruleshttpheadermatcheswithname>fn spec.egress.toPorts.rules.http.headerMatches.withName</h3> <div class=highlight><pre><span></span><code><span class=nx>withName</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Name identifies the header."</p> <h3 id=fn-specegresstoportsruleshttpheadermatcheswithvalue>fn spec.egress.toPorts.rules.http.headerMatches.withValue</h3> <div class=highlight><pre><span></span><code><span class=nx>withValue</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Value matches the exact value of the header. Can be specified either alone or together with \"Secret\"; will be used as the header value if the secret can not be found in the latter case."</p> <h2 id=obj-specegresstoportsruleshttpheadermatchessecret>obj spec.egress.toPorts.rules.http.headerMatches.secret</h2> <p>"Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no \"Value\" specified, the match will fail."</p> <h3 id=fn-specegresstoportsruleshttpheadermatchessecretwithname>fn spec.egress.toPorts.rules.http.headerMatches.secret.withName</h3> <div class=highlight><pre><span></span><code><span class=nx>withName</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Name is the name of the secret."</p> <h3 id=fn-specegresstoportsruleshttpheadermatchessecretwithnamespace>fn spec.egress.toPorts.rules.http.headerMatches.secret.withNamespace</h3> <div class=highlight><pre><span></span><code><span class=nx>withNamespace</span><span class=p>(</span><span class=nx>namespace</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\")."</p> <h2 id=obj-specegresstoportsruleskafka>obj spec.egress.toPorts.rules.kafka</h2> <p>"Kafka-specific rules."</p> <h3 id=fn-specegresstoportsruleskafkawithapikey>fn spec.egress.toPorts.rules.kafka.withApiKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withApiKey</span><span class=p>(</span><span class=nx>apiKey</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"APIKey is a case-insensitive string matched against the key of a request, e.g. \"produce\", \"fetch\", \"createtopic\", \"deletetopic\", et al Reference: https://kafka.apache.org/protocol#protocol_api_keys \n If omitted or empty, and if Role is not specified, then all keys are allowed."</p> <h3 id=fn-specegresstoportsruleskafkawithapiversion>fn spec.egress.toPorts.rules.kafka.withApiVersion</h3> <div class=highlight><pre><span></span><code><span class=nx>withApiVersion</span><span class=p>(</span><span class=nx>apiVersion</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"APIVersion is the version matched against the api version of the Kafka message. If set, it has to be a string representing a positive integer. \n If omitted or empty, all versions are allowed."</p> <h3 id=fn-specegresstoportsruleskafkawithclientid>fn spec.egress.toPorts.rules.kafka.withClientID</h3> <div class=highlight><pre><span></span><code><span class=nx>withClientID</span><span class=p>(</span><span class=nx>clientID</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ClientID is the client identifier as provided in the request. \n From Kafka protocol documentation: This is a user supplied identifier for the client application. The user can use any identifier they like and it will be used when logging errors, monitoring aggregates, etc. For example, one might want to monitor not just the requests per second overall, but the number coming from each client application (each of which could reside on multiple servers). This id acts as a logical grouping across all requests from a particular client. \n If omitted or empty, all client identifiers are allowed."</p> <h3 id=fn-specegresstoportsruleskafkawithrole>fn spec.egress.toPorts.rules.kafka.withRole</h3> <div class=highlight><pre><span></span><code><span class=nx>withRole</span><span class=p>(</span><span class=nx>role</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as \"produce\" or \"consume\". A Role automatically expands into all APIKeys required to perform the specified higher-level operation. \n The following values are supported: - \"produce\": Allow producing to the topics specified in the rule - \"consume\": Allow consuming from the topics specified in the rule \n This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule. \n If omitted or empty, and if APIKey is not specified, then all keys are allowed."</p> <h3 id=fn-specegresstoportsruleskafkawithtopic>fn spec.egress.toPorts.rules.kafka.withTopic</h3> <div class=highlight><pre><span></span><code><span class=nx>withTopic</span><span class=p>(</span><span class=nx>topic</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Topic is the topic name contained in the message. If a Kafka request contains multiple topics, then all topics must be allowed or the message will be rejected. \n This constraint is ignored if the matched request message type doesn't contain any topic. Maximum size of Topic can be 249 characters as per recent Kafka spec and allowed characters are a-z, A-Z, 0-9, -, . and _. \n Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10 version the length was changed from 255 to 249. For compatibility reasons we are using 255. \n If omitted or empty, all topics are allowed."</p> <h2 id=obj-specegresstoportsterminatingtls>obj spec.egress.toPorts.terminatingTLS</h2> <p>"TerminatingTLS is the TLS context for the connection terminated by the L7 proxy. For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy."</p> <h3 id=fn-specegresstoportsterminatingtlswithcertificate>fn spec.egress.toPorts.terminatingTLS.withCertificate</h3> <div class=highlight><pre><span></span><code><span class=nx>withCertificate</span><span class=p>(</span><span class=nx>certificate</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist."</p> <h3 id=fn-specegresstoportsterminatingtlswithprivatekey>fn spec.egress.toPorts.terminatingTLS.withPrivateKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withPrivateKey</span><span class=p>(</span><span class=nx>privateKey</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist."</p> <h3 id=fn-specegresstoportsterminatingtlswithtrustedca>fn spec.egress.toPorts.terminatingTLS.withTrustedCA</h3> <div class=highlight><pre><span></span><code><span class=nx>withTrustedCA</span><span class=p>(</span><span class=nx>trustedCA</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist."</p> <h2 id=obj-specegresstoportsterminatingtlssecret>obj spec.egress.toPorts.terminatingTLS.secret</h2> <p>"Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt' - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate."</p> <h3 id=fn-specegresstoportsterminatingtlssecretwithname>fn spec.egress.toPorts.terminatingTLS.secret.withName</h3> <div class=highlight><pre><span></span><code><span class=nx>withName</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Name is the name of the secret."</p> <h3 id=fn-specegresstoportsterminatingtlssecretwithnamespace>fn spec.egress.toPorts.terminatingTLS.secret.withNamespace</h3> <div class=highlight><pre><span></span><code><span class=nx>withNamespace</span><span class=p>(</span><span class=nx>namespace</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\")."</p> <h2 id=obj-specegresstorequires>obj spec.egress.toRequires</h2> <p>"ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires any endpoint to which it communicates to also carry the label \"team=A\"."</p> <h3 id=fn-specegresstorequireswithmatchexpressions>fn spec.egress.toRequires.withMatchExpressions</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressions</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specegresstorequireswithmatchexpressionsmixin>fn spec.egress.toRequires.withMatchExpressionsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressionsMixin</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegresstorequireswithmatchlabels>fn spec.egress.toRequires.withMatchLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabels</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <h3 id=fn-specegresstorequireswithmatchlabelsmixin>fn spec.egress.toRequires.withMatchLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabelsMixin</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specegresstorequiresmatchexpressions>obj spec.egress.toRequires.matchExpressions</h2> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specegresstorequiresmatchexpressionswithkey>fn spec.egress.toRequires.matchExpressions.withKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withKey</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"key is the label key that the selector applies to."</p> <h3 id=fn-specegresstorequiresmatchexpressionswithoperator>fn spec.egress.toRequires.matchExpressions.withOperator</h3> <div class=highlight><pre><span></span><code><span class=nx>withOperator</span><span class=p>(</span><span class=nx>operator</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist."</p> <h3 id=fn-specegresstorequiresmatchexpressionswithvalues>fn spec.egress.toRequires.matchExpressions.withValues</h3> <div class=highlight><pre><span></span><code><span class=nx>withValues</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <h3 id=fn-specegresstorequiresmatchexpressionswithvaluesmixin>fn spec.egress.toRequires.matchExpressions.withValuesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withValuesMixin</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specegresstoservices>obj spec.egress.toServices</h2> <p>"ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors. \n Example: Any endpoint with the label \"app=backend-app\" is allowed to initiate connections to all cidrs backing the \"external-service\" service"</p> <h2 id=obj-specegresstoservicesk8sservice>obj spec.egress.toServices.k8sService</h2> <p>"K8sService selects service by name and namespace pair"</p> <h3 id=fn-specegresstoservicesk8sservicewithnamespace>fn spec.egress.toServices.k8sService.withNamespace</h3> <div class=highlight><pre><span></span><code><span class=nx>withNamespace</span><span class=p>(</span><span class=nx>namespace</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h3 id=fn-specegresstoservicesk8sservicewithservicename>fn spec.egress.toServices.k8sService.withServiceName</h3> <div class=highlight><pre><span></span><code><span class=nx>withServiceName</span><span class=p>(</span><span class=nx>serviceName</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h2 id=obj-specegresstoservicesk8sserviceselector>obj spec.egress.toServices.k8sServiceSelector</h2> <p>"K8sServiceSelector selects services by k8s labels and namespace"</p> <h3 id=fn-specegresstoservicesk8sserviceselectorwithnamespace>fn spec.egress.toServices.k8sServiceSelector.withNamespace</h3> <div class=highlight><pre><span></span><code><span class=nx>withNamespace</span><span class=p>(</span><span class=nx>namespace</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h2 id=obj-specegresstoservicesk8sserviceselectorselector>obj spec.egress.toServices.k8sServiceSelector.selector</h2> <p>"ServiceSelector is a label selector for k8s services"</p> <h3 id=fn-specegresstoservicesk8sserviceselectorselectorwithmatchexpressions>fn spec.egress.toServices.k8sServiceSelector.selector.withMatchExpressions</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressions</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specegresstoservicesk8sserviceselectorselectorwithmatchexpressionsmixin>fn spec.egress.toServices.k8sServiceSelector.selector.withMatchExpressionsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressionsMixin</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegresstoservicesk8sserviceselectorselectorwithmatchlabels>fn spec.egress.toServices.k8sServiceSelector.selector.withMatchLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabels</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <h3 id=fn-specegresstoservicesk8sserviceselectorselectorwithmatchlabelsmixin>fn spec.egress.toServices.k8sServiceSelector.selector.withMatchLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabelsMixin</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specegresstoservicesk8sserviceselectorselectormatchexpressions>obj spec.egress.toServices.k8sServiceSelector.selector.matchExpressions</h2> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specegresstoservicesk8sserviceselectorselectormatchexpressionswithkey>fn spec.egress.toServices.k8sServiceSelector.selector.matchExpressions.withKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withKey</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"key is the label key that the selector applies to."</p> <h3 id=fn-specegresstoservicesk8sserviceselectorselectormatchexpressionswithoperator>fn spec.egress.toServices.k8sServiceSelector.selector.matchExpressions.withOperator</h3> <div class=highlight><pre><span></span><code><span class=nx>withOperator</span><span class=p>(</span><span class=nx>operator</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist."</p> <h3 id=fn-specegresstoservicesk8sserviceselectorselectormatchexpressionswithvalues>fn spec.egress.toServices.k8sServiceSelector.selector.matchExpressions.withValues</h3> <div class=highlight><pre><span></span><code><span class=nx>withValues</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <h3 id=fn-specegresstoservicesk8sserviceselectorselectormatchexpressionswithvaluesmixin>fn spec.egress.toServices.k8sServiceSelector.selector.matchExpressions.withValuesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withValuesMixin</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specegressdeny>obj spec.egressDeny</h2> <p>"EgressDeny is a list of EgressDenyRule which are enforced at egress. Any rule inserted here will by denied regardless of the allowed egress rules in the 'egress' field. If omitted or empty, this rule does not apply at egress."</p> <h3 id=fn-specegressdenywithicmps>fn spec.egressDeny.withIcmps</h3> <div class=highlight><pre><span></span><code><span class=nx>withIcmps</span><span class=p>(</span><span class=nx>icmps</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to connect to. \n Example: Any endpoint with the label \"app=httpd\" is not allowed to initiate type 8 ICMP connections."</p> <h3 id=fn-specegressdenywithicmpsmixin>fn spec.egressDeny.withIcmpsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withIcmpsMixin</span><span class=p>(</span><span class=nx>icmps</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to connect to. \n Example: Any endpoint with the label \"app=httpd\" is not allowed to initiate type 8 ICMP connections."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegressdenywithtocidr>fn spec.egressDeny.withToCIDR</h3> <div class=highlight><pre><span></span><code><span class=nx>withToCIDR</span><span class=p>(</span><span class=nx>toCIDR</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24"</p> <h3 id=fn-specegressdenywithtocidrmixin>fn spec.egressDeny.withToCIDRMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToCIDRMixin</span><span class=p>(</span><span class=nx>toCIDR</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegressdenywithtocidrset>fn spec.egressDeny.withToCIDRSet</h3> <div class=highlight><pre><span></span><code><span class=nx>withToCIDRSet</span><span class=p>(</span><span class=nx>toCIDRSet</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28."</p> <h3 id=fn-specegressdenywithtocidrsetmixin>fn spec.egressDeny.withToCIDRSetMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToCIDRSetMixin</span><span class=p>(</span><span class=nx>toCIDRSet</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegressdenywithtoendpoints>fn spec.egressDeny.withToEndpoints</h3> <div class=highlight><pre><span></span><code><span class=nx>withToEndpoints</span><span class=p>(</span><span class=nx>toEndpoints</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate. \n Example: Any endpoint with the label \"role=frontend\" can communicate with any endpoint carrying the label \"role=backend\"."</p> <h3 id=fn-specegressdenywithtoendpointsmixin>fn spec.egressDeny.withToEndpointsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToEndpointsMixin</span><span class=p>(</span><span class=nx>toEndpoints</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate. \n Example: Any endpoint with the label \"role=frontend\" can communicate with any endpoint carrying the label \"role=backend\"."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegressdenywithtoentities>fn spec.egressDeny.withToEntities</h3> <div class=highlight><pre><span></span><code><span class=nx>withToEntities</span><span class=p>(</span><span class=nx>toEntities</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are <code>world</code>, <code>cluster</code> and <code>host</code>"</p> <h3 id=fn-specegressdenywithtoentitiesmixin>fn spec.egressDeny.withToEntitiesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToEntitiesMixin</span><span class=p>(</span><span class=nx>toEntities</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are <code>world</code>, <code>cluster</code> and <code>host</code>"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegressdenywithtogroups>fn spec.egressDeny.withToGroups</h3> <div class=highlight><pre><span></span><code><span class=nx>withToGroups</span><span class=p>(</span><span class=nx>toGroups</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives: \n Example: toGroups: - aws: securityGroupsIds: - 'sg-XXXXXXXXXXXXX'"</p> <h3 id=fn-specegressdenywithtogroupsmixin>fn spec.egressDeny.withToGroupsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToGroupsMixin</span><span class=p>(</span><span class=nx>toGroups</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives: \n Example: toGroups: - aws: securityGroupsIds: - 'sg-XXXXXXXXXXXXX'"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegressdenywithtoports>fn spec.egressDeny.withToPorts</h3> <div class=highlight><pre><span></span><code><span class=nx>withToPorts</span><span class=p>(</span><span class=nx>toPorts</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to connect to. \n Example: Any endpoint with the label \"role=frontend\" is not allowed to initiate connections to destination port 8080/tcp"</p> <h3 id=fn-specegressdenywithtoportsmixin>fn spec.egressDeny.withToPortsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToPortsMixin</span><span class=p>(</span><span class=nx>toPorts</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to connect to. \n Example: Any endpoint with the label \"role=frontend\" is not allowed to initiate connections to destination port 8080/tcp"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegressdenywithtorequires>fn spec.egressDeny.withToRequires</h3> <div class=highlight><pre><span></span><code><span class=nx>withToRequires</span><span class=p>(</span><span class=nx>toRequires</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires any endpoint to which it communicates to also carry the label \"team=A\"."</p> <h3 id=fn-specegressdenywithtorequiresmixin>fn spec.egressDeny.withToRequiresMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToRequiresMixin</span><span class=p>(</span><span class=nx>toRequires</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires any endpoint to which it communicates to also carry the label \"team=A\"."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegressdenywithtoservices>fn spec.egressDeny.withToServices</h3> <div class=highlight><pre><span></span><code><span class=nx>withToServices</span><span class=p>(</span><span class=nx>toServices</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors. \n Example: Any endpoint with the label \"app=backend-app\" is allowed to initiate connections to all cidrs backing the \"external-service\" service"</p> <h3 id=fn-specegressdenywithtoservicesmixin>fn spec.egressDeny.withToServicesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToServicesMixin</span><span class=p>(</span><span class=nx>toServices</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors. \n Example: Any endpoint with the label \"app=backend-app\" is allowed to initiate connections to all cidrs backing the \"external-service\" service"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specegressdenyicmps>obj spec.egressDeny.icmps</h2> <p>"ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to connect to. \n Example: Any endpoint with the label \"app=httpd\" is not allowed to initiate type 8 ICMP connections."</p> <h3 id=fn-specegressdenyicmpswithfields>fn spec.egressDeny.icmps.withFields</h3> <div class=highlight><pre><span></span><code><span class=nx>withFields</span><span class=p>(</span><span class=nx>fields</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Fields is a list of ICMP fields."</p> <h3 id=fn-specegressdenyicmpswithfieldsmixin>fn spec.egressDeny.icmps.withFieldsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withFieldsMixin</span><span class=p>(</span><span class=nx>fields</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Fields is a list of ICMP fields."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specegressdenyicmpsfields>obj spec.egressDeny.icmps.fields</h2> <p>"Fields is a list of ICMP fields."</p> <h3 id=fn-specegressdenyicmpsfieldswithfamily>fn spec.egressDeny.icmps.fields.withFamily</h3> <div class=highlight><pre><span></span><code><span class=nx>withFamily</span><span class=p>(</span><span class=nx>family</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Family is a IP address version. Currently, we support <code>IPv4</code> and <code>IPv6</code>. <code>IPv4</code> is set as default."</p> <h3 id=fn-specegressdenyicmpsfieldswithtype>fn spec.egressDeny.icmps.fields.withType</h3> <div class=highlight><pre><span></span><code><span class=nx>withType</span><span class=p>(</span><span class=kr>type</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Type is a ICMP-type. It should be 0-255 (8bit)."</p> <h2 id=obj-specegressdenytocidrset>obj spec.egressDeny.toCIDRSet</h2> <p>"ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28."</p> <h3 id=fn-specegressdenytocidrsetwithcidr>fn spec.egressDeny.toCIDRSet.withCidr</h3> <div class=highlight><pre><span></span><code><span class=nx>withCidr</span><span class=p>(</span><span class=nx>cidr</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"CIDR is a CIDR prefix / IP Block."</p> <h3 id=fn-specegressdenytocidrsetwithexcept>fn spec.egressDeny.toCIDRSet.withExcept</h3> <div class=highlight><pre><span></span><code><span class=nx>withExcept</span><span class=p>(</span><span class=nx>except</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules."</p> <h3 id=fn-specegressdenytocidrsetwithexceptmixin>fn spec.egressDeny.toCIDRSet.withExceptMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withExceptMixin</span><span class=p>(</span><span class=nx>except</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specegressdenytoendpoints>obj spec.egressDeny.toEndpoints</h2> <p>"ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate. \n Example: Any endpoint with the label \"role=frontend\" can communicate with any endpoint carrying the label \"role=backend\"."</p> <h3 id=fn-specegressdenytoendpointswithmatchexpressions>fn spec.egressDeny.toEndpoints.withMatchExpressions</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressions</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specegressdenytoendpointswithmatchexpressionsmixin>fn spec.egressDeny.toEndpoints.withMatchExpressionsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressionsMixin</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegressdenytoendpointswithmatchlabels>fn spec.egressDeny.toEndpoints.withMatchLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabels</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <h3 id=fn-specegressdenytoendpointswithmatchlabelsmixin>fn spec.egressDeny.toEndpoints.withMatchLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabelsMixin</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specegressdenytoendpointsmatchexpressions>obj spec.egressDeny.toEndpoints.matchExpressions</h2> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specegressdenytoendpointsmatchexpressionswithkey>fn spec.egressDeny.toEndpoints.matchExpressions.withKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withKey</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"key is the label key that the selector applies to."</p> <h3 id=fn-specegressdenytoendpointsmatchexpressionswithoperator>fn spec.egressDeny.toEndpoints.matchExpressions.withOperator</h3> <div class=highlight><pre><span></span><code><span class=nx>withOperator</span><span class=p>(</span><span class=nx>operator</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist."</p> <h3 id=fn-specegressdenytoendpointsmatchexpressionswithvalues>fn spec.egressDeny.toEndpoints.matchExpressions.withValues</h3> <div class=highlight><pre><span></span><code><span class=nx>withValues</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <h3 id=fn-specegressdenytoendpointsmatchexpressionswithvaluesmixin>fn spec.egressDeny.toEndpoints.matchExpressions.withValuesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withValuesMixin</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specegressdenytogroups>obj spec.egressDeny.toGroups</h2> <p>"ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives: \n Example: toGroups: - aws: securityGroupsIds: - 'sg-XXXXXXXXXXXXX'"</p> <h2 id=obj-specegressdenytogroupsaws>obj spec.egressDeny.toGroups.aws</h2> <p>"AWSGroup is an structure that can be used to whitelisting information from AWS integration"</p> <h3 id=fn-specegressdenytogroupsawswithlabels>fn spec.egressDeny.toGroups.aws.withLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withLabels</span><span class=p>(</span><span class=nx>labels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h3 id=fn-specegressdenytogroupsawswithlabelsmixin>fn spec.egressDeny.toGroups.aws.withLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withLabelsMixin</span><span class=p>(</span><span class=nx>labels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegressdenytogroupsawswithregion>fn spec.egressDeny.toGroups.aws.withRegion</h3> <div class=highlight><pre><span></span><code><span class=nx>withRegion</span><span class=p>(</span><span class=nx>region</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h3 id=fn-specegressdenytogroupsawswithsecuritygroupsids>fn spec.egressDeny.toGroups.aws.withSecurityGroupsIds</h3> <div class=highlight><pre><span></span><code><span class=nx>withSecurityGroupsIds</span><span class=p>(</span><span class=nx>securityGroupsIds</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h3 id=fn-specegressdenytogroupsawswithsecuritygroupsidsmixin>fn spec.egressDeny.toGroups.aws.withSecurityGroupsIdsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withSecurityGroupsIdsMixin</span><span class=p>(</span><span class=nx>securityGroupsIds</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegressdenytogroupsawswithsecuritygroupsnames>fn spec.egressDeny.toGroups.aws.withSecurityGroupsNames</h3> <div class=highlight><pre><span></span><code><span class=nx>withSecurityGroupsNames</span><span class=p>(</span><span class=nx>securityGroupsNames</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h3 id=fn-specegressdenytogroupsawswithsecuritygroupsnamesmixin>fn spec.egressDeny.toGroups.aws.withSecurityGroupsNamesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withSecurityGroupsNamesMixin</span><span class=p>(</span><span class=nx>securityGroupsNames</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specegressdenytoports>obj spec.egressDeny.toPorts</h2> <p>"ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to connect to. \n Example: Any endpoint with the label \"role=frontend\" is not allowed to initiate connections to destination port 8080/tcp"</p> <h3 id=fn-specegressdenytoportswithports>fn spec.egressDeny.toPorts.withPorts</h3> <div class=highlight><pre><span></span><code><span class=nx>withPorts</span><span class=p>(</span><span class=nx>ports</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Ports is a list of L4 port/protocol"</p> <h3 id=fn-specegressdenytoportswithportsmixin>fn spec.egressDeny.toPorts.withPortsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withPortsMixin</span><span class=p>(</span><span class=nx>ports</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Ports is a list of L4 port/protocol"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specegressdenytoportsports>obj spec.egressDeny.toPorts.ports</h2> <p>"Ports is a list of L4 port/protocol"</p> <h3 id=fn-specegressdenytoportsportswithport>fn spec.egressDeny.toPorts.ports.withPort</h3> <div class=highlight><pre><span></span><code><span class=nx>withPort</span><span class=p>(</span><span class=nx>port</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end."</p> <h3 id=fn-specegressdenytoportsportswithprotocol>fn spec.egressDeny.toPorts.ports.withProtocol</h3> <div class=highlight><pre><span></span><code><span class=nx>withProtocol</span><span class=p>(</span><span class=nx>protocol</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"\"/\"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this."</p> <h2 id=obj-specegressdenytorequires>obj spec.egressDeny.toRequires</h2> <p>"ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires any endpoint to which it communicates to also carry the label \"team=A\"."</p> <h3 id=fn-specegressdenytorequireswithmatchexpressions>fn spec.egressDeny.toRequires.withMatchExpressions</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressions</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specegressdenytorequireswithmatchexpressionsmixin>fn spec.egressDeny.toRequires.withMatchExpressionsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressionsMixin</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegressdenytorequireswithmatchlabels>fn spec.egressDeny.toRequires.withMatchLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabels</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <h3 id=fn-specegressdenytorequireswithmatchlabelsmixin>fn spec.egressDeny.toRequires.withMatchLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabelsMixin</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specegressdenytorequiresmatchexpressions>obj spec.egressDeny.toRequires.matchExpressions</h2> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specegressdenytorequiresmatchexpressionswithkey>fn spec.egressDeny.toRequires.matchExpressions.withKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withKey</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"key is the label key that the selector applies to."</p> <h3 id=fn-specegressdenytorequiresmatchexpressionswithoperator>fn spec.egressDeny.toRequires.matchExpressions.withOperator</h3> <div class=highlight><pre><span></span><code><span class=nx>withOperator</span><span class=p>(</span><span class=nx>operator</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist."</p> <h3 id=fn-specegressdenytorequiresmatchexpressionswithvalues>fn spec.egressDeny.toRequires.matchExpressions.withValues</h3> <div class=highlight><pre><span></span><code><span class=nx>withValues</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <h3 id=fn-specegressdenytorequiresmatchexpressionswithvaluesmixin>fn spec.egressDeny.toRequires.matchExpressions.withValuesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withValuesMixin</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specegressdenytoservices>obj spec.egressDeny.toServices</h2> <p>"ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors. \n Example: Any endpoint with the label \"app=backend-app\" is allowed to initiate connections to all cidrs backing the \"external-service\" service"</p> <h2 id=obj-specegressdenytoservicesk8sservice>obj spec.egressDeny.toServices.k8sService</h2> <p>"K8sService selects service by name and namespace pair"</p> <h3 id=fn-specegressdenytoservicesk8sservicewithnamespace>fn spec.egressDeny.toServices.k8sService.withNamespace</h3> <div class=highlight><pre><span></span><code><span class=nx>withNamespace</span><span class=p>(</span><span class=nx>namespace</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h3 id=fn-specegressdenytoservicesk8sservicewithservicename>fn spec.egressDeny.toServices.k8sService.withServiceName</h3> <div class=highlight><pre><span></span><code><span class=nx>withServiceName</span><span class=p>(</span><span class=nx>serviceName</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h2 id=obj-specegressdenytoservicesk8sserviceselector>obj spec.egressDeny.toServices.k8sServiceSelector</h2> <p>"K8sServiceSelector selects services by k8s labels and namespace"</p> <h3 id=fn-specegressdenytoservicesk8sserviceselectorwithnamespace>fn spec.egressDeny.toServices.k8sServiceSelector.withNamespace</h3> <div class=highlight><pre><span></span><code><span class=nx>withNamespace</span><span class=p>(</span><span class=nx>namespace</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h2 id=obj-specegressdenytoservicesk8sserviceselectorselector>obj spec.egressDeny.toServices.k8sServiceSelector.selector</h2> <p>"ServiceSelector is a label selector for k8s services"</p> <h3 id=fn-specegressdenytoservicesk8sserviceselectorselectorwithmatchexpressions>fn spec.egressDeny.toServices.k8sServiceSelector.selector.withMatchExpressions</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressions</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specegressdenytoservicesk8sserviceselectorselectorwithmatchexpressionsmixin>fn spec.egressDeny.toServices.k8sServiceSelector.selector.withMatchExpressionsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressionsMixin</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specegressdenytoservicesk8sserviceselectorselectorwithmatchlabels>fn spec.egressDeny.toServices.k8sServiceSelector.selector.withMatchLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabels</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <h3 id=fn-specegressdenytoservicesk8sserviceselectorselectorwithmatchlabelsmixin>fn spec.egressDeny.toServices.k8sServiceSelector.selector.withMatchLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabelsMixin</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specegressdenytoservicesk8sserviceselectorselectormatchexpressions>obj spec.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions</h2> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specegressdenytoservicesk8sserviceselectorselectormatchexpressionswithkey>fn spec.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions.withKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withKey</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"key is the label key that the selector applies to."</p> <h3 id=fn-specegressdenytoservicesk8sserviceselectorselectormatchexpressionswithoperator>fn spec.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions.withOperator</h3> <div class=highlight><pre><span></span><code><span class=nx>withOperator</span><span class=p>(</span><span class=nx>operator</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist."</p> <h3 id=fn-specegressdenytoservicesk8sserviceselectorselectormatchexpressionswithvalues>fn spec.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions.withValues</h3> <div class=highlight><pre><span></span><code><span class=nx>withValues</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <h3 id=fn-specegressdenytoservicesk8sserviceselectorselectormatchexpressionswithvaluesmixin>fn spec.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions.withValuesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withValuesMixin</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specendpointselector>obj spec.endpointSelector</h2> <p>"EndpointSelector selects all endpoints which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive."</p> <h3 id=fn-specendpointselectorwithmatchexpressions>fn spec.endpointSelector.withMatchExpressions</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressions</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specendpointselectorwithmatchexpressionsmixin>fn spec.endpointSelector.withMatchExpressionsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressionsMixin</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specendpointselectorwithmatchlabels>fn spec.endpointSelector.withMatchLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabels</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <h3 id=fn-specendpointselectorwithmatchlabelsmixin>fn spec.endpointSelector.withMatchLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabelsMixin</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specendpointselectormatchexpressions>obj spec.endpointSelector.matchExpressions</h2> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specendpointselectormatchexpressionswithkey>fn spec.endpointSelector.matchExpressions.withKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withKey</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"key is the label key that the selector applies to."</p> <h3 id=fn-specendpointselectormatchexpressionswithoperator>fn spec.endpointSelector.matchExpressions.withOperator</h3> <div class=highlight><pre><span></span><code><span class=nx>withOperator</span><span class=p>(</span><span class=nx>operator</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist."</p> <h3 id=fn-specendpointselectormatchexpressionswithvalues>fn spec.endpointSelector.matchExpressions.withValues</h3> <div class=highlight><pre><span></span><code><span class=nx>withValues</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <h3 id=fn-specendpointselectormatchexpressionswithvaluesmixin>fn spec.endpointSelector.matchExpressions.withValuesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withValuesMixin</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specingress>obj spec.ingress</h2> <p>"Ingress is a list of IngressRule which are enforced at ingress. If omitted or empty, this rule does not apply at ingress."</p> <h3 id=fn-specingresswithfromcidr>fn spec.ingress.withFromCIDR</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromCIDR</span><span class=p>(</span><span class=nx>fromCIDR</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do <em>not</em> originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.3.9.1"</p> <h3 id=fn-specingresswithfromcidrmixin>fn spec.ingress.withFromCIDRMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromCIDRMixin</span><span class=p>(</span><span class=nx>fromCIDR</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do <em>not</em> originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.3.9.1"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specingresswithfromcidrset>fn spec.ingress.withFromCIDRSet</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromCIDRSet</span><span class=p>(</span><span class=nx>fromCIDRSet</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12."</p> <h3 id=fn-specingresswithfromcidrsetmixin>fn spec.ingress.withFromCIDRSetMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromCIDRSetMixin</span><span class=p>(</span><span class=nx>fromCIDRSet</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specingresswithfromendpoints>fn spec.ingress.withFromEndpoints</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromEndpoints</span><span class=p>(</span><span class=nx>fromEndpoints</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule. \n Example: Any endpoint with the label \"role=backend\" can be consumed by any endpoint carrying the label \"role=frontend\"."</p> <h3 id=fn-specingresswithfromendpointsmixin>fn spec.ingress.withFromEndpointsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromEndpointsMixin</span><span class=p>(</span><span class=nx>fromEndpoints</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule. \n Example: Any endpoint with the label \"role=backend\" can be consumed by any endpoint carrying the label \"role=frontend\"."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specingresswithfromentities>fn spec.ingress.withFromEntities</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromEntities</span><span class=p>(</span><span class=nx>fromEntities</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are <code>world</code>, <code>cluster</code> and <code>host</code>"</p> <h3 id=fn-specingresswithfromentitiesmixin>fn spec.ingress.withFromEntitiesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromEntitiesMixin</span><span class=p>(</span><span class=nx>fromEntities</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are <code>world</code>, <code>cluster</code> and <code>host</code>"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specingresswithfromrequires>fn spec.ingress.withFromRequires</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromRequires</span><span class=p>(</span><span class=nx>fromRequires</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires consuming endpoint to also carry the label \"team=A\"."</p> <h3 id=fn-specingresswithfromrequiresmixin>fn spec.ingress.withFromRequiresMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromRequiresMixin</span><span class=p>(</span><span class=nx>fromRequires</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires consuming endpoint to also carry the label \"team=A\"."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specingresswithicmps>fn spec.ingress.withIcmps</h3> <div class=highlight><pre><span></span><code><span class=nx>withIcmps</span><span class=p>(</span><span class=nx>icmps</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can only accept incoming type 8 ICMP connections."</p> <h3 id=fn-specingresswithicmpsmixin>fn spec.ingress.withIcmpsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withIcmpsMixin</span><span class=p>(</span><span class=nx>icmps</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can only accept incoming type 8 ICMP connections."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specingresswithtoports>fn spec.ingress.withToPorts</h3> <div class=highlight><pre><span></span><code><span class=nx>withToPorts</span><span class=p>(</span><span class=nx>toPorts</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can only accept incoming connections on port 80/tcp."</p> <h3 id=fn-specingresswithtoportsmixin>fn spec.ingress.withToPortsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToPortsMixin</span><span class=p>(</span><span class=nx>toPorts</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can only accept incoming connections on port 80/tcp."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specingressfromcidrset>obj spec.ingress.fromCIDRSet</h2> <p>"FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12."</p> <h3 id=fn-specingressfromcidrsetwithcidr>fn spec.ingress.fromCIDRSet.withCidr</h3> <div class=highlight><pre><span></span><code><span class=nx>withCidr</span><span class=p>(</span><span class=nx>cidr</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"CIDR is a CIDR prefix / IP Block."</p> <h3 id=fn-specingressfromcidrsetwithexcept>fn spec.ingress.fromCIDRSet.withExcept</h3> <div class=highlight><pre><span></span><code><span class=nx>withExcept</span><span class=p>(</span><span class=nx>except</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules."</p> <h3 id=fn-specingressfromcidrsetwithexceptmixin>fn spec.ingress.fromCIDRSet.withExceptMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withExceptMixin</span><span class=p>(</span><span class=nx>except</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specingressfromendpoints>obj spec.ingress.fromEndpoints</h2> <p>"FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule. \n Example: Any endpoint with the label \"role=backend\" can be consumed by any endpoint carrying the label \"role=frontend\"."</p> <h3 id=fn-specingressfromendpointswithmatchexpressions>fn spec.ingress.fromEndpoints.withMatchExpressions</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressions</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specingressfromendpointswithmatchexpressionsmixin>fn spec.ingress.fromEndpoints.withMatchExpressionsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressionsMixin</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specingressfromendpointswithmatchlabels>fn spec.ingress.fromEndpoints.withMatchLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabels</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <h3 id=fn-specingressfromendpointswithmatchlabelsmixin>fn spec.ingress.fromEndpoints.withMatchLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabelsMixin</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specingressfromendpointsmatchexpressions>obj spec.ingress.fromEndpoints.matchExpressions</h2> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specingressfromendpointsmatchexpressionswithkey>fn spec.ingress.fromEndpoints.matchExpressions.withKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withKey</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"key is the label key that the selector applies to."</p> <h3 id=fn-specingressfromendpointsmatchexpressionswithoperator>fn spec.ingress.fromEndpoints.matchExpressions.withOperator</h3> <div class=highlight><pre><span></span><code><span class=nx>withOperator</span><span class=p>(</span><span class=nx>operator</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist."</p> <h3 id=fn-specingressfromendpointsmatchexpressionswithvalues>fn spec.ingress.fromEndpoints.matchExpressions.withValues</h3> <div class=highlight><pre><span></span><code><span class=nx>withValues</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <h3 id=fn-specingressfromendpointsmatchexpressionswithvaluesmixin>fn spec.ingress.fromEndpoints.matchExpressions.withValuesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withValuesMixin</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specingressfromrequires>obj spec.ingress.fromRequires</h2> <p>"FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires consuming endpoint to also carry the label \"team=A\"."</p> <h3 id=fn-specingressfromrequireswithmatchexpressions>fn spec.ingress.fromRequires.withMatchExpressions</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressions</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specingressfromrequireswithmatchexpressionsmixin>fn spec.ingress.fromRequires.withMatchExpressionsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressionsMixin</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specingressfromrequireswithmatchlabels>fn spec.ingress.fromRequires.withMatchLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabels</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <h3 id=fn-specingressfromrequireswithmatchlabelsmixin>fn spec.ingress.fromRequires.withMatchLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabelsMixin</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specingressfromrequiresmatchexpressions>obj spec.ingress.fromRequires.matchExpressions</h2> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specingressfromrequiresmatchexpressionswithkey>fn spec.ingress.fromRequires.matchExpressions.withKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withKey</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"key is the label key that the selector applies to."</p> <h3 id=fn-specingressfromrequiresmatchexpressionswithoperator>fn spec.ingress.fromRequires.matchExpressions.withOperator</h3> <div class=highlight><pre><span></span><code><span class=nx>withOperator</span><span class=p>(</span><span class=nx>operator</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist."</p> <h3 id=fn-specingressfromrequiresmatchexpressionswithvalues>fn spec.ingress.fromRequires.matchExpressions.withValues</h3> <div class=highlight><pre><span></span><code><span class=nx>withValues</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <h3 id=fn-specingressfromrequiresmatchexpressionswithvaluesmixin>fn spec.ingress.fromRequires.matchExpressions.withValuesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withValuesMixin</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specingressicmps>obj spec.ingress.icmps</h2> <p>"ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can only accept incoming type 8 ICMP connections."</p> <h3 id=fn-specingressicmpswithfields>fn spec.ingress.icmps.withFields</h3> <div class=highlight><pre><span></span><code><span class=nx>withFields</span><span class=p>(</span><span class=nx>fields</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Fields is a list of ICMP fields."</p> <h3 id=fn-specingressicmpswithfieldsmixin>fn spec.ingress.icmps.withFieldsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withFieldsMixin</span><span class=p>(</span><span class=nx>fields</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Fields is a list of ICMP fields."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specingressicmpsfields>obj spec.ingress.icmps.fields</h2> <p>"Fields is a list of ICMP fields."</p> <h3 id=fn-specingressicmpsfieldswithfamily>fn spec.ingress.icmps.fields.withFamily</h3> <div class=highlight><pre><span></span><code><span class=nx>withFamily</span><span class=p>(</span><span class=nx>family</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Family is a IP address version. Currently, we support <code>IPv4</code> and <code>IPv6</code>. <code>IPv4</code> is set as default."</p> <h3 id=fn-specingressicmpsfieldswithtype>fn spec.ingress.icmps.fields.withType</h3> <div class=highlight><pre><span></span><code><span class=nx>withType</span><span class=p>(</span><span class=kr>type</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Type is a ICMP-type. It should be 0-255 (8bit)."</p> <h2 id=obj-specingresstoports>obj spec.ingress.toPorts</h2> <p>"ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can only accept incoming connections on port 80/tcp."</p> <h3 id=fn-specingresstoportswithports>fn spec.ingress.toPorts.withPorts</h3> <div class=highlight><pre><span></span><code><span class=nx>withPorts</span><span class=p>(</span><span class=nx>ports</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Ports is a list of L4 port/protocol"</p> <h3 id=fn-specingresstoportswithportsmixin>fn spec.ingress.toPorts.withPortsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withPortsMixin</span><span class=p>(</span><span class=nx>ports</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Ports is a list of L4 port/protocol"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specingresstoportsoriginatingtls>obj spec.ingress.toPorts.originatingTLS</h2> <p>"OriginatingTLS is the TLS context for the connections originated by the L7 proxy. For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint."</p> <h3 id=fn-specingresstoportsoriginatingtlswithcertificate>fn spec.ingress.toPorts.originatingTLS.withCertificate</h3> <div class=highlight><pre><span></span><code><span class=nx>withCertificate</span><span class=p>(</span><span class=nx>certificate</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist."</p> <h3 id=fn-specingresstoportsoriginatingtlswithprivatekey>fn spec.ingress.toPorts.originatingTLS.withPrivateKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withPrivateKey</span><span class=p>(</span><span class=nx>privateKey</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist."</p> <h3 id=fn-specingresstoportsoriginatingtlswithtrustedca>fn spec.ingress.toPorts.originatingTLS.withTrustedCA</h3> <div class=highlight><pre><span></span><code><span class=nx>withTrustedCA</span><span class=p>(</span><span class=nx>trustedCA</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist."</p> <h2 id=obj-specingresstoportsoriginatingtlssecret>obj spec.ingress.toPorts.originatingTLS.secret</h2> <p>"Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt' - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate."</p> <h3 id=fn-specingresstoportsoriginatingtlssecretwithname>fn spec.ingress.toPorts.originatingTLS.secret.withName</h3> <div class=highlight><pre><span></span><code><span class=nx>withName</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Name is the name of the secret."</p> <h3 id=fn-specingresstoportsoriginatingtlssecretwithnamespace>fn spec.ingress.toPorts.originatingTLS.secret.withNamespace</h3> <div class=highlight><pre><span></span><code><span class=nx>withNamespace</span><span class=p>(</span><span class=nx>namespace</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\")."</p> <h2 id=obj-specingresstoportsports>obj spec.ingress.toPorts.ports</h2> <p>"Ports is a list of L4 port/protocol"</p> <h3 id=fn-specingresstoportsportswithport>fn spec.ingress.toPorts.ports.withPort</h3> <div class=highlight><pre><span></span><code><span class=nx>withPort</span><span class=p>(</span><span class=nx>port</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end."</p> <h3 id=fn-specingresstoportsportswithprotocol>fn spec.ingress.toPorts.ports.withProtocol</h3> <div class=highlight><pre><span></span><code><span class=nx>withProtocol</span><span class=p>(</span><span class=nx>protocol</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"\"/\"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this."</p> <h2 id=obj-specingresstoportsrules>obj spec.ingress.toPorts.rules</h2> <p>"Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced."</p> <h3 id=fn-specingresstoportsruleswithdns>fn spec.ingress.toPorts.rules.withDns</h3> <div class=highlight><pre><span></span><code><span class=nx>withDns</span><span class=p>(</span><span class=nx>dns</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"DNS-specific rules."</p> <h3 id=fn-specingresstoportsruleswithdnsmixin>fn spec.ingress.toPorts.rules.withDnsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withDnsMixin</span><span class=p>(</span><span class=nx>dns</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"DNS-specific rules."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specingresstoportsruleswithhttp>fn spec.ingress.toPorts.rules.withHttp</h3> <div class=highlight><pre><span></span><code><span class=nx>withHttp</span><span class=p>(</span><span class=nx>http</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"HTTP specific rules."</p> <h3 id=fn-specingresstoportsruleswithhttpmixin>fn spec.ingress.toPorts.rules.withHttpMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withHttpMixin</span><span class=p>(</span><span class=nx>http</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"HTTP specific rules."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specingresstoportsruleswithkafka>fn spec.ingress.toPorts.rules.withKafka</h3> <div class=highlight><pre><span></span><code><span class=nx>withKafka</span><span class=p>(</span><span class=nx>kafka</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Kafka-specific rules."</p> <h3 id=fn-specingresstoportsruleswithkafkamixin>fn spec.ingress.toPorts.rules.withKafkaMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withKafkaMixin</span><span class=p>(</span><span class=nx>kafka</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Kafka-specific rules."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specingresstoportsruleswithl7>fn spec.ingress.toPorts.rules.withL7</h3> <div class=highlight><pre><span></span><code><span class=nx>withL7</span><span class=p>(</span><span class=nx>l7</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Key-value pair rules."</p> <h3 id=fn-specingresstoportsruleswithl7mixin>fn spec.ingress.toPorts.rules.withL7Mixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withL7Mixin</span><span class=p>(</span><span class=nx>l7</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Key-value pair rules."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specingresstoportsruleswithl7proto>fn spec.ingress.toPorts.rules.withL7proto</h3> <div class=highlight><pre><span></span><code><span class=nx>withL7proto</span><span class=p>(</span><span class=nx>l7proto</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Name of the L7 protocol for which the Key-value pair rules apply."</p> <h2 id=obj-specingresstoportsrulesdns>obj spec.ingress.toPorts.rules.dns</h2> <p>"DNS-specific rules."</p> <h3 id=fn-specingresstoportsrulesdnswithmatchname>fn spec.ingress.toPorts.rules.dns.withMatchName</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchName</span><span class=p>(</span><span class=nx>matchName</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"MatchName matches literal DNS names. A trailing \".\" is automatically added when missing."</p> <h3 id=fn-specingresstoportsrulesdnswithmatchpattern>fn spec.ingress.toPorts.rules.dns.withMatchPattern</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchPattern</span><span class=p>(</span><span class=nx>matchPattern</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"<em>\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"</em>\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: <code>*.cilium.io</code> matches subomains of cilium at that level www.cilium.io and blog.cilium.io match, cilium.io and google.com do not <code>*cilium.io</code> matches cilium.io and all subdomains ends with \"cilium.io\" except those containing \".\" separator, subcilium.io and sub-cilium.io match, www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\" sub.cilium.io and subdomain.cilium.io match, www.cilium.io, blog.cilium.io, cilium.io and google.com do not"</p> <h2 id=obj-specingresstoportsruleshttp>obj spec.ingress.toPorts.rules.http</h2> <p>"HTTP specific rules."</p> <h3 id=fn-specingresstoportsruleshttpwithheadermatches>fn spec.ingress.toPorts.rules.http.withHeaderMatches</h3> <div class=highlight><pre><span></span><code><span class=nx>withHeaderMatches</span><span class=p>(</span><span class=nx>headerMatches</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match."</p> <h3 id=fn-specingresstoportsruleshttpwithheadermatchesmixin>fn spec.ingress.toPorts.rules.http.withHeaderMatchesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withHeaderMatchesMixin</span><span class=p>(</span><span class=nx>headerMatches</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specingresstoportsruleshttpwithheaders>fn spec.ingress.toPorts.rules.http.withHeaders</h3> <div class=highlight><pre><span></span><code><span class=nx>withHeaders</span><span class=p>(</span><span class=nx>headers</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present."</p> <h3 id=fn-specingresstoportsruleshttpwithheadersmixin>fn spec.ingress.toPorts.rules.http.withHeadersMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withHeadersMixin</span><span class=p>(</span><span class=nx>headers</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specingresstoportsruleshttpwithhost>fn spec.ingress.toPorts.rules.http.withHost</h3> <div class=highlight><pre><span></span><code><span class=nx>withHost</span><span class=p>(</span><span class=nx>host</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Host is an extended POSIX regex matched against the host header of a request, e.g. \"foo.com\" \n If omitted or empty, the value of the host header is ignored."</p> <h3 id=fn-specingresstoportsruleshttpwithmethod>fn spec.ingress.toPorts.rules.http.withMethod</h3> <div class=highlight><pre><span></span><code><span class=nx>withMethod</span><span class=p>(</span><span class=nx>method</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Method is an extended POSIX regex matched against the method of a request, e.g. \"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\", ... \n If omitted or empty, all methods are allowed."</p> <h3 id=fn-specingresstoportsruleshttpwithpath>fn spec.ingress.toPorts.rules.http.withPath</h3> <div class=highlight><pre><span></span><code><span class=nx>withPath</span><span class=p>(</span><span class=nx>path</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Path is an extended POSIX regex matched against the path of a request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986. \n If omitted or empty, all paths are all allowed."</p> <h2 id=obj-specingresstoportsruleshttpheadermatches>obj spec.ingress.toPorts.rules.http.headerMatches</h2> <p>"HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match."</p> <h3 id=fn-specingresstoportsruleshttpheadermatcheswithmismatch>fn spec.ingress.toPorts.rules.http.headerMatches.withMismatch</h3> <div class=highlight><pre><span></span><code><span class=nx>withMismatch</span><span class=p>(</span><span class=nx>mismatch</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log."</p> <h3 id=fn-specingresstoportsruleshttpheadermatcheswithname>fn spec.ingress.toPorts.rules.http.headerMatches.withName</h3> <div class=highlight><pre><span></span><code><span class=nx>withName</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Name identifies the header."</p> <h3 id=fn-specingresstoportsruleshttpheadermatcheswithvalue>fn spec.ingress.toPorts.rules.http.headerMatches.withValue</h3> <div class=highlight><pre><span></span><code><span class=nx>withValue</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Value matches the exact value of the header. Can be specified either alone or together with \"Secret\"; will be used as the header value if the secret can not be found in the latter case."</p> <h2 id=obj-specingresstoportsruleshttpheadermatchessecret>obj spec.ingress.toPorts.rules.http.headerMatches.secret</h2> <p>"Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no \"Value\" specified, the match will fail."</p> <h3 id=fn-specingresstoportsruleshttpheadermatchessecretwithname>fn spec.ingress.toPorts.rules.http.headerMatches.secret.withName</h3> <div class=highlight><pre><span></span><code><span class=nx>withName</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Name is the name of the secret."</p> <h3 id=fn-specingresstoportsruleshttpheadermatchessecretwithnamespace>fn spec.ingress.toPorts.rules.http.headerMatches.secret.withNamespace</h3> <div class=highlight><pre><span></span><code><span class=nx>withNamespace</span><span class=p>(</span><span class=nx>namespace</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\")."</p> <h2 id=obj-specingresstoportsruleskafka>obj spec.ingress.toPorts.rules.kafka</h2> <p>"Kafka-specific rules."</p> <h3 id=fn-specingresstoportsruleskafkawithapikey>fn spec.ingress.toPorts.rules.kafka.withApiKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withApiKey</span><span class=p>(</span><span class=nx>apiKey</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"APIKey is a case-insensitive string matched against the key of a request, e.g. \"produce\", \"fetch\", \"createtopic\", \"deletetopic\", et al Reference: https://kafka.apache.org/protocol#protocol_api_keys \n If omitted or empty, and if Role is not specified, then all keys are allowed."</p> <h3 id=fn-specingresstoportsruleskafkawithapiversion>fn spec.ingress.toPorts.rules.kafka.withApiVersion</h3> <div class=highlight><pre><span></span><code><span class=nx>withApiVersion</span><span class=p>(</span><span class=nx>apiVersion</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"APIVersion is the version matched against the api version of the Kafka message. If set, it has to be a string representing a positive integer. \n If omitted or empty, all versions are allowed."</p> <h3 id=fn-specingresstoportsruleskafkawithclientid>fn spec.ingress.toPorts.rules.kafka.withClientID</h3> <div class=highlight><pre><span></span><code><span class=nx>withClientID</span><span class=p>(</span><span class=nx>clientID</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ClientID is the client identifier as provided in the request. \n From Kafka protocol documentation: This is a user supplied identifier for the client application. The user can use any identifier they like and it will be used when logging errors, monitoring aggregates, etc. For example, one might want to monitor not just the requests per second overall, but the number coming from each client application (each of which could reside on multiple servers). This id acts as a logical grouping across all requests from a particular client. \n If omitted or empty, all client identifiers are allowed."</p> <h3 id=fn-specingresstoportsruleskafkawithrole>fn spec.ingress.toPorts.rules.kafka.withRole</h3> <div class=highlight><pre><span></span><code><span class=nx>withRole</span><span class=p>(</span><span class=nx>role</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as \"produce\" or \"consume\". A Role automatically expands into all APIKeys required to perform the specified higher-level operation. \n The following values are supported: - \"produce\": Allow producing to the topics specified in the rule - \"consume\": Allow consuming from the topics specified in the rule \n This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule. \n If omitted or empty, and if APIKey is not specified, then all keys are allowed."</p> <h3 id=fn-specingresstoportsruleskafkawithtopic>fn spec.ingress.toPorts.rules.kafka.withTopic</h3> <div class=highlight><pre><span></span><code><span class=nx>withTopic</span><span class=p>(</span><span class=nx>topic</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Topic is the topic name contained in the message. If a Kafka request contains multiple topics, then all topics must be allowed or the message will be rejected. \n This constraint is ignored if the matched request message type doesn't contain any topic. Maximum size of Topic can be 249 characters as per recent Kafka spec and allowed characters are a-z, A-Z, 0-9, -, . and _. \n Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10 version the length was changed from 255 to 249. For compatibility reasons we are using 255. \n If omitted or empty, all topics are allowed."</p> <h2 id=obj-specingresstoportsterminatingtls>obj spec.ingress.toPorts.terminatingTLS</h2> <p>"TerminatingTLS is the TLS context for the connection terminated by the L7 proxy. For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy."</p> <h3 id=fn-specingresstoportsterminatingtlswithcertificate>fn spec.ingress.toPorts.terminatingTLS.withCertificate</h3> <div class=highlight><pre><span></span><code><span class=nx>withCertificate</span><span class=p>(</span><span class=nx>certificate</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist."</p> <h3 id=fn-specingresstoportsterminatingtlswithprivatekey>fn spec.ingress.toPorts.terminatingTLS.withPrivateKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withPrivateKey</span><span class=p>(</span><span class=nx>privateKey</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist."</p> <h3 id=fn-specingresstoportsterminatingtlswithtrustedca>fn spec.ingress.toPorts.terminatingTLS.withTrustedCA</h3> <div class=highlight><pre><span></span><code><span class=nx>withTrustedCA</span><span class=p>(</span><span class=nx>trustedCA</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist."</p> <h2 id=obj-specingresstoportsterminatingtlssecret>obj spec.ingress.toPorts.terminatingTLS.secret</h2> <p>"Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt' - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate."</p> <h3 id=fn-specingresstoportsterminatingtlssecretwithname>fn spec.ingress.toPorts.terminatingTLS.secret.withName</h3> <div class=highlight><pre><span></span><code><span class=nx>withName</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Name is the name of the secret."</p> <h3 id=fn-specingresstoportsterminatingtlssecretwithnamespace>fn spec.ingress.toPorts.terminatingTLS.secret.withNamespace</h3> <div class=highlight><pre><span></span><code><span class=nx>withNamespace</span><span class=p>(</span><span class=nx>namespace</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\")."</p> <h2 id=obj-specingressdeny>obj spec.ingressDeny</h2> <p>"IngressDeny is a list of IngressDenyRule which are enforced at ingress. Any rule inserted here will by denied regardless of the allowed ingress rules in the 'ingress' field. If omitted or empty, this rule does not apply at ingress."</p> <h3 id=fn-specingressdenywithfromcidr>fn spec.ingressDeny.withFromCIDR</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromCIDR</span><span class=p>(</span><span class=nx>fromCIDR</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do <em>not</em> originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.3.9.1"</p> <h3 id=fn-specingressdenywithfromcidrmixin>fn spec.ingressDeny.withFromCIDRMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromCIDRMixin</span><span class=p>(</span><span class=nx>fromCIDR</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do <em>not</em> originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.3.9.1"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specingressdenywithfromcidrset>fn spec.ingressDeny.withFromCIDRSet</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromCIDRSet</span><span class=p>(</span><span class=nx>fromCIDRSet</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12."</p> <h3 id=fn-specingressdenywithfromcidrsetmixin>fn spec.ingressDeny.withFromCIDRSetMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromCIDRSetMixin</span><span class=p>(</span><span class=nx>fromCIDRSet</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specingressdenywithfromendpoints>fn spec.ingressDeny.withFromEndpoints</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromEndpoints</span><span class=p>(</span><span class=nx>fromEndpoints</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule. \n Example: Any endpoint with the label \"role=backend\" can be consumed by any endpoint carrying the label \"role=frontend\"."</p> <h3 id=fn-specingressdenywithfromendpointsmixin>fn spec.ingressDeny.withFromEndpointsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromEndpointsMixin</span><span class=p>(</span><span class=nx>fromEndpoints</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule. \n Example: Any endpoint with the label \"role=backend\" can be consumed by any endpoint carrying the label \"role=frontend\"."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specingressdenywithfromentities>fn spec.ingressDeny.withFromEntities</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromEntities</span><span class=p>(</span><span class=nx>fromEntities</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are <code>world</code>, <code>cluster</code> and <code>host</code>"</p> <h3 id=fn-specingressdenywithfromentitiesmixin>fn spec.ingressDeny.withFromEntitiesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromEntitiesMixin</span><span class=p>(</span><span class=nx>fromEntities</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are <code>world</code>, <code>cluster</code> and <code>host</code>"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specingressdenywithfromrequires>fn spec.ingressDeny.withFromRequires</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromRequires</span><span class=p>(</span><span class=nx>fromRequires</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires consuming endpoint to also carry the label \"team=A\"."</p> <h3 id=fn-specingressdenywithfromrequiresmixin>fn spec.ingressDeny.withFromRequiresMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromRequiresMixin</span><span class=p>(</span><span class=nx>fromRequires</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires consuming endpoint to also carry the label \"team=A\"."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specingressdenywithicmps>fn spec.ingressDeny.withIcmps</h3> <div class=highlight><pre><span></span><code><span class=nx>withIcmps</span><span class=p>(</span><span class=nx>icmps</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can not accept incoming type 8 ICMP connections."</p> <h3 id=fn-specingressdenywithicmpsmixin>fn spec.ingressDeny.withIcmpsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withIcmpsMixin</span><span class=p>(</span><span class=nx>icmps</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can not accept incoming type 8 ICMP connections."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specingressdenywithtoports>fn spec.ingressDeny.withToPorts</h3> <div class=highlight><pre><span></span><code><span class=nx>withToPorts</span><span class=p>(</span><span class=nx>toPorts</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can not accept incoming connections on port 80/tcp."</p> <h3 id=fn-specingressdenywithtoportsmixin>fn spec.ingressDeny.withToPortsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToPortsMixin</span><span class=p>(</span><span class=nx>toPorts</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can not accept incoming connections on port 80/tcp."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specingressdenyfromcidrset>obj spec.ingressDeny.fromCIDRSet</h2> <p>"FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12."</p> <h3 id=fn-specingressdenyfromcidrsetwithcidr>fn spec.ingressDeny.fromCIDRSet.withCidr</h3> <div class=highlight><pre><span></span><code><span class=nx>withCidr</span><span class=p>(</span><span class=nx>cidr</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"CIDR is a CIDR prefix / IP Block."</p> <h3 id=fn-specingressdenyfromcidrsetwithexcept>fn spec.ingressDeny.fromCIDRSet.withExcept</h3> <div class=highlight><pre><span></span><code><span class=nx>withExcept</span><span class=p>(</span><span class=nx>except</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules."</p> <h3 id=fn-specingressdenyfromcidrsetwithexceptmixin>fn spec.ingressDeny.fromCIDRSet.withExceptMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withExceptMixin</span><span class=p>(</span><span class=nx>except</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specingressdenyfromendpoints>obj spec.ingressDeny.fromEndpoints</h2> <p>"FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule. \n Example: Any endpoint with the label \"role=backend\" can be consumed by any endpoint carrying the label \"role=frontend\"."</p> <h3 id=fn-specingressdenyfromendpointswithmatchexpressions>fn spec.ingressDeny.fromEndpoints.withMatchExpressions</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressions</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specingressdenyfromendpointswithmatchexpressionsmixin>fn spec.ingressDeny.fromEndpoints.withMatchExpressionsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressionsMixin</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specingressdenyfromendpointswithmatchlabels>fn spec.ingressDeny.fromEndpoints.withMatchLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabels</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <h3 id=fn-specingressdenyfromendpointswithmatchlabelsmixin>fn spec.ingressDeny.fromEndpoints.withMatchLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabelsMixin</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specingressdenyfromendpointsmatchexpressions>obj spec.ingressDeny.fromEndpoints.matchExpressions</h2> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specingressdenyfromendpointsmatchexpressionswithkey>fn spec.ingressDeny.fromEndpoints.matchExpressions.withKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withKey</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"key is the label key that the selector applies to."</p> <h3 id=fn-specingressdenyfromendpointsmatchexpressionswithoperator>fn spec.ingressDeny.fromEndpoints.matchExpressions.withOperator</h3> <div class=highlight><pre><span></span><code><span class=nx>withOperator</span><span class=p>(</span><span class=nx>operator</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist."</p> <h3 id=fn-specingressdenyfromendpointsmatchexpressionswithvalues>fn spec.ingressDeny.fromEndpoints.matchExpressions.withValues</h3> <div class=highlight><pre><span></span><code><span class=nx>withValues</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <h3 id=fn-specingressdenyfromendpointsmatchexpressionswithvaluesmixin>fn spec.ingressDeny.fromEndpoints.matchExpressions.withValuesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withValuesMixin</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specingressdenyfromrequires>obj spec.ingressDeny.fromRequires</h2> <p>"FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires consuming endpoint to also carry the label \"team=A\"."</p> <h3 id=fn-specingressdenyfromrequireswithmatchexpressions>fn spec.ingressDeny.fromRequires.withMatchExpressions</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressions</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specingressdenyfromrequireswithmatchexpressionsmixin>fn spec.ingressDeny.fromRequires.withMatchExpressionsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressionsMixin</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specingressdenyfromrequireswithmatchlabels>fn spec.ingressDeny.fromRequires.withMatchLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabels</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <h3 id=fn-specingressdenyfromrequireswithmatchlabelsmixin>fn spec.ingressDeny.fromRequires.withMatchLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabelsMixin</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specingressdenyfromrequiresmatchexpressions>obj spec.ingressDeny.fromRequires.matchExpressions</h2> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specingressdenyfromrequiresmatchexpressionswithkey>fn spec.ingressDeny.fromRequires.matchExpressions.withKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withKey</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"key is the label key that the selector applies to."</p> <h3 id=fn-specingressdenyfromrequiresmatchexpressionswithoperator>fn spec.ingressDeny.fromRequires.matchExpressions.withOperator</h3> <div class=highlight><pre><span></span><code><span class=nx>withOperator</span><span class=p>(</span><span class=nx>operator</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist."</p> <h3 id=fn-specingressdenyfromrequiresmatchexpressionswithvalues>fn spec.ingressDeny.fromRequires.matchExpressions.withValues</h3> <div class=highlight><pre><span></span><code><span class=nx>withValues</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <h3 id=fn-specingressdenyfromrequiresmatchexpressionswithvaluesmixin>fn spec.ingressDeny.fromRequires.matchExpressions.withValuesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withValuesMixin</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specingressdenyicmps>obj spec.ingressDeny.icmps</h2> <p>"ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can not accept incoming type 8 ICMP connections."</p> <h3 id=fn-specingressdenyicmpswithfields>fn spec.ingressDeny.icmps.withFields</h3> <div class=highlight><pre><span></span><code><span class=nx>withFields</span><span class=p>(</span><span class=nx>fields</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Fields is a list of ICMP fields."</p> <h3 id=fn-specingressdenyicmpswithfieldsmixin>fn spec.ingressDeny.icmps.withFieldsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withFieldsMixin</span><span class=p>(</span><span class=nx>fields</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Fields is a list of ICMP fields."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specingressdenyicmpsfields>obj spec.ingressDeny.icmps.fields</h2> <p>"Fields is a list of ICMP fields."</p> <h3 id=fn-specingressdenyicmpsfieldswithfamily>fn spec.ingressDeny.icmps.fields.withFamily</h3> <div class=highlight><pre><span></span><code><span class=nx>withFamily</span><span class=p>(</span><span class=nx>family</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Family is a IP address version. Currently, we support <code>IPv4</code> and <code>IPv6</code>. <code>IPv4</code> is set as default."</p> <h3 id=fn-specingressdenyicmpsfieldswithtype>fn spec.ingressDeny.icmps.fields.withType</h3> <div class=highlight><pre><span></span><code><span class=nx>withType</span><span class=p>(</span><span class=kr>type</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Type is a ICMP-type. It should be 0-255 (8bit)."</p> <h2 id=obj-specingressdenytoports>obj spec.ingressDeny.toPorts</h2> <p>"ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can not accept incoming connections on port 80/tcp."</p> <h3 id=fn-specingressdenytoportswithports>fn spec.ingressDeny.toPorts.withPorts</h3> <div class=highlight><pre><span></span><code><span class=nx>withPorts</span><span class=p>(</span><span class=nx>ports</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Ports is a list of L4 port/protocol"</p> <h3 id=fn-specingressdenytoportswithportsmixin>fn spec.ingressDeny.toPorts.withPortsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withPortsMixin</span><span class=p>(</span><span class=nx>ports</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Ports is a list of L4 port/protocol"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specingressdenytoportsports>obj spec.ingressDeny.toPorts.ports</h2> <p>"Ports is a list of L4 port/protocol"</p> <h3 id=fn-specingressdenytoportsportswithport>fn spec.ingressDeny.toPorts.ports.withPort</h3> <div class=highlight><pre><span></span><code><span class=nx>withPort</span><span class=p>(</span><span class=nx>port</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end."</p> <h3 id=fn-specingressdenytoportsportswithprotocol>fn spec.ingressDeny.toPorts.ports.withProtocol</h3> <div class=highlight><pre><span></span><code><span class=nx>withProtocol</span><span class=p>(</span><span class=nx>protocol</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"\"/\"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this."</p> <h2 id=obj-speclabels>obj spec.labels</h2> <p>"Labels is a list of optional strings which can be used to re-identify the rule or to store metadata. It is possible to lookup or delete strings based on labels. Labels are not required to be unique, multiple rules can have overlapping or identical labels."</p> <h3 id=fn-speclabelswithkey>fn spec.labels.withKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withKey</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h3 id=fn-speclabelswithsource>fn spec.labels.withSource</h3> <div class=highlight><pre><span></span><code><span class=nx>withSource</span><span class=p>(</span><span class=nx>source</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Source can be one of the above values (e.g.: LabelSourceContainer)."</p> <h3 id=fn-speclabelswithvalue>fn spec.labels.withValue</h3> <div class=highlight><pre><span></span><code><span class=nx>withValue</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h2 id=obj-specnodeselector>obj spec.nodeSelector</h2> <p>"NodeSelector selects all nodes which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive. Can only be used in CiliumClusterwideNetworkPolicies."</p> <h3 id=fn-specnodeselectorwithmatchexpressions>fn spec.nodeSelector.withMatchExpressions</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressions</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specnodeselectorwithmatchexpressionsmixin>fn spec.nodeSelector.withMatchExpressionsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressionsMixin</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specnodeselectorwithmatchlabels>fn spec.nodeSelector.withMatchLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabels</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <h3 id=fn-specnodeselectorwithmatchlabelsmixin>fn spec.nodeSelector.withMatchLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabelsMixin</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specnodeselectormatchexpressions>obj spec.nodeSelector.matchExpressions</h2> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specnodeselectormatchexpressionswithkey>fn spec.nodeSelector.matchExpressions.withKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withKey</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"key is the label key that the selector applies to."</p> <h3 id=fn-specnodeselectormatchexpressionswithoperator>fn spec.nodeSelector.matchExpressions.withOperator</h3> <div class=highlight><pre><span></span><code><span class=nx>withOperator</span><span class=p>(</span><span class=nx>operator</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist."</p> <h3 id=fn-specnodeselectormatchexpressionswithvalues>fn spec.nodeSelector.matchExpressions.withValues</h3> <div class=highlight><pre><span></span><code><span class=nx>withValues</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <h3 id=fn-specnodeselectormatchexpressionswithvaluesmixin>fn spec.nodeSelector.matchExpressions.withValuesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withValuesMixin</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specs>obj specs</h2> <p>"Specs is a list of desired Cilium specific rule specification."</p> <h3 id=fn-specswithdescription>fn specs.withDescription</h3> <div class=highlight><pre><span></span><code><span class=nx>withDescription</span><span class=p>(</span><span class=nx>description</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Description is a free form string, it can be used by the creator of the rule to store human readable explanation of the purpose of this rule. Rules cannot be identified by comment."</p> <h3 id=fn-specswithegress>fn specs.withEgress</h3> <div class=highlight><pre><span></span><code><span class=nx>withEgress</span><span class=p>(</span><span class=nx>egress</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Egress is a list of EgressRule which are enforced at egress. If omitted or empty, this rule does not apply at egress."</p> <h3 id=fn-specswithegressdeny>fn specs.withEgressDeny</h3> <div class=highlight><pre><span></span><code><span class=nx>withEgressDeny</span><span class=p>(</span><span class=nx>egressDeny</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"EgressDeny is a list of EgressDenyRule which are enforced at egress. Any rule inserted here will by denied regardless of the allowed egress rules in the 'egress' field. If omitted or empty, this rule does not apply at egress."</p> <h3 id=fn-specswithegressdenymixin>fn specs.withEgressDenyMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withEgressDenyMixin</span><span class=p>(</span><span class=nx>egressDeny</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"EgressDeny is a list of EgressDenyRule which are enforced at egress. Any rule inserted here will by denied regardless of the allowed egress rules in the 'egress' field. If omitted or empty, this rule does not apply at egress."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specswithegressmixin>fn specs.withEgressMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withEgressMixin</span><span class=p>(</span><span class=nx>egress</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Egress is a list of EgressRule which are enforced at egress. If omitted or empty, this rule does not apply at egress."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specswithingress>fn specs.withIngress</h3> <div class=highlight><pre><span></span><code><span class=nx>withIngress</span><span class=p>(</span><span class=nx>ingress</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Ingress is a list of IngressRule which are enforced at ingress. If omitted or empty, this rule does not apply at ingress."</p> <h3 id=fn-specswithingressdeny>fn specs.withIngressDeny</h3> <div class=highlight><pre><span></span><code><span class=nx>withIngressDeny</span><span class=p>(</span><span class=nx>ingressDeny</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"IngressDeny is a list of IngressDenyRule which are enforced at ingress. Any rule inserted here will by denied regardless of the allowed ingress rules in the 'ingress' field. If omitted or empty, this rule does not apply at ingress."</p> <h3 id=fn-specswithingressdenymixin>fn specs.withIngressDenyMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withIngressDenyMixin</span><span class=p>(</span><span class=nx>ingressDeny</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"IngressDeny is a list of IngressDenyRule which are enforced at ingress. Any rule inserted here will by denied regardless of the allowed ingress rules in the 'ingress' field. If omitted or empty, this rule does not apply at ingress."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specswithingressmixin>fn specs.withIngressMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withIngressMixin</span><span class=p>(</span><span class=nx>ingress</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Ingress is a list of IngressRule which are enforced at ingress. If omitted or empty, this rule does not apply at ingress."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specswithlabels>fn specs.withLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withLabels</span><span class=p>(</span><span class=nx>labels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Labels is a list of optional strings which can be used to re-identify the rule or to store metadata. It is possible to lookup or delete strings based on labels. Labels are not required to be unique, multiple rules can have overlapping or identical labels."</p> <h3 id=fn-specswithlabelsmixin>fn specs.withLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withLabelsMixin</span><span class=p>(</span><span class=nx>labels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Labels is a list of optional strings which can be used to re-identify the rule or to store metadata. It is possible to lookup or delete strings based on labels. Labels are not required to be unique, multiple rules can have overlapping or identical labels."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsegress>obj specs.egress</h2> <p>"Egress is a list of EgressRule which are enforced at egress. If omitted or empty, this rule does not apply at egress."</p> <h3 id=fn-specsegresswithicmps>fn specs.egress.withIcmps</h3> <div class=highlight><pre><span></span><code><span class=nx>withIcmps</span><span class=p>(</span><span class=nx>icmps</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to connect to. \n Example: Any endpoint with the label \"app=httpd\" is allowed to initiate type 8 ICMP connections."</p> <h3 id=fn-specsegresswithicmpsmixin>fn specs.egress.withIcmpsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withIcmpsMixin</span><span class=p>(</span><span class=nx>icmps</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to connect to. \n Example: Any endpoint with the label \"app=httpd\" is allowed to initiate type 8 ICMP connections."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegresswithtocidr>fn specs.egress.withToCIDR</h3> <div class=highlight><pre><span></span><code><span class=nx>withToCIDR</span><span class=p>(</span><span class=nx>toCIDR</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24"</p> <h3 id=fn-specsegresswithtocidrmixin>fn specs.egress.withToCIDRMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToCIDRMixin</span><span class=p>(</span><span class=nx>toCIDR</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegresswithtocidrset>fn specs.egress.withToCIDRSet</h3> <div class=highlight><pre><span></span><code><span class=nx>withToCIDRSet</span><span class=p>(</span><span class=nx>toCIDRSet</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28."</p> <h3 id=fn-specsegresswithtocidrsetmixin>fn specs.egress.withToCIDRSetMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToCIDRSetMixin</span><span class=p>(</span><span class=nx>toCIDRSet</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegresswithtoendpoints>fn specs.egress.withToEndpoints</h3> <div class=highlight><pre><span></span><code><span class=nx>withToEndpoints</span><span class=p>(</span><span class=nx>toEndpoints</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate. \n Example: Any endpoint with the label \"role=frontend\" can communicate with any endpoint carrying the label \"role=backend\"."</p> <h3 id=fn-specsegresswithtoendpointsmixin>fn specs.egress.withToEndpointsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToEndpointsMixin</span><span class=p>(</span><span class=nx>toEndpoints</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate. \n Example: Any endpoint with the label \"role=frontend\" can communicate with any endpoint carrying the label \"role=backend\"."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegresswithtoentities>fn specs.egress.withToEntities</h3> <div class=highlight><pre><span></span><code><span class=nx>withToEntities</span><span class=p>(</span><span class=nx>toEntities</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are <code>world</code>, <code>cluster</code> and <code>host</code>"</p> <h3 id=fn-specsegresswithtoentitiesmixin>fn specs.egress.withToEntitiesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToEntitiesMixin</span><span class=p>(</span><span class=nx>toEntities</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are <code>world</code>, <code>cluster</code> and <code>host</code>"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegresswithtofqdns>fn specs.egress.withToFQDNs</h3> <div class=highlight><pre><span></span><code><span class=nx>withToFQDNs</span><span class=p>(</span><span class=nx>toFQDNs</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToFQDN allows whitelisting DNS names in place of IPs. The IPs that result from DNS resolution of <code>ToFQDN.MatchName</code>s are added to the same EgressRule object as ToCIDRSet entries, and behave accordingly. Any L4 and L7 rules within this EgressRule will also apply to these IPs. The DNS -&gt; IP mapping is re-resolved periodically from within the cilium-agent, and the IPs in the DNS response are effected in the policy for selected pods as-is (i.e. the list of IPs is not modified in any way). Note: An explicit rule to allow for DNS traffic is needed for the pods, as ToFQDN counts as an egress rule and will enforce egress policy when PolicyEnforcment=default. Note: If the resolved IPs are IPs within the kubernetes cluster, the ToFQDN rule will not apply to that IP. Note: ToFQDN cannot occur in the same policy as other To* rules. \n The current implementation has a number of limitations: - The DNS resolution originates from cilium-agent, and not from the pods. Differences between the responses seen by cilium agent and a particular pod will whitelist the incorrect IP. - DNS TTLs are ignored, and cilium-agent will repoll on a short interval (5 seconds). Each change to the DNS data will trigger a policy regeneration. This may result in delayed updates to the policy for an endpoint when the data changes often or the system is under load."</p> <h3 id=fn-specsegresswithtofqdnsmixin>fn specs.egress.withToFQDNsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToFQDNsMixin</span><span class=p>(</span><span class=nx>toFQDNs</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToFQDN allows whitelisting DNS names in place of IPs. The IPs that result from DNS resolution of <code>ToFQDN.MatchName</code>s are added to the same EgressRule object as ToCIDRSet entries, and behave accordingly. Any L4 and L7 rules within this EgressRule will also apply to these IPs. The DNS -&gt; IP mapping is re-resolved periodically from within the cilium-agent, and the IPs in the DNS response are effected in the policy for selected pods as-is (i.e. the list of IPs is not modified in any way). Note: An explicit rule to allow for DNS traffic is needed for the pods, as ToFQDN counts as an egress rule and will enforce egress policy when PolicyEnforcment=default. Note: If the resolved IPs are IPs within the kubernetes cluster, the ToFQDN rule will not apply to that IP. Note: ToFQDN cannot occur in the same policy as other To* rules. \n The current implementation has a number of limitations: - The DNS resolution originates from cilium-agent, and not from the pods. Differences between the responses seen by cilium agent and a particular pod will whitelist the incorrect IP. - DNS TTLs are ignored, and cilium-agent will repoll on a short interval (5 seconds). Each change to the DNS data will trigger a policy regeneration. This may result in delayed updates to the policy for an endpoint when the data changes often or the system is under load."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegresswithtogroups>fn specs.egress.withToGroups</h3> <div class=highlight><pre><span></span><code><span class=nx>withToGroups</span><span class=p>(</span><span class=nx>toGroups</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives: \n Example: toGroups: - aws: securityGroupsIds: - 'sg-XXXXXXXXXXXXX'"</p> <h3 id=fn-specsegresswithtogroupsmixin>fn specs.egress.withToGroupsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToGroupsMixin</span><span class=p>(</span><span class=nx>toGroups</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives: \n Example: toGroups: - aws: securityGroupsIds: - 'sg-XXXXXXXXXXXXX'"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegresswithtoports>fn specs.egress.withToPorts</h3> <div class=highlight><pre><span></span><code><span class=nx>withToPorts</span><span class=p>(</span><span class=nx>toPorts</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to connect to. \n Example: Any endpoint with the label \"role=frontend\" is allowed to initiate connections to destination port 8080/tcp"</p> <h3 id=fn-specsegresswithtoportsmixin>fn specs.egress.withToPortsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToPortsMixin</span><span class=p>(</span><span class=nx>toPorts</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to connect to. \n Example: Any endpoint with the label \"role=frontend\" is allowed to initiate connections to destination port 8080/tcp"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegresswithtorequires>fn specs.egress.withToRequires</h3> <div class=highlight><pre><span></span><code><span class=nx>withToRequires</span><span class=p>(</span><span class=nx>toRequires</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires any endpoint to which it communicates to also carry the label \"team=A\"."</p> <h3 id=fn-specsegresswithtorequiresmixin>fn specs.egress.withToRequiresMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToRequiresMixin</span><span class=p>(</span><span class=nx>toRequires</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires any endpoint to which it communicates to also carry the label \"team=A\"."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegresswithtoservices>fn specs.egress.withToServices</h3> <div class=highlight><pre><span></span><code><span class=nx>withToServices</span><span class=p>(</span><span class=nx>toServices</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors. \n Example: Any endpoint with the label \"app=backend-app\" is allowed to initiate connections to all cidrs backing the \"external-service\" service"</p> <h3 id=fn-specsegresswithtoservicesmixin>fn specs.egress.withToServicesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToServicesMixin</span><span class=p>(</span><span class=nx>toServices</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors. \n Example: Any endpoint with the label \"app=backend-app\" is allowed to initiate connections to all cidrs backing the \"external-service\" service"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsegressicmps>obj specs.egress.icmps</h2> <p>"ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to connect to. \n Example: Any endpoint with the label \"app=httpd\" is allowed to initiate type 8 ICMP connections."</p> <h3 id=fn-specsegressicmpswithfields>fn specs.egress.icmps.withFields</h3> <div class=highlight><pre><span></span><code><span class=nx>withFields</span><span class=p>(</span><span class=nx>fields</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Fields is a list of ICMP fields."</p> <h3 id=fn-specsegressicmpswithfieldsmixin>fn specs.egress.icmps.withFieldsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withFieldsMixin</span><span class=p>(</span><span class=nx>fields</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Fields is a list of ICMP fields."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsegressicmpsfields>obj specs.egress.icmps.fields</h2> <p>"Fields is a list of ICMP fields."</p> <h3 id=fn-specsegressicmpsfieldswithfamily>fn specs.egress.icmps.fields.withFamily</h3> <div class=highlight><pre><span></span><code><span class=nx>withFamily</span><span class=p>(</span><span class=nx>family</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Family is a IP address version. Currently, we support <code>IPv4</code> and <code>IPv6</code>. <code>IPv4</code> is set as default."</p> <h3 id=fn-specsegressicmpsfieldswithtype>fn specs.egress.icmps.fields.withType</h3> <div class=highlight><pre><span></span><code><span class=nx>withType</span><span class=p>(</span><span class=kr>type</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Type is a ICMP-type. It should be 0-255 (8bit)."</p> <h2 id=obj-specsegresstocidrset>obj specs.egress.toCIDRSet</h2> <p>"ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28."</p> <h3 id=fn-specsegresstocidrsetwithcidr>fn specs.egress.toCIDRSet.withCidr</h3> <div class=highlight><pre><span></span><code><span class=nx>withCidr</span><span class=p>(</span><span class=nx>cidr</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"CIDR is a CIDR prefix / IP Block."</p> <h3 id=fn-specsegresstocidrsetwithexcept>fn specs.egress.toCIDRSet.withExcept</h3> <div class=highlight><pre><span></span><code><span class=nx>withExcept</span><span class=p>(</span><span class=nx>except</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules."</p> <h3 id=fn-specsegresstocidrsetwithexceptmixin>fn specs.egress.toCIDRSet.withExceptMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withExceptMixin</span><span class=p>(</span><span class=nx>except</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsegresstoendpoints>obj specs.egress.toEndpoints</h2> <p>"ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate. \n Example: Any endpoint with the label \"role=frontend\" can communicate with any endpoint carrying the label \"role=backend\"."</p> <h3 id=fn-specsegresstoendpointswithmatchexpressions>fn specs.egress.toEndpoints.withMatchExpressions</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressions</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specsegresstoendpointswithmatchexpressionsmixin>fn specs.egress.toEndpoints.withMatchExpressionsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressionsMixin</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegresstoendpointswithmatchlabels>fn specs.egress.toEndpoints.withMatchLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabels</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <h3 id=fn-specsegresstoendpointswithmatchlabelsmixin>fn specs.egress.toEndpoints.withMatchLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabelsMixin</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsegresstoendpointsmatchexpressions>obj specs.egress.toEndpoints.matchExpressions</h2> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specsegresstoendpointsmatchexpressionswithkey>fn specs.egress.toEndpoints.matchExpressions.withKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withKey</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"key is the label key that the selector applies to."</p> <h3 id=fn-specsegresstoendpointsmatchexpressionswithoperator>fn specs.egress.toEndpoints.matchExpressions.withOperator</h3> <div class=highlight><pre><span></span><code><span class=nx>withOperator</span><span class=p>(</span><span class=nx>operator</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist."</p> <h3 id=fn-specsegresstoendpointsmatchexpressionswithvalues>fn specs.egress.toEndpoints.matchExpressions.withValues</h3> <div class=highlight><pre><span></span><code><span class=nx>withValues</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <h3 id=fn-specsegresstoendpointsmatchexpressionswithvaluesmixin>fn specs.egress.toEndpoints.matchExpressions.withValuesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withValuesMixin</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsegresstofqdns>obj specs.egress.toFQDNs</h2> <p>"ToFQDN allows whitelisting DNS names in place of IPs. The IPs that result from DNS resolution of <code>ToFQDN.MatchName</code>s are added to the same EgressRule object as ToCIDRSet entries, and behave accordingly. Any L4 and L7 rules within this EgressRule will also apply to these IPs. The DNS -&gt; IP mapping is re-resolved periodically from within the cilium-agent, and the IPs in the DNS response are effected in the policy for selected pods as-is (i.e. the list of IPs is not modified in any way). Note: An explicit rule to allow for DNS traffic is needed for the pods, as ToFQDN counts as an egress rule and will enforce egress policy when PolicyEnforcment=default. Note: If the resolved IPs are IPs within the kubernetes cluster, the ToFQDN rule will not apply to that IP. Note: ToFQDN cannot occur in the same policy as other To* rules. \n The current implementation has a number of limitations: - The DNS resolution originates from cilium-agent, and not from the pods. Differences between the responses seen by cilium agent and a particular pod will whitelist the incorrect IP. - DNS TTLs are ignored, and cilium-agent will repoll on a short interval (5 seconds). Each change to the DNS data will trigger a policy regeneration. This may result in delayed updates to the policy for an endpoint when the data changes often or the system is under load."</p> <h3 id=fn-specsegresstofqdnswithmatchname>fn specs.egress.toFQDNs.withMatchName</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchName</span><span class=p>(</span><span class=nx>matchName</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"MatchName matches literal DNS names. A trailing \".\" is automatically added when missing."</p> <h3 id=fn-specsegresstofqdnswithmatchpattern>fn specs.egress.toFQDNs.withMatchPattern</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchPattern</span><span class=p>(</span><span class=nx>matchPattern</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"<em>\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"</em>\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: <code>*.cilium.io</code> matches subomains of cilium at that level www.cilium.io and blog.cilium.io match, cilium.io and google.com do not <code>*cilium.io</code> matches cilium.io and all subdomains ends with \"cilium.io\" except those containing \".\" separator, subcilium.io and sub-cilium.io match, www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\" sub.cilium.io and subdomain.cilium.io match, www.cilium.io, blog.cilium.io, cilium.io and google.com do not"</p> <h2 id=obj-specsegresstogroups>obj specs.egress.toGroups</h2> <p>"ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives: \n Example: toGroups: - aws: securityGroupsIds: - 'sg-XXXXXXXXXXXXX'"</p> <h2 id=obj-specsegresstogroupsaws>obj specs.egress.toGroups.aws</h2> <p>"AWSGroup is an structure that can be used to whitelisting information from AWS integration"</p> <h3 id=fn-specsegresstogroupsawswithlabels>fn specs.egress.toGroups.aws.withLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withLabels</span><span class=p>(</span><span class=nx>labels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h3 id=fn-specsegresstogroupsawswithlabelsmixin>fn specs.egress.toGroups.aws.withLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withLabelsMixin</span><span class=p>(</span><span class=nx>labels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegresstogroupsawswithregion>fn specs.egress.toGroups.aws.withRegion</h3> <div class=highlight><pre><span></span><code><span class=nx>withRegion</span><span class=p>(</span><span class=nx>region</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h3 id=fn-specsegresstogroupsawswithsecuritygroupsids>fn specs.egress.toGroups.aws.withSecurityGroupsIds</h3> <div class=highlight><pre><span></span><code><span class=nx>withSecurityGroupsIds</span><span class=p>(</span><span class=nx>securityGroupsIds</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h3 id=fn-specsegresstogroupsawswithsecuritygroupsidsmixin>fn specs.egress.toGroups.aws.withSecurityGroupsIdsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withSecurityGroupsIdsMixin</span><span class=p>(</span><span class=nx>securityGroupsIds</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegresstogroupsawswithsecuritygroupsnames>fn specs.egress.toGroups.aws.withSecurityGroupsNames</h3> <div class=highlight><pre><span></span><code><span class=nx>withSecurityGroupsNames</span><span class=p>(</span><span class=nx>securityGroupsNames</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h3 id=fn-specsegresstogroupsawswithsecuritygroupsnamesmixin>fn specs.egress.toGroups.aws.withSecurityGroupsNamesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withSecurityGroupsNamesMixin</span><span class=p>(</span><span class=nx>securityGroupsNames</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsegresstoports>obj specs.egress.toPorts</h2> <p>"ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to connect to. \n Example: Any endpoint with the label \"role=frontend\" is allowed to initiate connections to destination port 8080/tcp"</p> <h3 id=fn-specsegresstoportswithports>fn specs.egress.toPorts.withPorts</h3> <div class=highlight><pre><span></span><code><span class=nx>withPorts</span><span class=p>(</span><span class=nx>ports</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Ports is a list of L4 port/protocol"</p> <h3 id=fn-specsegresstoportswithportsmixin>fn specs.egress.toPorts.withPortsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withPortsMixin</span><span class=p>(</span><span class=nx>ports</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Ports is a list of L4 port/protocol"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsegresstoportsoriginatingtls>obj specs.egress.toPorts.originatingTLS</h2> <p>"OriginatingTLS is the TLS context for the connections originated by the L7 proxy. For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint."</p> <h3 id=fn-specsegresstoportsoriginatingtlswithcertificate>fn specs.egress.toPorts.originatingTLS.withCertificate</h3> <div class=highlight><pre><span></span><code><span class=nx>withCertificate</span><span class=p>(</span><span class=nx>certificate</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist."</p> <h3 id=fn-specsegresstoportsoriginatingtlswithprivatekey>fn specs.egress.toPorts.originatingTLS.withPrivateKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withPrivateKey</span><span class=p>(</span><span class=nx>privateKey</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist."</p> <h3 id=fn-specsegresstoportsoriginatingtlswithtrustedca>fn specs.egress.toPorts.originatingTLS.withTrustedCA</h3> <div class=highlight><pre><span></span><code><span class=nx>withTrustedCA</span><span class=p>(</span><span class=nx>trustedCA</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist."</p> <h2 id=obj-specsegresstoportsoriginatingtlssecret>obj specs.egress.toPorts.originatingTLS.secret</h2> <p>"Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt' - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate."</p> <h3 id=fn-specsegresstoportsoriginatingtlssecretwithname>fn specs.egress.toPorts.originatingTLS.secret.withName</h3> <div class=highlight><pre><span></span><code><span class=nx>withName</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Name is the name of the secret."</p> <h3 id=fn-specsegresstoportsoriginatingtlssecretwithnamespace>fn specs.egress.toPorts.originatingTLS.secret.withNamespace</h3> <div class=highlight><pre><span></span><code><span class=nx>withNamespace</span><span class=p>(</span><span class=nx>namespace</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\")."</p> <h2 id=obj-specsegresstoportsports>obj specs.egress.toPorts.ports</h2> <p>"Ports is a list of L4 port/protocol"</p> <h3 id=fn-specsegresstoportsportswithport>fn specs.egress.toPorts.ports.withPort</h3> <div class=highlight><pre><span></span><code><span class=nx>withPort</span><span class=p>(</span><span class=nx>port</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end."</p> <h3 id=fn-specsegresstoportsportswithprotocol>fn specs.egress.toPorts.ports.withProtocol</h3> <div class=highlight><pre><span></span><code><span class=nx>withProtocol</span><span class=p>(</span><span class=nx>protocol</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"\"/\"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this."</p> <h2 id=obj-specsegresstoportsrules>obj specs.egress.toPorts.rules</h2> <p>"Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced."</p> <h3 id=fn-specsegresstoportsruleswithdns>fn specs.egress.toPorts.rules.withDns</h3> <div class=highlight><pre><span></span><code><span class=nx>withDns</span><span class=p>(</span><span class=nx>dns</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"DNS-specific rules."</p> <h3 id=fn-specsegresstoportsruleswithdnsmixin>fn specs.egress.toPorts.rules.withDnsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withDnsMixin</span><span class=p>(</span><span class=nx>dns</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"DNS-specific rules."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegresstoportsruleswithhttp>fn specs.egress.toPorts.rules.withHttp</h3> <div class=highlight><pre><span></span><code><span class=nx>withHttp</span><span class=p>(</span><span class=nx>http</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"HTTP specific rules."</p> <h3 id=fn-specsegresstoportsruleswithhttpmixin>fn specs.egress.toPorts.rules.withHttpMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withHttpMixin</span><span class=p>(</span><span class=nx>http</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"HTTP specific rules."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegresstoportsruleswithkafka>fn specs.egress.toPorts.rules.withKafka</h3> <div class=highlight><pre><span></span><code><span class=nx>withKafka</span><span class=p>(</span><span class=nx>kafka</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Kafka-specific rules."</p> <h3 id=fn-specsegresstoportsruleswithkafkamixin>fn specs.egress.toPorts.rules.withKafkaMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withKafkaMixin</span><span class=p>(</span><span class=nx>kafka</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Kafka-specific rules."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegresstoportsruleswithl7>fn specs.egress.toPorts.rules.withL7</h3> <div class=highlight><pre><span></span><code><span class=nx>withL7</span><span class=p>(</span><span class=nx>l7</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Key-value pair rules."</p> <h3 id=fn-specsegresstoportsruleswithl7mixin>fn specs.egress.toPorts.rules.withL7Mixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withL7Mixin</span><span class=p>(</span><span class=nx>l7</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Key-value pair rules."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegresstoportsruleswithl7proto>fn specs.egress.toPorts.rules.withL7proto</h3> <div class=highlight><pre><span></span><code><span class=nx>withL7proto</span><span class=p>(</span><span class=nx>l7proto</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Name of the L7 protocol for which the Key-value pair rules apply."</p> <h2 id=obj-specsegresstoportsrulesdns>obj specs.egress.toPorts.rules.dns</h2> <p>"DNS-specific rules."</p> <h3 id=fn-specsegresstoportsrulesdnswithmatchname>fn specs.egress.toPorts.rules.dns.withMatchName</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchName</span><span class=p>(</span><span class=nx>matchName</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"MatchName matches literal DNS names. A trailing \".\" is automatically added when missing."</p> <h3 id=fn-specsegresstoportsrulesdnswithmatchpattern>fn specs.egress.toPorts.rules.dns.withMatchPattern</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchPattern</span><span class=p>(</span><span class=nx>matchPattern</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"<em>\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"</em>\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: <code>*.cilium.io</code> matches subomains of cilium at that level www.cilium.io and blog.cilium.io match, cilium.io and google.com do not <code>*cilium.io</code> matches cilium.io and all subdomains ends with \"cilium.io\" except those containing \".\" separator, subcilium.io and sub-cilium.io match, www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\" sub.cilium.io and subdomain.cilium.io match, www.cilium.io, blog.cilium.io, cilium.io and google.com do not"</p> <h2 id=obj-specsegresstoportsruleshttp>obj specs.egress.toPorts.rules.http</h2> <p>"HTTP specific rules."</p> <h3 id=fn-specsegresstoportsruleshttpwithheadermatches>fn specs.egress.toPorts.rules.http.withHeaderMatches</h3> <div class=highlight><pre><span></span><code><span class=nx>withHeaderMatches</span><span class=p>(</span><span class=nx>headerMatches</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match."</p> <h3 id=fn-specsegresstoportsruleshttpwithheadermatchesmixin>fn specs.egress.toPorts.rules.http.withHeaderMatchesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withHeaderMatchesMixin</span><span class=p>(</span><span class=nx>headerMatches</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegresstoportsruleshttpwithheaders>fn specs.egress.toPorts.rules.http.withHeaders</h3> <div class=highlight><pre><span></span><code><span class=nx>withHeaders</span><span class=p>(</span><span class=nx>headers</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present."</p> <h3 id=fn-specsegresstoportsruleshttpwithheadersmixin>fn specs.egress.toPorts.rules.http.withHeadersMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withHeadersMixin</span><span class=p>(</span><span class=nx>headers</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegresstoportsruleshttpwithhost>fn specs.egress.toPorts.rules.http.withHost</h3> <div class=highlight><pre><span></span><code><span class=nx>withHost</span><span class=p>(</span><span class=nx>host</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Host is an extended POSIX regex matched against the host header of a request, e.g. \"foo.com\" \n If omitted or empty, the value of the host header is ignored."</p> <h3 id=fn-specsegresstoportsruleshttpwithmethod>fn specs.egress.toPorts.rules.http.withMethod</h3> <div class=highlight><pre><span></span><code><span class=nx>withMethod</span><span class=p>(</span><span class=nx>method</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Method is an extended POSIX regex matched against the method of a request, e.g. \"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\", ... \n If omitted or empty, all methods are allowed."</p> <h3 id=fn-specsegresstoportsruleshttpwithpath>fn specs.egress.toPorts.rules.http.withPath</h3> <div class=highlight><pre><span></span><code><span class=nx>withPath</span><span class=p>(</span><span class=nx>path</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Path is an extended POSIX regex matched against the path of a request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986. \n If omitted or empty, all paths are all allowed."</p> <h2 id=obj-specsegresstoportsruleshttpheadermatches>obj specs.egress.toPorts.rules.http.headerMatches</h2> <p>"HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match."</p> <h3 id=fn-specsegresstoportsruleshttpheadermatcheswithmismatch>fn specs.egress.toPorts.rules.http.headerMatches.withMismatch</h3> <div class=highlight><pre><span></span><code><span class=nx>withMismatch</span><span class=p>(</span><span class=nx>mismatch</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log."</p> <h3 id=fn-specsegresstoportsruleshttpheadermatcheswithname>fn specs.egress.toPorts.rules.http.headerMatches.withName</h3> <div class=highlight><pre><span></span><code><span class=nx>withName</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Name identifies the header."</p> <h3 id=fn-specsegresstoportsruleshttpheadermatcheswithvalue>fn specs.egress.toPorts.rules.http.headerMatches.withValue</h3> <div class=highlight><pre><span></span><code><span class=nx>withValue</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Value matches the exact value of the header. Can be specified either alone or together with \"Secret\"; will be used as the header value if the secret can not be found in the latter case."</p> <h2 id=obj-specsegresstoportsruleshttpheadermatchessecret>obj specs.egress.toPorts.rules.http.headerMatches.secret</h2> <p>"Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no \"Value\" specified, the match will fail."</p> <h3 id=fn-specsegresstoportsruleshttpheadermatchessecretwithname>fn specs.egress.toPorts.rules.http.headerMatches.secret.withName</h3> <div class=highlight><pre><span></span><code><span class=nx>withName</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Name is the name of the secret."</p> <h3 id=fn-specsegresstoportsruleshttpheadermatchessecretwithnamespace>fn specs.egress.toPorts.rules.http.headerMatches.secret.withNamespace</h3> <div class=highlight><pre><span></span><code><span class=nx>withNamespace</span><span class=p>(</span><span class=nx>namespace</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\")."</p> <h2 id=obj-specsegresstoportsruleskafka>obj specs.egress.toPorts.rules.kafka</h2> <p>"Kafka-specific rules."</p> <h3 id=fn-specsegresstoportsruleskafkawithapikey>fn specs.egress.toPorts.rules.kafka.withApiKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withApiKey</span><span class=p>(</span><span class=nx>apiKey</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"APIKey is a case-insensitive string matched against the key of a request, e.g. \"produce\", \"fetch\", \"createtopic\", \"deletetopic\", et al Reference: https://kafka.apache.org/protocol#protocol_api_keys \n If omitted or empty, and if Role is not specified, then all keys are allowed."</p> <h3 id=fn-specsegresstoportsruleskafkawithapiversion>fn specs.egress.toPorts.rules.kafka.withApiVersion</h3> <div class=highlight><pre><span></span><code><span class=nx>withApiVersion</span><span class=p>(</span><span class=nx>apiVersion</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"APIVersion is the version matched against the api version of the Kafka message. If set, it has to be a string representing a positive integer. \n If omitted or empty, all versions are allowed."</p> <h3 id=fn-specsegresstoportsruleskafkawithclientid>fn specs.egress.toPorts.rules.kafka.withClientID</h3> <div class=highlight><pre><span></span><code><span class=nx>withClientID</span><span class=p>(</span><span class=nx>clientID</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ClientID is the client identifier as provided in the request. \n From Kafka protocol documentation: This is a user supplied identifier for the client application. The user can use any identifier they like and it will be used when logging errors, monitoring aggregates, etc. For example, one might want to monitor not just the requests per second overall, but the number coming from each client application (each of which could reside on multiple servers). This id acts as a logical grouping across all requests from a particular client. \n If omitted or empty, all client identifiers are allowed."</p> <h3 id=fn-specsegresstoportsruleskafkawithrole>fn specs.egress.toPorts.rules.kafka.withRole</h3> <div class=highlight><pre><span></span><code><span class=nx>withRole</span><span class=p>(</span><span class=nx>role</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as \"produce\" or \"consume\". A Role automatically expands into all APIKeys required to perform the specified higher-level operation. \n The following values are supported: - \"produce\": Allow producing to the topics specified in the rule - \"consume\": Allow consuming from the topics specified in the rule \n This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule. \n If omitted or empty, and if APIKey is not specified, then all keys are allowed."</p> <h3 id=fn-specsegresstoportsruleskafkawithtopic>fn specs.egress.toPorts.rules.kafka.withTopic</h3> <div class=highlight><pre><span></span><code><span class=nx>withTopic</span><span class=p>(</span><span class=nx>topic</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Topic is the topic name contained in the message. If a Kafka request contains multiple topics, then all topics must be allowed or the message will be rejected. \n This constraint is ignored if the matched request message type doesn't contain any topic. Maximum size of Topic can be 249 characters as per recent Kafka spec and allowed characters are a-z, A-Z, 0-9, -, . and _. \n Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10 version the length was changed from 255 to 249. For compatibility reasons we are using 255. \n If omitted or empty, all topics are allowed."</p> <h2 id=obj-specsegresstoportsterminatingtls>obj specs.egress.toPorts.terminatingTLS</h2> <p>"TerminatingTLS is the TLS context for the connection terminated by the L7 proxy. For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy."</p> <h3 id=fn-specsegresstoportsterminatingtlswithcertificate>fn specs.egress.toPorts.terminatingTLS.withCertificate</h3> <div class=highlight><pre><span></span><code><span class=nx>withCertificate</span><span class=p>(</span><span class=nx>certificate</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist."</p> <h3 id=fn-specsegresstoportsterminatingtlswithprivatekey>fn specs.egress.toPorts.terminatingTLS.withPrivateKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withPrivateKey</span><span class=p>(</span><span class=nx>privateKey</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist."</p> <h3 id=fn-specsegresstoportsterminatingtlswithtrustedca>fn specs.egress.toPorts.terminatingTLS.withTrustedCA</h3> <div class=highlight><pre><span></span><code><span class=nx>withTrustedCA</span><span class=p>(</span><span class=nx>trustedCA</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist."</p> <h2 id=obj-specsegresstoportsterminatingtlssecret>obj specs.egress.toPorts.terminatingTLS.secret</h2> <p>"Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt' - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate."</p> <h3 id=fn-specsegresstoportsterminatingtlssecretwithname>fn specs.egress.toPorts.terminatingTLS.secret.withName</h3> <div class=highlight><pre><span></span><code><span class=nx>withName</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Name is the name of the secret."</p> <h3 id=fn-specsegresstoportsterminatingtlssecretwithnamespace>fn specs.egress.toPorts.terminatingTLS.secret.withNamespace</h3> <div class=highlight><pre><span></span><code><span class=nx>withNamespace</span><span class=p>(</span><span class=nx>namespace</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\")."</p> <h2 id=obj-specsegresstorequires>obj specs.egress.toRequires</h2> <p>"ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires any endpoint to which it communicates to also carry the label \"team=A\"."</p> <h3 id=fn-specsegresstorequireswithmatchexpressions>fn specs.egress.toRequires.withMatchExpressions</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressions</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specsegresstorequireswithmatchexpressionsmixin>fn specs.egress.toRequires.withMatchExpressionsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressionsMixin</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegresstorequireswithmatchlabels>fn specs.egress.toRequires.withMatchLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabels</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <h3 id=fn-specsegresstorequireswithmatchlabelsmixin>fn specs.egress.toRequires.withMatchLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabelsMixin</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsegresstorequiresmatchexpressions>obj specs.egress.toRequires.matchExpressions</h2> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specsegresstorequiresmatchexpressionswithkey>fn specs.egress.toRequires.matchExpressions.withKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withKey</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"key is the label key that the selector applies to."</p> <h3 id=fn-specsegresstorequiresmatchexpressionswithoperator>fn specs.egress.toRequires.matchExpressions.withOperator</h3> <div class=highlight><pre><span></span><code><span class=nx>withOperator</span><span class=p>(</span><span class=nx>operator</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist."</p> <h3 id=fn-specsegresstorequiresmatchexpressionswithvalues>fn specs.egress.toRequires.matchExpressions.withValues</h3> <div class=highlight><pre><span></span><code><span class=nx>withValues</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <h3 id=fn-specsegresstorequiresmatchexpressionswithvaluesmixin>fn specs.egress.toRequires.matchExpressions.withValuesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withValuesMixin</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsegresstoservices>obj specs.egress.toServices</h2> <p>"ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors. \n Example: Any endpoint with the label \"app=backend-app\" is allowed to initiate connections to all cidrs backing the \"external-service\" service"</p> <h2 id=obj-specsegresstoservicesk8sservice>obj specs.egress.toServices.k8sService</h2> <p>"K8sService selects service by name and namespace pair"</p> <h3 id=fn-specsegresstoservicesk8sservicewithnamespace>fn specs.egress.toServices.k8sService.withNamespace</h3> <div class=highlight><pre><span></span><code><span class=nx>withNamespace</span><span class=p>(</span><span class=nx>namespace</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h3 id=fn-specsegresstoservicesk8sservicewithservicename>fn specs.egress.toServices.k8sService.withServiceName</h3> <div class=highlight><pre><span></span><code><span class=nx>withServiceName</span><span class=p>(</span><span class=nx>serviceName</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h2 id=obj-specsegresstoservicesk8sserviceselector>obj specs.egress.toServices.k8sServiceSelector</h2> <p>"K8sServiceSelector selects services by k8s labels and namespace"</p> <h3 id=fn-specsegresstoservicesk8sserviceselectorwithnamespace>fn specs.egress.toServices.k8sServiceSelector.withNamespace</h3> <div class=highlight><pre><span></span><code><span class=nx>withNamespace</span><span class=p>(</span><span class=nx>namespace</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h2 id=obj-specsegresstoservicesk8sserviceselectorselector>obj specs.egress.toServices.k8sServiceSelector.selector</h2> <p>"ServiceSelector is a label selector for k8s services"</p> <h3 id=fn-specsegresstoservicesk8sserviceselectorselectorwithmatchexpressions>fn specs.egress.toServices.k8sServiceSelector.selector.withMatchExpressions</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressions</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specsegresstoservicesk8sserviceselectorselectorwithmatchexpressionsmixin>fn specs.egress.toServices.k8sServiceSelector.selector.withMatchExpressionsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressionsMixin</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegresstoservicesk8sserviceselectorselectorwithmatchlabels>fn specs.egress.toServices.k8sServiceSelector.selector.withMatchLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabels</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <h3 id=fn-specsegresstoservicesk8sserviceselectorselectorwithmatchlabelsmixin>fn specs.egress.toServices.k8sServiceSelector.selector.withMatchLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabelsMixin</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsegresstoservicesk8sserviceselectorselectormatchexpressions>obj specs.egress.toServices.k8sServiceSelector.selector.matchExpressions</h2> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specsegresstoservicesk8sserviceselectorselectormatchexpressionswithkey>fn specs.egress.toServices.k8sServiceSelector.selector.matchExpressions.withKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withKey</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"key is the label key that the selector applies to."</p> <h3 id=fn-specsegresstoservicesk8sserviceselectorselectormatchexpressionswithoperator>fn specs.egress.toServices.k8sServiceSelector.selector.matchExpressions.withOperator</h3> <div class=highlight><pre><span></span><code><span class=nx>withOperator</span><span class=p>(</span><span class=nx>operator</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist."</p> <h3 id=fn-specsegresstoservicesk8sserviceselectorselectormatchexpressionswithvalues>fn specs.egress.toServices.k8sServiceSelector.selector.matchExpressions.withValues</h3> <div class=highlight><pre><span></span><code><span class=nx>withValues</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <h3 id=fn-specsegresstoservicesk8sserviceselectorselectormatchexpressionswithvaluesmixin>fn specs.egress.toServices.k8sServiceSelector.selector.matchExpressions.withValuesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withValuesMixin</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsegressdeny>obj specs.egressDeny</h2> <p>"EgressDeny is a list of EgressDenyRule which are enforced at egress. Any rule inserted here will by denied regardless of the allowed egress rules in the 'egress' field. If omitted or empty, this rule does not apply at egress."</p> <h3 id=fn-specsegressdenywithicmps>fn specs.egressDeny.withIcmps</h3> <div class=highlight><pre><span></span><code><span class=nx>withIcmps</span><span class=p>(</span><span class=nx>icmps</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to connect to. \n Example: Any endpoint with the label \"app=httpd\" is not allowed to initiate type 8 ICMP connections."</p> <h3 id=fn-specsegressdenywithicmpsmixin>fn specs.egressDeny.withIcmpsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withIcmpsMixin</span><span class=p>(</span><span class=nx>icmps</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to connect to. \n Example: Any endpoint with the label \"app=httpd\" is not allowed to initiate type 8 ICMP connections."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegressdenywithtocidr>fn specs.egressDeny.withToCIDR</h3> <div class=highlight><pre><span></span><code><span class=nx>withToCIDR</span><span class=p>(</span><span class=nx>toCIDR</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24"</p> <h3 id=fn-specsegressdenywithtocidrmixin>fn specs.egressDeny.withToCIDRMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToCIDRMixin</span><span class=p>(</span><span class=nx>toCIDR</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections. Only connections destined for outside of the cluster and not targeting the host will be subject to CIDR rules. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegressdenywithtocidrset>fn specs.egressDeny.withToCIDRSet</h3> <div class=highlight><pre><span></span><code><span class=nx>withToCIDRSet</span><span class=p>(</span><span class=nx>toCIDRSet</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28."</p> <h3 id=fn-specsegressdenywithtocidrsetmixin>fn specs.egressDeny.withToCIDRSetMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToCIDRSetMixin</span><span class=p>(</span><span class=nx>toCIDRSet</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegressdenywithtoendpoints>fn specs.egressDeny.withToEndpoints</h3> <div class=highlight><pre><span></span><code><span class=nx>withToEndpoints</span><span class=p>(</span><span class=nx>toEndpoints</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate. \n Example: Any endpoint with the label \"role=frontend\" can communicate with any endpoint carrying the label \"role=backend\"."</p> <h3 id=fn-specsegressdenywithtoendpointsmixin>fn specs.egressDeny.withToEndpointsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToEndpointsMixin</span><span class=p>(</span><span class=nx>toEndpoints</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate. \n Example: Any endpoint with the label \"role=frontend\" can communicate with any endpoint carrying the label \"role=backend\"."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegressdenywithtoentities>fn specs.egressDeny.withToEntities</h3> <div class=highlight><pre><span></span><code><span class=nx>withToEntities</span><span class=p>(</span><span class=nx>toEntities</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are <code>world</code>, <code>cluster</code> and <code>host</code>"</p> <h3 id=fn-specsegressdenywithtoentitiesmixin>fn specs.egressDeny.withToEntitiesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToEntitiesMixin</span><span class=p>(</span><span class=nx>toEntities</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToEntities is a list of special entities to which the endpoint subject to the rule is allowed to initiate connections. Supported entities are <code>world</code>, <code>cluster</code> and <code>host</code>"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegressdenywithtogroups>fn specs.egressDeny.withToGroups</h3> <div class=highlight><pre><span></span><code><span class=nx>withToGroups</span><span class=p>(</span><span class=nx>toGroups</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives: \n Example: toGroups: - aws: securityGroupsIds: - 'sg-XXXXXXXXXXXXX'"</p> <h3 id=fn-specsegressdenywithtogroupsmixin>fn specs.egressDeny.withToGroupsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToGroupsMixin</span><span class=p>(</span><span class=nx>toGroups</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives: \n Example: toGroups: - aws: securityGroupsIds: - 'sg-XXXXXXXXXXXXX'"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegressdenywithtoports>fn specs.egressDeny.withToPorts</h3> <div class=highlight><pre><span></span><code><span class=nx>withToPorts</span><span class=p>(</span><span class=nx>toPorts</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to connect to. \n Example: Any endpoint with the label \"role=frontend\" is not allowed to initiate connections to destination port 8080/tcp"</p> <h3 id=fn-specsegressdenywithtoportsmixin>fn specs.egressDeny.withToPortsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToPortsMixin</span><span class=p>(</span><span class=nx>toPorts</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to connect to. \n Example: Any endpoint with the label \"role=frontend\" is not allowed to initiate connections to destination port 8080/tcp"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegressdenywithtorequires>fn specs.egressDeny.withToRequires</h3> <div class=highlight><pre><span></span><code><span class=nx>withToRequires</span><span class=p>(</span><span class=nx>toRequires</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires any endpoint to which it communicates to also carry the label \"team=A\"."</p> <h3 id=fn-specsegressdenywithtorequiresmixin>fn specs.egressDeny.withToRequiresMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToRequiresMixin</span><span class=p>(</span><span class=nx>toRequires</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires any endpoint to which it communicates to also carry the label \"team=A\"."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegressdenywithtoservices>fn specs.egressDeny.withToServices</h3> <div class=highlight><pre><span></span><code><span class=nx>withToServices</span><span class=p>(</span><span class=nx>toServices</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors. \n Example: Any endpoint with the label \"app=backend-app\" is allowed to initiate connections to all cidrs backing the \"external-service\" service"</p> <h3 id=fn-specsegressdenywithtoservicesmixin>fn specs.egressDeny.withToServicesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToServicesMixin</span><span class=p>(</span><span class=nx>toServices</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors. \n Example: Any endpoint with the label \"app=backend-app\" is allowed to initiate connections to all cidrs backing the \"external-service\" service"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsegressdenyicmps>obj specs.egressDeny.icmps</h2> <p>"ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to connect to. \n Example: Any endpoint with the label \"app=httpd\" is not allowed to initiate type 8 ICMP connections."</p> <h3 id=fn-specsegressdenyicmpswithfields>fn specs.egressDeny.icmps.withFields</h3> <div class=highlight><pre><span></span><code><span class=nx>withFields</span><span class=p>(</span><span class=nx>fields</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Fields is a list of ICMP fields."</p> <h3 id=fn-specsegressdenyicmpswithfieldsmixin>fn specs.egressDeny.icmps.withFieldsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withFieldsMixin</span><span class=p>(</span><span class=nx>fields</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Fields is a list of ICMP fields."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsegressdenyicmpsfields>obj specs.egressDeny.icmps.fields</h2> <p>"Fields is a list of ICMP fields."</p> <h3 id=fn-specsegressdenyicmpsfieldswithfamily>fn specs.egressDeny.icmps.fields.withFamily</h3> <div class=highlight><pre><span></span><code><span class=nx>withFamily</span><span class=p>(</span><span class=nx>family</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Family is a IP address version. Currently, we support <code>IPv4</code> and <code>IPv6</code>. <code>IPv4</code> is set as default."</p> <h3 id=fn-specsegressdenyicmpsfieldswithtype>fn specs.egressDeny.icmps.fields.withType</h3> <div class=highlight><pre><span></span><code><span class=nx>withType</span><span class=p>(</span><span class=kr>type</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Type is a ICMP-type. It should be 0-255 (8bit)."</p> <h2 id=obj-specsegressdenytocidrset>obj specs.egressDeny.toCIDRSet</h2> <p>"ToCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to initiate connections to in addition to connections which are allowed via ToEndpoints, along with a list of subnets contained within their corresponding IP block to which traffic should not be allowed. This will match on the destination IP address of outgoing connections. Adding a prefix into ToCIDR or into ToCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between ToCIDR and ToCIDRSet. \n Example: Any endpoint with the label \"app=database-proxy\" is allowed to initiate connections to 10.2.3.0/24 except from IPs in subnet 10.2.3.0/28."</p> <h3 id=fn-specsegressdenytocidrsetwithcidr>fn specs.egressDeny.toCIDRSet.withCidr</h3> <div class=highlight><pre><span></span><code><span class=nx>withCidr</span><span class=p>(</span><span class=nx>cidr</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"CIDR is a CIDR prefix / IP Block."</p> <h3 id=fn-specsegressdenytocidrsetwithexcept>fn specs.egressDeny.toCIDRSet.withExcept</h3> <div class=highlight><pre><span></span><code><span class=nx>withExcept</span><span class=p>(</span><span class=nx>except</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules."</p> <h3 id=fn-specsegressdenytocidrsetwithexceptmixin>fn specs.egressDeny.toCIDRSet.withExceptMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withExceptMixin</span><span class=p>(</span><span class=nx>except</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsegressdenytoendpoints>obj specs.egressDeny.toEndpoints</h2> <p>"ToEndpoints is a list of endpoints identified by an EndpointSelector to which the endpoints subject to the rule are allowed to communicate. \n Example: Any endpoint with the label \"role=frontend\" can communicate with any endpoint carrying the label \"role=backend\"."</p> <h3 id=fn-specsegressdenytoendpointswithmatchexpressions>fn specs.egressDeny.toEndpoints.withMatchExpressions</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressions</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specsegressdenytoendpointswithmatchexpressionsmixin>fn specs.egressDeny.toEndpoints.withMatchExpressionsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressionsMixin</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegressdenytoendpointswithmatchlabels>fn specs.egressDeny.toEndpoints.withMatchLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabels</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <h3 id=fn-specsegressdenytoendpointswithmatchlabelsmixin>fn specs.egressDeny.toEndpoints.withMatchLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabelsMixin</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsegressdenytoendpointsmatchexpressions>obj specs.egressDeny.toEndpoints.matchExpressions</h2> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specsegressdenytoendpointsmatchexpressionswithkey>fn specs.egressDeny.toEndpoints.matchExpressions.withKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withKey</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"key is the label key that the selector applies to."</p> <h3 id=fn-specsegressdenytoendpointsmatchexpressionswithoperator>fn specs.egressDeny.toEndpoints.matchExpressions.withOperator</h3> <div class=highlight><pre><span></span><code><span class=nx>withOperator</span><span class=p>(</span><span class=nx>operator</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist."</p> <h3 id=fn-specsegressdenytoendpointsmatchexpressionswithvalues>fn specs.egressDeny.toEndpoints.matchExpressions.withValues</h3> <div class=highlight><pre><span></span><code><span class=nx>withValues</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <h3 id=fn-specsegressdenytoendpointsmatchexpressionswithvaluesmixin>fn specs.egressDeny.toEndpoints.matchExpressions.withValuesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withValuesMixin</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsegressdenytogroups>obj specs.egressDeny.toGroups</h2> <p>"ToGroups is a directive that allows the integration with multiple outside providers. Currently, only AWS is supported, and the rule can select by multiple sub directives: \n Example: toGroups: - aws: securityGroupsIds: - 'sg-XXXXXXXXXXXXX'"</p> <h2 id=obj-specsegressdenytogroupsaws>obj specs.egressDeny.toGroups.aws</h2> <p>"AWSGroup is an structure that can be used to whitelisting information from AWS integration"</p> <h3 id=fn-specsegressdenytogroupsawswithlabels>fn specs.egressDeny.toGroups.aws.withLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withLabels</span><span class=p>(</span><span class=nx>labels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h3 id=fn-specsegressdenytogroupsawswithlabelsmixin>fn specs.egressDeny.toGroups.aws.withLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withLabelsMixin</span><span class=p>(</span><span class=nx>labels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegressdenytogroupsawswithregion>fn specs.egressDeny.toGroups.aws.withRegion</h3> <div class=highlight><pre><span></span><code><span class=nx>withRegion</span><span class=p>(</span><span class=nx>region</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h3 id=fn-specsegressdenytogroupsawswithsecuritygroupsids>fn specs.egressDeny.toGroups.aws.withSecurityGroupsIds</h3> <div class=highlight><pre><span></span><code><span class=nx>withSecurityGroupsIds</span><span class=p>(</span><span class=nx>securityGroupsIds</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h3 id=fn-specsegressdenytogroupsawswithsecuritygroupsidsmixin>fn specs.egressDeny.toGroups.aws.withSecurityGroupsIdsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withSecurityGroupsIdsMixin</span><span class=p>(</span><span class=nx>securityGroupsIds</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegressdenytogroupsawswithsecuritygroupsnames>fn specs.egressDeny.toGroups.aws.withSecurityGroupsNames</h3> <div class=highlight><pre><span></span><code><span class=nx>withSecurityGroupsNames</span><span class=p>(</span><span class=nx>securityGroupsNames</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h3 id=fn-specsegressdenytogroupsawswithsecuritygroupsnamesmixin>fn specs.egressDeny.toGroups.aws.withSecurityGroupsNamesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withSecurityGroupsNamesMixin</span><span class=p>(</span><span class=nx>securityGroupsNames</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsegressdenytoports>obj specs.egressDeny.toPorts</h2> <p>"ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to connect to. \n Example: Any endpoint with the label \"role=frontend\" is not allowed to initiate connections to destination port 8080/tcp"</p> <h3 id=fn-specsegressdenytoportswithports>fn specs.egressDeny.toPorts.withPorts</h3> <div class=highlight><pre><span></span><code><span class=nx>withPorts</span><span class=p>(</span><span class=nx>ports</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Ports is a list of L4 port/protocol"</p> <h3 id=fn-specsegressdenytoportswithportsmixin>fn specs.egressDeny.toPorts.withPortsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withPortsMixin</span><span class=p>(</span><span class=nx>ports</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Ports is a list of L4 port/protocol"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsegressdenytoportsports>obj specs.egressDeny.toPorts.ports</h2> <p>"Ports is a list of L4 port/protocol"</p> <h3 id=fn-specsegressdenytoportsportswithport>fn specs.egressDeny.toPorts.ports.withPort</h3> <div class=highlight><pre><span></span><code><span class=nx>withPort</span><span class=p>(</span><span class=nx>port</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end."</p> <h3 id=fn-specsegressdenytoportsportswithprotocol>fn specs.egressDeny.toPorts.ports.withProtocol</h3> <div class=highlight><pre><span></span><code><span class=nx>withProtocol</span><span class=p>(</span><span class=nx>protocol</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"\"/\"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this."</p> <h2 id=obj-specsegressdenytorequires>obj specs.egressDeny.toRequires</h2> <p>"ToRequires is a list of additional constraints which must be met in order for the selected endpoints to be able to connect to other endpoints. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching ToEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires any endpoint to which it communicates to also carry the label \"team=A\"."</p> <h3 id=fn-specsegressdenytorequireswithmatchexpressions>fn specs.egressDeny.toRequires.withMatchExpressions</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressions</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specsegressdenytorequireswithmatchexpressionsmixin>fn specs.egressDeny.toRequires.withMatchExpressionsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressionsMixin</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegressdenytorequireswithmatchlabels>fn specs.egressDeny.toRequires.withMatchLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabels</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <h3 id=fn-specsegressdenytorequireswithmatchlabelsmixin>fn specs.egressDeny.toRequires.withMatchLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabelsMixin</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsegressdenytorequiresmatchexpressions>obj specs.egressDeny.toRequires.matchExpressions</h2> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specsegressdenytorequiresmatchexpressionswithkey>fn specs.egressDeny.toRequires.matchExpressions.withKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withKey</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"key is the label key that the selector applies to."</p> <h3 id=fn-specsegressdenytorequiresmatchexpressionswithoperator>fn specs.egressDeny.toRequires.matchExpressions.withOperator</h3> <div class=highlight><pre><span></span><code><span class=nx>withOperator</span><span class=p>(</span><span class=nx>operator</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist."</p> <h3 id=fn-specsegressdenytorequiresmatchexpressionswithvalues>fn specs.egressDeny.toRequires.matchExpressions.withValues</h3> <div class=highlight><pre><span></span><code><span class=nx>withValues</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <h3 id=fn-specsegressdenytorequiresmatchexpressionswithvaluesmixin>fn specs.egressDeny.toRequires.matchExpressions.withValuesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withValuesMixin</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsegressdenytoservices>obj specs.egressDeny.toServices</h2> <p>"ToServices is a list of services to which the endpoint subject to the rule is allowed to initiate connections. Currently Cilium only supports toServices for K8s services without selectors. \n Example: Any endpoint with the label \"app=backend-app\" is allowed to initiate connections to all cidrs backing the \"external-service\" service"</p> <h2 id=obj-specsegressdenytoservicesk8sservice>obj specs.egressDeny.toServices.k8sService</h2> <p>"K8sService selects service by name and namespace pair"</p> <h3 id=fn-specsegressdenytoservicesk8sservicewithnamespace>fn specs.egressDeny.toServices.k8sService.withNamespace</h3> <div class=highlight><pre><span></span><code><span class=nx>withNamespace</span><span class=p>(</span><span class=nx>namespace</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h3 id=fn-specsegressdenytoservicesk8sservicewithservicename>fn specs.egressDeny.toServices.k8sService.withServiceName</h3> <div class=highlight><pre><span></span><code><span class=nx>withServiceName</span><span class=p>(</span><span class=nx>serviceName</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h2 id=obj-specsegressdenytoservicesk8sserviceselector>obj specs.egressDeny.toServices.k8sServiceSelector</h2> <p>"K8sServiceSelector selects services by k8s labels and namespace"</p> <h3 id=fn-specsegressdenytoservicesk8sserviceselectorwithnamespace>fn specs.egressDeny.toServices.k8sServiceSelector.withNamespace</h3> <div class=highlight><pre><span></span><code><span class=nx>withNamespace</span><span class=p>(</span><span class=nx>namespace</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h2 id=obj-specsegressdenytoservicesk8sserviceselectorselector>obj specs.egressDeny.toServices.k8sServiceSelector.selector</h2> <p>"ServiceSelector is a label selector for k8s services"</p> <h3 id=fn-specsegressdenytoservicesk8sserviceselectorselectorwithmatchexpressions>fn specs.egressDeny.toServices.k8sServiceSelector.selector.withMatchExpressions</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressions</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specsegressdenytoservicesk8sserviceselectorselectorwithmatchexpressionsmixin>fn specs.egressDeny.toServices.k8sServiceSelector.selector.withMatchExpressionsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressionsMixin</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsegressdenytoservicesk8sserviceselectorselectorwithmatchlabels>fn specs.egressDeny.toServices.k8sServiceSelector.selector.withMatchLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabels</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <h3 id=fn-specsegressdenytoservicesk8sserviceselectorselectorwithmatchlabelsmixin>fn specs.egressDeny.toServices.k8sServiceSelector.selector.withMatchLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabelsMixin</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsegressdenytoservicesk8sserviceselectorselectormatchexpressions>obj specs.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions</h2> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specsegressdenytoservicesk8sserviceselectorselectormatchexpressionswithkey>fn specs.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions.withKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withKey</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"key is the label key that the selector applies to."</p> <h3 id=fn-specsegressdenytoservicesk8sserviceselectorselectormatchexpressionswithoperator>fn specs.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions.withOperator</h3> <div class=highlight><pre><span></span><code><span class=nx>withOperator</span><span class=p>(</span><span class=nx>operator</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist."</p> <h3 id=fn-specsegressdenytoservicesk8sserviceselectorselectormatchexpressionswithvalues>fn specs.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions.withValues</h3> <div class=highlight><pre><span></span><code><span class=nx>withValues</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <h3 id=fn-specsegressdenytoservicesk8sserviceselectorselectormatchexpressionswithvaluesmixin>fn specs.egressDeny.toServices.k8sServiceSelector.selector.matchExpressions.withValuesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withValuesMixin</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsendpointselector>obj specs.endpointSelector</h2> <p>"EndpointSelector selects all endpoints which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive."</p> <h3 id=fn-specsendpointselectorwithmatchexpressions>fn specs.endpointSelector.withMatchExpressions</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressions</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specsendpointselectorwithmatchexpressionsmixin>fn specs.endpointSelector.withMatchExpressionsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressionsMixin</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsendpointselectorwithmatchlabels>fn specs.endpointSelector.withMatchLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabels</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <h3 id=fn-specsendpointselectorwithmatchlabelsmixin>fn specs.endpointSelector.withMatchLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabelsMixin</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsendpointselectormatchexpressions>obj specs.endpointSelector.matchExpressions</h2> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specsendpointselectormatchexpressionswithkey>fn specs.endpointSelector.matchExpressions.withKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withKey</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"key is the label key that the selector applies to."</p> <h3 id=fn-specsendpointselectormatchexpressionswithoperator>fn specs.endpointSelector.matchExpressions.withOperator</h3> <div class=highlight><pre><span></span><code><span class=nx>withOperator</span><span class=p>(</span><span class=nx>operator</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist."</p> <h3 id=fn-specsendpointselectormatchexpressionswithvalues>fn specs.endpointSelector.matchExpressions.withValues</h3> <div class=highlight><pre><span></span><code><span class=nx>withValues</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <h3 id=fn-specsendpointselectormatchexpressionswithvaluesmixin>fn specs.endpointSelector.matchExpressions.withValuesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withValuesMixin</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsingress>obj specs.ingress</h2> <p>"Ingress is a list of IngressRule which are enforced at ingress. If omitted or empty, this rule does not apply at ingress."</p> <h3 id=fn-specsingresswithfromcidr>fn specs.ingress.withFromCIDR</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromCIDR</span><span class=p>(</span><span class=nx>fromCIDR</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do <em>not</em> originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.3.9.1"</p> <h3 id=fn-specsingresswithfromcidrmixin>fn specs.ingress.withFromCIDRMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromCIDRMixin</span><span class=p>(</span><span class=nx>fromCIDR</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do <em>not</em> originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.3.9.1"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsingresswithfromcidrset>fn specs.ingress.withFromCIDRSet</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromCIDRSet</span><span class=p>(</span><span class=nx>fromCIDRSet</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12."</p> <h3 id=fn-specsingresswithfromcidrsetmixin>fn specs.ingress.withFromCIDRSetMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromCIDRSetMixin</span><span class=p>(</span><span class=nx>fromCIDRSet</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsingresswithfromendpoints>fn specs.ingress.withFromEndpoints</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromEndpoints</span><span class=p>(</span><span class=nx>fromEndpoints</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule. \n Example: Any endpoint with the label \"role=backend\" can be consumed by any endpoint carrying the label \"role=frontend\"."</p> <h3 id=fn-specsingresswithfromendpointsmixin>fn specs.ingress.withFromEndpointsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromEndpointsMixin</span><span class=p>(</span><span class=nx>fromEndpoints</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule. \n Example: Any endpoint with the label \"role=backend\" can be consumed by any endpoint carrying the label \"role=frontend\"."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsingresswithfromentities>fn specs.ingress.withFromEntities</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromEntities</span><span class=p>(</span><span class=nx>fromEntities</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are <code>world</code>, <code>cluster</code> and <code>host</code>"</p> <h3 id=fn-specsingresswithfromentitiesmixin>fn specs.ingress.withFromEntitiesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromEntitiesMixin</span><span class=p>(</span><span class=nx>fromEntities</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are <code>world</code>, <code>cluster</code> and <code>host</code>"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsingresswithfromrequires>fn specs.ingress.withFromRequires</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromRequires</span><span class=p>(</span><span class=nx>fromRequires</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires consuming endpoint to also carry the label \"team=A\"."</p> <h3 id=fn-specsingresswithfromrequiresmixin>fn specs.ingress.withFromRequiresMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromRequiresMixin</span><span class=p>(</span><span class=nx>fromRequires</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires consuming endpoint to also carry the label \"team=A\"."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsingresswithicmps>fn specs.ingress.withIcmps</h3> <div class=highlight><pre><span></span><code><span class=nx>withIcmps</span><span class=p>(</span><span class=nx>icmps</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can only accept incoming type 8 ICMP connections."</p> <h3 id=fn-specsingresswithicmpsmixin>fn specs.ingress.withIcmpsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withIcmpsMixin</span><span class=p>(</span><span class=nx>icmps</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can only accept incoming type 8 ICMP connections."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsingresswithtoports>fn specs.ingress.withToPorts</h3> <div class=highlight><pre><span></span><code><span class=nx>withToPorts</span><span class=p>(</span><span class=nx>toPorts</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can only accept incoming connections on port 80/tcp."</p> <h3 id=fn-specsingresswithtoportsmixin>fn specs.ingress.withToPortsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToPortsMixin</span><span class=p>(</span><span class=nx>toPorts</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can only accept incoming connections on port 80/tcp."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsingressfromcidrset>obj specs.ingress.fromCIDRSet</h2> <p>"FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12."</p> <h3 id=fn-specsingressfromcidrsetwithcidr>fn specs.ingress.fromCIDRSet.withCidr</h3> <div class=highlight><pre><span></span><code><span class=nx>withCidr</span><span class=p>(</span><span class=nx>cidr</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"CIDR is a CIDR prefix / IP Block."</p> <h3 id=fn-specsingressfromcidrsetwithexcept>fn specs.ingress.fromCIDRSet.withExcept</h3> <div class=highlight><pre><span></span><code><span class=nx>withExcept</span><span class=p>(</span><span class=nx>except</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules."</p> <h3 id=fn-specsingressfromcidrsetwithexceptmixin>fn specs.ingress.fromCIDRSet.withExceptMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withExceptMixin</span><span class=p>(</span><span class=nx>except</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsingressfromendpoints>obj specs.ingress.fromEndpoints</h2> <p>"FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule. \n Example: Any endpoint with the label \"role=backend\" can be consumed by any endpoint carrying the label \"role=frontend\"."</p> <h3 id=fn-specsingressfromendpointswithmatchexpressions>fn specs.ingress.fromEndpoints.withMatchExpressions</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressions</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specsingressfromendpointswithmatchexpressionsmixin>fn specs.ingress.fromEndpoints.withMatchExpressionsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressionsMixin</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsingressfromendpointswithmatchlabels>fn specs.ingress.fromEndpoints.withMatchLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabels</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <h3 id=fn-specsingressfromendpointswithmatchlabelsmixin>fn specs.ingress.fromEndpoints.withMatchLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabelsMixin</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsingressfromendpointsmatchexpressions>obj specs.ingress.fromEndpoints.matchExpressions</h2> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specsingressfromendpointsmatchexpressionswithkey>fn specs.ingress.fromEndpoints.matchExpressions.withKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withKey</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"key is the label key that the selector applies to."</p> <h3 id=fn-specsingressfromendpointsmatchexpressionswithoperator>fn specs.ingress.fromEndpoints.matchExpressions.withOperator</h3> <div class=highlight><pre><span></span><code><span class=nx>withOperator</span><span class=p>(</span><span class=nx>operator</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist."</p> <h3 id=fn-specsingressfromendpointsmatchexpressionswithvalues>fn specs.ingress.fromEndpoints.matchExpressions.withValues</h3> <div class=highlight><pre><span></span><code><span class=nx>withValues</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <h3 id=fn-specsingressfromendpointsmatchexpressionswithvaluesmixin>fn specs.ingress.fromEndpoints.matchExpressions.withValuesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withValuesMixin</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsingressfromrequires>obj specs.ingress.fromRequires</h2> <p>"FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires consuming endpoint to also carry the label \"team=A\"."</p> <h3 id=fn-specsingressfromrequireswithmatchexpressions>fn specs.ingress.fromRequires.withMatchExpressions</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressions</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specsingressfromrequireswithmatchexpressionsmixin>fn specs.ingress.fromRequires.withMatchExpressionsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressionsMixin</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsingressfromrequireswithmatchlabels>fn specs.ingress.fromRequires.withMatchLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabels</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <h3 id=fn-specsingressfromrequireswithmatchlabelsmixin>fn specs.ingress.fromRequires.withMatchLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabelsMixin</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsingressfromrequiresmatchexpressions>obj specs.ingress.fromRequires.matchExpressions</h2> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specsingressfromrequiresmatchexpressionswithkey>fn specs.ingress.fromRequires.matchExpressions.withKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withKey</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"key is the label key that the selector applies to."</p> <h3 id=fn-specsingressfromrequiresmatchexpressionswithoperator>fn specs.ingress.fromRequires.matchExpressions.withOperator</h3> <div class=highlight><pre><span></span><code><span class=nx>withOperator</span><span class=p>(</span><span class=nx>operator</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist."</p> <h3 id=fn-specsingressfromrequiresmatchexpressionswithvalues>fn specs.ingress.fromRequires.matchExpressions.withValues</h3> <div class=highlight><pre><span></span><code><span class=nx>withValues</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <h3 id=fn-specsingressfromrequiresmatchexpressionswithvaluesmixin>fn specs.ingress.fromRequires.matchExpressions.withValuesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withValuesMixin</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsingressicmps>obj specs.ingress.icmps</h2> <p>"ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can only accept incoming type 8 ICMP connections."</p> <h3 id=fn-specsingressicmpswithfields>fn specs.ingress.icmps.withFields</h3> <div class=highlight><pre><span></span><code><span class=nx>withFields</span><span class=p>(</span><span class=nx>fields</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Fields is a list of ICMP fields."</p> <h3 id=fn-specsingressicmpswithfieldsmixin>fn specs.ingress.icmps.withFieldsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withFieldsMixin</span><span class=p>(</span><span class=nx>fields</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Fields is a list of ICMP fields."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsingressicmpsfields>obj specs.ingress.icmps.fields</h2> <p>"Fields is a list of ICMP fields."</p> <h3 id=fn-specsingressicmpsfieldswithfamily>fn specs.ingress.icmps.fields.withFamily</h3> <div class=highlight><pre><span></span><code><span class=nx>withFamily</span><span class=p>(</span><span class=nx>family</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Family is a IP address version. Currently, we support <code>IPv4</code> and <code>IPv6</code>. <code>IPv4</code> is set as default."</p> <h3 id=fn-specsingressicmpsfieldswithtype>fn specs.ingress.icmps.fields.withType</h3> <div class=highlight><pre><span></span><code><span class=nx>withType</span><span class=p>(</span><span class=kr>type</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Type is a ICMP-type. It should be 0-255 (8bit)."</p> <h2 id=obj-specsingresstoports>obj specs.ingress.toPorts</h2> <p>"ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can only accept incoming connections on port 80/tcp."</p> <h3 id=fn-specsingresstoportswithports>fn specs.ingress.toPorts.withPorts</h3> <div class=highlight><pre><span></span><code><span class=nx>withPorts</span><span class=p>(</span><span class=nx>ports</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Ports is a list of L4 port/protocol"</p> <h3 id=fn-specsingresstoportswithportsmixin>fn specs.ingress.toPorts.withPortsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withPortsMixin</span><span class=p>(</span><span class=nx>ports</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Ports is a list of L4 port/protocol"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsingresstoportsoriginatingtls>obj specs.ingress.toPorts.originatingTLS</h2> <p>"OriginatingTLS is the TLS context for the connections originated by the L7 proxy. For egress policy this specifies the client-side TLS parameters for the upstream connection originating from the L7 proxy to the remote destination. For ingress policy this specifies the client-side TLS parameters for the connection from the L7 proxy to the local endpoint."</p> <h3 id=fn-specsingresstoportsoriginatingtlswithcertificate>fn specs.ingress.toPorts.originatingTLS.withCertificate</h3> <div class=highlight><pre><span></span><code><span class=nx>withCertificate</span><span class=p>(</span><span class=nx>certificate</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist."</p> <h3 id=fn-specsingresstoportsoriginatingtlswithprivatekey>fn specs.ingress.toPorts.originatingTLS.withPrivateKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withPrivateKey</span><span class=p>(</span><span class=nx>privateKey</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist."</p> <h3 id=fn-specsingresstoportsoriginatingtlswithtrustedca>fn specs.ingress.toPorts.originatingTLS.withTrustedCA</h3> <div class=highlight><pre><span></span><code><span class=nx>withTrustedCA</span><span class=p>(</span><span class=nx>trustedCA</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist."</p> <h2 id=obj-specsingresstoportsoriginatingtlssecret>obj specs.ingress.toPorts.originatingTLS.secret</h2> <p>"Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt' - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate."</p> <h3 id=fn-specsingresstoportsoriginatingtlssecretwithname>fn specs.ingress.toPorts.originatingTLS.secret.withName</h3> <div class=highlight><pre><span></span><code><span class=nx>withName</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Name is the name of the secret."</p> <h3 id=fn-specsingresstoportsoriginatingtlssecretwithnamespace>fn specs.ingress.toPorts.originatingTLS.secret.withNamespace</h3> <div class=highlight><pre><span></span><code><span class=nx>withNamespace</span><span class=p>(</span><span class=nx>namespace</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\")."</p> <h2 id=obj-specsingresstoportsports>obj specs.ingress.toPorts.ports</h2> <p>"Ports is a list of L4 port/protocol"</p> <h3 id=fn-specsingresstoportsportswithport>fn specs.ingress.toPorts.ports.withPort</h3> <div class=highlight><pre><span></span><code><span class=nx>withPort</span><span class=p>(</span><span class=nx>port</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end."</p> <h3 id=fn-specsingresstoportsportswithprotocol>fn specs.ingress.toPorts.ports.withProtocol</h3> <div class=highlight><pre><span></span><code><span class=nx>withProtocol</span><span class=p>(</span><span class=nx>protocol</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"\"/\"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this."</p> <h2 id=obj-specsingresstoportsrules>obj specs.ingress.toPorts.rules</h2> <p>"Rules is a list of additional port level rules which must be met in order for the PortRule to allow the traffic. If omitted or empty, no layer 7 rules are enforced."</p> <h3 id=fn-specsingresstoportsruleswithdns>fn specs.ingress.toPorts.rules.withDns</h3> <div class=highlight><pre><span></span><code><span class=nx>withDns</span><span class=p>(</span><span class=nx>dns</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"DNS-specific rules."</p> <h3 id=fn-specsingresstoportsruleswithdnsmixin>fn specs.ingress.toPorts.rules.withDnsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withDnsMixin</span><span class=p>(</span><span class=nx>dns</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"DNS-specific rules."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsingresstoportsruleswithhttp>fn specs.ingress.toPorts.rules.withHttp</h3> <div class=highlight><pre><span></span><code><span class=nx>withHttp</span><span class=p>(</span><span class=nx>http</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"HTTP specific rules."</p> <h3 id=fn-specsingresstoportsruleswithhttpmixin>fn specs.ingress.toPorts.rules.withHttpMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withHttpMixin</span><span class=p>(</span><span class=nx>http</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"HTTP specific rules."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsingresstoportsruleswithkafka>fn specs.ingress.toPorts.rules.withKafka</h3> <div class=highlight><pre><span></span><code><span class=nx>withKafka</span><span class=p>(</span><span class=nx>kafka</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Kafka-specific rules."</p> <h3 id=fn-specsingresstoportsruleswithkafkamixin>fn specs.ingress.toPorts.rules.withKafkaMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withKafkaMixin</span><span class=p>(</span><span class=nx>kafka</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Kafka-specific rules."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsingresstoportsruleswithl7>fn specs.ingress.toPorts.rules.withL7</h3> <div class=highlight><pre><span></span><code><span class=nx>withL7</span><span class=p>(</span><span class=nx>l7</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Key-value pair rules."</p> <h3 id=fn-specsingresstoportsruleswithl7mixin>fn specs.ingress.toPorts.rules.withL7Mixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withL7Mixin</span><span class=p>(</span><span class=nx>l7</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Key-value pair rules."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsingresstoportsruleswithl7proto>fn specs.ingress.toPorts.rules.withL7proto</h3> <div class=highlight><pre><span></span><code><span class=nx>withL7proto</span><span class=p>(</span><span class=nx>l7proto</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Name of the L7 protocol for which the Key-value pair rules apply."</p> <h2 id=obj-specsingresstoportsrulesdns>obj specs.ingress.toPorts.rules.dns</h2> <p>"DNS-specific rules."</p> <h3 id=fn-specsingresstoportsrulesdnswithmatchname>fn specs.ingress.toPorts.rules.dns.withMatchName</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchName</span><span class=p>(</span><span class=nx>matchName</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"MatchName matches literal DNS names. A trailing \".\" is automatically added when missing."</p> <h3 id=fn-specsingresstoportsrulesdnswithmatchpattern>fn specs.ingress.toPorts.rules.dns.withMatchPattern</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchPattern</span><span class=p>(</span><span class=nx>matchPattern</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"MatchPattern allows using wildcards to match DNS names. All wildcards are case insensitive. The wildcards are: - \"<em>\" matches 0 or more DNS valid characters, and may occur anywhere in the pattern. As a special case a \"</em>\" as the leftmost character, without a following \".\" matches all subdomains as well as the name to the right. A trailing \".\" is automatically added when missing. \n Examples: <code>*.cilium.io</code> matches subomains of cilium at that level www.cilium.io and blog.cilium.io match, cilium.io and google.com do not <code>*cilium.io</code> matches cilium.io and all subdomains ends with \"cilium.io\" except those containing \".\" separator, subcilium.io and sub-cilium.io match, www.cilium.io and blog.cilium.io does not sub*.cilium.io matches subdomains of cilium where the subdomain component begins with \"sub\" sub.cilium.io and subdomain.cilium.io match, www.cilium.io, blog.cilium.io, cilium.io and google.com do not"</p> <h2 id=obj-specsingresstoportsruleshttp>obj specs.ingress.toPorts.rules.http</h2> <p>"HTTP specific rules."</p> <h3 id=fn-specsingresstoportsruleshttpwithheadermatches>fn specs.ingress.toPorts.rules.http.withHeaderMatches</h3> <div class=highlight><pre><span></span><code><span class=nx>withHeaderMatches</span><span class=p>(</span><span class=nx>headerMatches</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match."</p> <h3 id=fn-specsingresstoportsruleshttpwithheadermatchesmixin>fn specs.ingress.toPorts.rules.http.withHeaderMatchesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withHeaderMatchesMixin</span><span class=p>(</span><span class=nx>headerMatches</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsingresstoportsruleshttpwithheaders>fn specs.ingress.toPorts.rules.http.withHeaders</h3> <div class=highlight><pre><span></span><code><span class=nx>withHeaders</span><span class=p>(</span><span class=nx>headers</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present."</p> <h3 id=fn-specsingresstoportsruleshttpwithheadersmixin>fn specs.ingress.toPorts.rules.http.withHeadersMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withHeadersMixin</span><span class=p>(</span><span class=nx>headers</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Headers is a list of HTTP headers which must be present in the request. If omitted or empty, requests are allowed regardless of headers present."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsingresstoportsruleshttpwithhost>fn specs.ingress.toPorts.rules.http.withHost</h3> <div class=highlight><pre><span></span><code><span class=nx>withHost</span><span class=p>(</span><span class=nx>host</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Host is an extended POSIX regex matched against the host header of a request, e.g. \"foo.com\" \n If omitted or empty, the value of the host header is ignored."</p> <h3 id=fn-specsingresstoportsruleshttpwithmethod>fn specs.ingress.toPorts.rules.http.withMethod</h3> <div class=highlight><pre><span></span><code><span class=nx>withMethod</span><span class=p>(</span><span class=nx>method</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Method is an extended POSIX regex matched against the method of a request, e.g. \"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\", ... \n If omitted or empty, all methods are allowed."</p> <h3 id=fn-specsingresstoportsruleshttpwithpath>fn specs.ingress.toPorts.rules.http.withPath</h3> <div class=highlight><pre><span></span><code><span class=nx>withPath</span><span class=p>(</span><span class=nx>path</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Path is an extended POSIX regex matched against the path of a request. Currently it can contain characters disallowed from the conventional \"path\" part of a URL as defined by RFC 3986. \n If omitted or empty, all paths are all allowed."</p> <h2 id=obj-specsingresstoportsruleshttpheadermatches>obj specs.ingress.toPorts.rules.http.headerMatches</h2> <p>"HeaderMatches is a list of HTTP headers which must be present and match against the given values. Mismatch field can be used to specify what to do when there is no match."</p> <h3 id=fn-specsingresstoportsruleshttpheadermatcheswithmismatch>fn specs.ingress.toPorts.rules.http.headerMatches.withMismatch</h3> <div class=highlight><pre><span></span><code><span class=nx>withMismatch</span><span class=p>(</span><span class=nx>mismatch</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Mismatch identifies what to do in case there is no match. The default is to drop the request. Otherwise the overall rule is still considered as matching, but the mismatches are logged in the access log."</p> <h3 id=fn-specsingresstoportsruleshttpheadermatcheswithname>fn specs.ingress.toPorts.rules.http.headerMatches.withName</h3> <div class=highlight><pre><span></span><code><span class=nx>withName</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Name identifies the header."</p> <h3 id=fn-specsingresstoportsruleshttpheadermatcheswithvalue>fn specs.ingress.toPorts.rules.http.headerMatches.withValue</h3> <div class=highlight><pre><span></span><code><span class=nx>withValue</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Value matches the exact value of the header. Can be specified either alone or together with \"Secret\"; will be used as the header value if the secret can not be found in the latter case."</p> <h2 id=obj-specsingresstoportsruleshttpheadermatchessecret>obj specs.ingress.toPorts.rules.http.headerMatches.secret</h2> <p>"Secret refers to a secret that contains the value to be matched against. The secret must only contain one entry. If the referred secret does not exist, and there is no \"Value\" specified, the match will fail."</p> <h3 id=fn-specsingresstoportsruleshttpheadermatchessecretwithname>fn specs.ingress.toPorts.rules.http.headerMatches.secret.withName</h3> <div class=highlight><pre><span></span><code><span class=nx>withName</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Name is the name of the secret."</p> <h3 id=fn-specsingresstoportsruleshttpheadermatchessecretwithnamespace>fn specs.ingress.toPorts.rules.http.headerMatches.secret.withNamespace</h3> <div class=highlight><pre><span></span><code><span class=nx>withNamespace</span><span class=p>(</span><span class=nx>namespace</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\")."</p> <h2 id=obj-specsingresstoportsruleskafka>obj specs.ingress.toPorts.rules.kafka</h2> <p>"Kafka-specific rules."</p> <h3 id=fn-specsingresstoportsruleskafkawithapikey>fn specs.ingress.toPorts.rules.kafka.withApiKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withApiKey</span><span class=p>(</span><span class=nx>apiKey</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"APIKey is a case-insensitive string matched against the key of a request, e.g. \"produce\", \"fetch\", \"createtopic\", \"deletetopic\", et al Reference: https://kafka.apache.org/protocol#protocol_api_keys \n If omitted or empty, and if Role is not specified, then all keys are allowed."</p> <h3 id=fn-specsingresstoportsruleskafkawithapiversion>fn specs.ingress.toPorts.rules.kafka.withApiVersion</h3> <div class=highlight><pre><span></span><code><span class=nx>withApiVersion</span><span class=p>(</span><span class=nx>apiVersion</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"APIVersion is the version matched against the api version of the Kafka message. If set, it has to be a string representing a positive integer. \n If omitted or empty, all versions are allowed."</p> <h3 id=fn-specsingresstoportsruleskafkawithclientid>fn specs.ingress.toPorts.rules.kafka.withClientID</h3> <div class=highlight><pre><span></span><code><span class=nx>withClientID</span><span class=p>(</span><span class=nx>clientID</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ClientID is the client identifier as provided in the request. \n From Kafka protocol documentation: This is a user supplied identifier for the client application. The user can use any identifier they like and it will be used when logging errors, monitoring aggregates, etc. For example, one might want to monitor not just the requests per second overall, but the number coming from each client application (each of which could reside on multiple servers). This id acts as a logical grouping across all requests from a particular client. \n If omitted or empty, all client identifiers are allowed."</p> <h3 id=fn-specsingresstoportsruleskafkawithrole>fn specs.ingress.toPorts.rules.kafka.withRole</h3> <div class=highlight><pre><span></span><code><span class=nx>withRole</span><span class=p>(</span><span class=nx>role</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Role is a case-insensitive string and describes a group of API keys necessary to perform certain higher-level Kafka operations such as \"produce\" or \"consume\". A Role automatically expands into all APIKeys required to perform the specified higher-level operation. \n The following values are supported: - \"produce\": Allow producing to the topics specified in the rule - \"consume\": Allow consuming from the topics specified in the rule \n This field is incompatible with the APIKey field, i.e APIKey and Role cannot both be specified in the same rule. \n If omitted or empty, and if APIKey is not specified, then all keys are allowed."</p> <h3 id=fn-specsingresstoportsruleskafkawithtopic>fn specs.ingress.toPorts.rules.kafka.withTopic</h3> <div class=highlight><pre><span></span><code><span class=nx>withTopic</span><span class=p>(</span><span class=nx>topic</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Topic is the topic name contained in the message. If a Kafka request contains multiple topics, then all topics must be allowed or the message will be rejected. \n This constraint is ignored if the matched request message type doesn't contain any topic. Maximum size of Topic can be 249 characters as per recent Kafka spec and allowed characters are a-z, A-Z, 0-9, -, . and _. \n Older Kafka versions had longer topic lengths of 255, but in Kafka 0.10 version the length was changed from 255 to 249. For compatibility reasons we are using 255. \n If omitted or empty, all topics are allowed."</p> <h2 id=obj-specsingresstoportsterminatingtls>obj specs.ingress.toPorts.terminatingTLS</h2> <p>"TerminatingTLS is the TLS context for the connection terminated by the L7 proxy. For egress policy this specifies the server-side TLS parameters to be applied on the connections originated from the local endpoint and terminated by the L7 proxy. For ingress policy this specifies the server-side TLS parameters to be applied on the connections originated from a remote source and terminated by the L7 proxy."</p> <h3 id=fn-specsingresstoportsterminatingtlswithcertificate>fn specs.ingress.toPorts.terminatingTLS.withCertificate</h3> <div class=highlight><pre><span></span><code><span class=nx>withCertificate</span><span class=p>(</span><span class=nx>certificate</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Certificate is the file name or k8s secret item name for the certificate chain. If omitted, 'tls.crt' is assumed, if it exists. If given, the item must exist."</p> <h3 id=fn-specsingresstoportsterminatingtlswithprivatekey>fn specs.ingress.toPorts.terminatingTLS.withPrivateKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withPrivateKey</span><span class=p>(</span><span class=nx>privateKey</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"PrivateKey is the file name or k8s secret item name for the private key matching the certificate chain. If omitted, 'tls.key' is assumed, if it exists. If given, the item must exist."</p> <h3 id=fn-specsingresstoportsterminatingtlswithtrustedca>fn specs.ingress.toPorts.terminatingTLS.withTrustedCA</h3> <div class=highlight><pre><span></span><code><span class=nx>withTrustedCA</span><span class=p>(</span><span class=nx>trustedCA</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"TrustedCA is the file name or k8s secret item name for the trusted CA. If omitted, 'ca.crt' is assumed, if it exists. If given, the item must exist."</p> <h2 id=obj-specsingresstoportsterminatingtlssecret>obj specs.ingress.toPorts.terminatingTLS.secret</h2> <p>"Secret is the secret that contains the certificates and private key for the TLS context. By default, Cilium will search in this secret for the following items: - 'ca.crt' - Which represents the trusted CA to verify remote source. - 'tls.crt' - Which represents the public key certificate. - 'tls.key' - Which represents the private key matching the public key certificate."</p> <h3 id=fn-specsingresstoportsterminatingtlssecretwithname>fn specs.ingress.toPorts.terminatingTLS.secret.withName</h3> <div class=highlight><pre><span></span><code><span class=nx>withName</span><span class=p>(</span><span class=nx>name</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Name is the name of the secret."</p> <h3 id=fn-specsingresstoportsterminatingtlssecretwithnamespace>fn specs.ingress.toPorts.terminatingTLS.secret.withNamespace</h3> <div class=highlight><pre><span></span><code><span class=nx>withNamespace</span><span class=p>(</span><span class=nx>namespace</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Namespace is the namespace in which the secret exists. Context of use determines the default value if left out (e.g., \"default\")."</p> <h2 id=obj-specsingressdeny>obj specs.ingressDeny</h2> <p>"IngressDeny is a list of IngressDenyRule which are enforced at ingress. Any rule inserted here will by denied regardless of the allowed ingress rules in the 'ingress' field. If omitted or empty, this rule does not apply at ingress."</p> <h3 id=fn-specsingressdenywithfromcidr>fn specs.ingressDeny.withFromCIDR</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromCIDR</span><span class=p>(</span><span class=nx>fromCIDR</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do <em>not</em> originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.3.9.1"</p> <h3 id=fn-specsingressdenywithfromcidrmixin>fn specs.ingressDeny.withFromCIDRMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromCIDRMixin</span><span class=p>(</span><span class=nx>fromCIDR</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromCIDR is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from. Only connections which do <em>not</em> originate from the cluster or from the local host are subject to CIDR rules. In order to allow in-cluster connectivity, use the FromEndpoints field. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.3.9.1"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsingressdenywithfromcidrset>fn specs.ingressDeny.withFromCIDRSet</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromCIDRSet</span><span class=p>(</span><span class=nx>fromCIDRSet</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12."</p> <h3 id=fn-specsingressdenywithfromcidrsetmixin>fn specs.ingressDeny.withFromCIDRSetMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromCIDRSetMixin</span><span class=p>(</span><span class=nx>fromCIDRSet</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsingressdenywithfromendpoints>fn specs.ingressDeny.withFromEndpoints</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromEndpoints</span><span class=p>(</span><span class=nx>fromEndpoints</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule. \n Example: Any endpoint with the label \"role=backend\" can be consumed by any endpoint carrying the label \"role=frontend\"."</p> <h3 id=fn-specsingressdenywithfromendpointsmixin>fn specs.ingressDeny.withFromEndpointsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromEndpointsMixin</span><span class=p>(</span><span class=nx>fromEndpoints</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule. \n Example: Any endpoint with the label \"role=backend\" can be consumed by any endpoint carrying the label \"role=frontend\"."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsingressdenywithfromentities>fn specs.ingressDeny.withFromEntities</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromEntities</span><span class=p>(</span><span class=nx>fromEntities</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are <code>world</code>, <code>cluster</code> and <code>host</code>"</p> <h3 id=fn-specsingressdenywithfromentitiesmixin>fn specs.ingressDeny.withFromEntitiesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromEntitiesMixin</span><span class=p>(</span><span class=nx>fromEntities</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromEntities is a list of special entities which the endpoint subject to the rule is allowed to receive connections from. Supported entities are <code>world</code>, <code>cluster</code> and <code>host</code>"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsingressdenywithfromrequires>fn specs.ingressDeny.withFromRequires</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromRequires</span><span class=p>(</span><span class=nx>fromRequires</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires consuming endpoint to also carry the label \"team=A\"."</p> <h3 id=fn-specsingressdenywithfromrequiresmixin>fn specs.ingressDeny.withFromRequiresMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withFromRequiresMixin</span><span class=p>(</span><span class=nx>fromRequires</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires consuming endpoint to also carry the label \"team=A\"."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsingressdenywithicmps>fn specs.ingressDeny.withIcmps</h3> <div class=highlight><pre><span></span><code><span class=nx>withIcmps</span><span class=p>(</span><span class=nx>icmps</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can not accept incoming type 8 ICMP connections."</p> <h3 id=fn-specsingressdenywithicmpsmixin>fn specs.ingressDeny.withIcmpsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withIcmpsMixin</span><span class=p>(</span><span class=nx>icmps</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can not accept incoming type 8 ICMP connections."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsingressdenywithtoports>fn specs.ingressDeny.withToPorts</h3> <div class=highlight><pre><span></span><code><span class=nx>withToPorts</span><span class=p>(</span><span class=nx>toPorts</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can not accept incoming connections on port 80/tcp."</p> <h3 id=fn-specsingressdenywithtoportsmixin>fn specs.ingressDeny.withToPortsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withToPortsMixin</span><span class=p>(</span><span class=nx>toPorts</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can not accept incoming connections on port 80/tcp."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsingressdenyfromcidrset>obj specs.ingressDeny.fromCIDRSet</h2> <p>"FromCIDRSet is a list of IP blocks which the endpoint subject to the rule is allowed to receive connections from in addition to FromEndpoints, along with a list of subnets contained within their corresponding IP block from which traffic should not be allowed. This will match on the source IP address of incoming connections. Adding a prefix into FromCIDR or into FromCIDRSet with no ExcludeCIDRs is equivalent. Overlaps are allowed between FromCIDR and FromCIDRSet. \n Example: Any endpoint with the label \"app=my-legacy-pet\" is allowed to receive connections from 10.0.0.0/8 except from IPs in subnet 10.96.0.0/12."</p> <h3 id=fn-specsingressdenyfromcidrsetwithcidr>fn specs.ingressDeny.fromCIDRSet.withCidr</h3> <div class=highlight><pre><span></span><code><span class=nx>withCidr</span><span class=p>(</span><span class=nx>cidr</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"CIDR is a CIDR prefix / IP Block."</p> <h3 id=fn-specsingressdenyfromcidrsetwithexcept>fn specs.ingressDeny.fromCIDRSet.withExcept</h3> <div class=highlight><pre><span></span><code><span class=nx>withExcept</span><span class=p>(</span><span class=nx>except</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules."</p> <h3 id=fn-specsingressdenyfromcidrsetwithexceptmixin>fn specs.ingressDeny.fromCIDRSet.withExceptMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withExceptMixin</span><span class=p>(</span><span class=nx>except</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"ExceptCIDRs is a list of IP blocks which the endpoint subject to the rule is not allowed to initiate connections to. These CIDR prefixes should be contained within Cidr. These exceptions are only applied to the Cidr in this CIDRRule, and do not apply to any other CIDR prefixes in any other CIDRRules."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsingressdenyfromendpoints>obj specs.ingressDeny.fromEndpoints</h2> <p>"FromEndpoints is a list of endpoints identified by an EndpointSelector which are allowed to communicate with the endpoint subject to the rule. \n Example: Any endpoint with the label \"role=backend\" can be consumed by any endpoint carrying the label \"role=frontend\"."</p> <h3 id=fn-specsingressdenyfromendpointswithmatchexpressions>fn specs.ingressDeny.fromEndpoints.withMatchExpressions</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressions</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specsingressdenyfromendpointswithmatchexpressionsmixin>fn specs.ingressDeny.fromEndpoints.withMatchExpressionsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressionsMixin</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsingressdenyfromendpointswithmatchlabels>fn specs.ingressDeny.fromEndpoints.withMatchLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabels</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <h3 id=fn-specsingressdenyfromendpointswithmatchlabelsmixin>fn specs.ingressDeny.fromEndpoints.withMatchLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabelsMixin</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsingressdenyfromendpointsmatchexpressions>obj specs.ingressDeny.fromEndpoints.matchExpressions</h2> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specsingressdenyfromendpointsmatchexpressionswithkey>fn specs.ingressDeny.fromEndpoints.matchExpressions.withKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withKey</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"key is the label key that the selector applies to."</p> <h3 id=fn-specsingressdenyfromendpointsmatchexpressionswithoperator>fn specs.ingressDeny.fromEndpoints.matchExpressions.withOperator</h3> <div class=highlight><pre><span></span><code><span class=nx>withOperator</span><span class=p>(</span><span class=nx>operator</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist."</p> <h3 id=fn-specsingressdenyfromendpointsmatchexpressionswithvalues>fn specs.ingressDeny.fromEndpoints.matchExpressions.withValues</h3> <div class=highlight><pre><span></span><code><span class=nx>withValues</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <h3 id=fn-specsingressdenyfromendpointsmatchexpressionswithvaluesmixin>fn specs.ingressDeny.fromEndpoints.matchExpressions.withValuesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withValuesMixin</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsingressdenyfromrequires>obj specs.ingressDeny.fromRequires</h2> <p>"FromRequires is a list of additional constraints which must be met in order for the selected endpoints to be reachable. These additional constraints do no by itself grant access privileges and must always be accompanied with at least one matching FromEndpoints. \n Example: Any Endpoint with the label \"team=A\" requires consuming endpoint to also carry the label \"team=A\"."</p> <h3 id=fn-specsingressdenyfromrequireswithmatchexpressions>fn specs.ingressDeny.fromRequires.withMatchExpressions</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressions</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specsingressdenyfromrequireswithmatchexpressionsmixin>fn specs.ingressDeny.fromRequires.withMatchExpressionsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressionsMixin</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsingressdenyfromrequireswithmatchlabels>fn specs.ingressDeny.fromRequires.withMatchLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabels</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <h3 id=fn-specsingressdenyfromrequireswithmatchlabelsmixin>fn specs.ingressDeny.fromRequires.withMatchLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabelsMixin</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsingressdenyfromrequiresmatchexpressions>obj specs.ingressDeny.fromRequires.matchExpressions</h2> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specsingressdenyfromrequiresmatchexpressionswithkey>fn specs.ingressDeny.fromRequires.matchExpressions.withKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withKey</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"key is the label key that the selector applies to."</p> <h3 id=fn-specsingressdenyfromrequiresmatchexpressionswithoperator>fn specs.ingressDeny.fromRequires.matchExpressions.withOperator</h3> <div class=highlight><pre><span></span><code><span class=nx>withOperator</span><span class=p>(</span><span class=nx>operator</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist."</p> <h3 id=fn-specsingressdenyfromrequiresmatchexpressionswithvalues>fn specs.ingressDeny.fromRequires.matchExpressions.withValues</h3> <div class=highlight><pre><span></span><code><span class=nx>withValues</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <h3 id=fn-specsingressdenyfromrequiresmatchexpressionswithvaluesmixin>fn specs.ingressDeny.fromRequires.matchExpressions.withValuesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withValuesMixin</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsingressdenyicmps>obj specs.ingressDeny.icmps</h2> <p>"ICMPs is a list of ICMP rule identified by type number which the endpoint subject to the rule is not allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can not accept incoming type 8 ICMP connections."</p> <h3 id=fn-specsingressdenyicmpswithfields>fn specs.ingressDeny.icmps.withFields</h3> <div class=highlight><pre><span></span><code><span class=nx>withFields</span><span class=p>(</span><span class=nx>fields</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Fields is a list of ICMP fields."</p> <h3 id=fn-specsingressdenyicmpswithfieldsmixin>fn specs.ingressDeny.icmps.withFieldsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withFieldsMixin</span><span class=p>(</span><span class=nx>fields</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Fields is a list of ICMP fields."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsingressdenyicmpsfields>obj specs.ingressDeny.icmps.fields</h2> <p>"Fields is a list of ICMP fields."</p> <h3 id=fn-specsingressdenyicmpsfieldswithfamily>fn specs.ingressDeny.icmps.fields.withFamily</h3> <div class=highlight><pre><span></span><code><span class=nx>withFamily</span><span class=p>(</span><span class=nx>family</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Family is a IP address version. Currently, we support <code>IPv4</code> and <code>IPv6</code>. <code>IPv4</code> is set as default."</p> <h3 id=fn-specsingressdenyicmpsfieldswithtype>fn specs.ingressDeny.icmps.fields.withType</h3> <div class=highlight><pre><span></span><code><span class=nx>withType</span><span class=p>(</span><span class=kr>type</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Type is a ICMP-type. It should be 0-255 (8bit)."</p> <h2 id=obj-specsingressdenytoports>obj specs.ingressDeny.toPorts</h2> <p>"ToPorts is a list of destination ports identified by port number and protocol which the endpoint subject to the rule is not allowed to receive connections on. \n Example: Any endpoint with the label \"app=httpd\" can not accept incoming connections on port 80/tcp."</p> <h3 id=fn-specsingressdenytoportswithports>fn specs.ingressDeny.toPorts.withPorts</h3> <div class=highlight><pre><span></span><code><span class=nx>withPorts</span><span class=p>(</span><span class=nx>ports</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Ports is a list of L4 port/protocol"</p> <h3 id=fn-specsingressdenytoportswithportsmixin>fn specs.ingressDeny.toPorts.withPortsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withPortsMixin</span><span class=p>(</span><span class=nx>ports</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Ports is a list of L4 port/protocol"</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsingressdenytoportsports>obj specs.ingressDeny.toPorts.ports</h2> <p>"Ports is a list of L4 port/protocol"</p> <h3 id=fn-specsingressdenytoportsportswithport>fn specs.ingressDeny.toPorts.ports.withPort</h3> <div class=highlight><pre><span></span><code><span class=nx>withPort</span><span class=p>(</span><span class=nx>port</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Port is an L4 port number. For now the string will be strictly parsed as a single uint16. In the future, this field may support ranges in the form \"1024-2048 Port can also be a port name, which must contain at least one [a-z], and may also contain [0-9] and '-' anywhere except adjacent to another '-' or in the beginning or the end."</p> <h3 id=fn-specsingressdenytoportsportswithprotocol>fn specs.ingressDeny.toPorts.ports.withProtocol</h3> <div class=highlight><pre><span></span><code><span class=nx>withProtocol</span><span class=p>(</span><span class=nx>protocol</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Protocol is the L4 protocol. If omitted or empty, any protocol matches. Accepted values: \"TCP\", \"UDP\", \"\"/\"ANY\" \n Matching on ICMP is not supported. \n Named port specified for a container may narrow this down, but may not contradict this."</p> <h2 id=obj-specslabels>obj specs.labels</h2> <p>"Labels is a list of optional strings which can be used to re-identify the rule or to store metadata. It is possible to lookup or delete strings based on labels. Labels are not required to be unique, multiple rules can have overlapping or identical labels."</p> <h3 id=fn-specslabelswithkey>fn specs.labels.withKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withKey</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h3 id=fn-specslabelswithsource>fn specs.labels.withSource</h3> <div class=highlight><pre><span></span><code><span class=nx>withSource</span><span class=p>(</span><span class=nx>source</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"Source can be one of the above values (e.g.: LabelSourceContainer)."</p> <h3 id=fn-specslabelswithvalue>fn specs.labels.withValue</h3> <div class=highlight><pre><span></span><code><span class=nx>withValue</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span><span class=w></span>
</code></pre></div> <h2 id=obj-specsnodeselector>obj specs.nodeSelector</h2> <p>"NodeSelector selects all nodes which should be subject to this rule. EndpointSelector and NodeSelector cannot be both empty and are mutually exclusive. Can only be used in CiliumClusterwideNetworkPolicies."</p> <h3 id=fn-specsnodeselectorwithmatchexpressions>fn specs.nodeSelector.withMatchExpressions</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressions</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specsnodeselectorwithmatchexpressionsmixin>fn specs.nodeSelector.withMatchExpressionsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchExpressionsMixin</span><span class=p>(</span><span class=nx>matchExpressions</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h3 id=fn-specsnodeselectorwithmatchlabels>fn specs.nodeSelector.withMatchLabels</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabels</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <h3 id=fn-specsnodeselectorwithmatchlabelsmixin>fn specs.nodeSelector.withMatchLabelsMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withMatchLabelsMixin</span><span class=p>(</span><span class=nx>matchLabels</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \"key\", the operator is \"In\", and the values array contains only \"value\". The requirements are ANDed."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> <h2 id=obj-specsnodeselectormatchexpressions>obj specs.nodeSelector.matchExpressions</h2> <p>"matchExpressions is a list of label selector requirements. The requirements are ANDed."</p> <h3 id=fn-specsnodeselectormatchexpressionswithkey>fn specs.nodeSelector.matchExpressions.withKey</h3> <div class=highlight><pre><span></span><code><span class=nx>withKey</span><span class=p>(</span><span class=nx>key</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"key is the label key that the selector applies to."</p> <h3 id=fn-specsnodeselectormatchexpressionswithoperator>fn specs.nodeSelector.matchExpressions.withOperator</h3> <div class=highlight><pre><span></span><code><span class=nx>withOperator</span><span class=p>(</span><span class=nx>operator</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist."</p> <h3 id=fn-specsnodeselectormatchexpressionswithvalues>fn specs.nodeSelector.matchExpressions.withValues</h3> <div class=highlight><pre><span></span><code><span class=nx>withValues</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <h3 id=fn-specsnodeselectormatchexpressionswithvaluesmixin>fn specs.nodeSelector.matchExpressions.withValuesMixin</h3> <div class=highlight><pre><span></span><code><span class=nx>withValuesMixin</span><span class=p>(</span><span class=nx>values</span><span class=p>)</span><span class=w></span>
</code></pre></div> <p>"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch."</p> <p><strong>Note:</strong> This function appends passed data to existing values</p> </article> </div> </div> </main> <footer class=md-footer> <nav class="md-footer__inner md-grid" aria-label=Footer> <a href=../ciliumLocalRedirectPolicy/ class="md-footer__link md-footer__link--prev" aria-label="Previous: cilium.v2.ciliumLocalRedirectPolicy" rel=prev> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg> </div> <div class=md-footer__title> <div class=md-ellipsis> <span class=md-footer__direction> Previous </span> cilium.v2.ciliumLocalRedirectPolicy </div> </div> </a> <a href=../ciliumNode/ class="md-footer__link md-footer__link--next" aria-label="Next: cilium.v2.ciliumNode" rel=next> <div class=md-footer__title> <div class=md-ellipsis> <span class=md-footer__direction> Next </span> cilium.v2.ciliumNode </div> </div> <div class="md-footer__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg> </div> </a> </nav> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "../../../..", "features": [], "search": "../../../../assets/javascripts/workers/search.5bf1dace.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}}</script> <script src=../../../../assets/javascripts/bundle.078830c0.min.js></script> </body> </html>